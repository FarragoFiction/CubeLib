@JS()
library babylon;

import "package:js/js.dart";
import "package:func/func.dart";
import "dart:typed_data" show ByteBuffer, Uint8List, Float32List, Int32List, Uint32List, Uint16List, TypedData;
import "dart:html" show HttpRequest, CanvasElement, Event, HtmlElement, ImageElement, Blob, VideoElement, KeyboardEvent, ProgressEvent, File, Worker, DeviceOrientationEvent, FocusEvent, ButtonElement, GamepadButton, CanvasRenderingContext2D, Window, Document, MouseEvent, Navigator, Element, Screen, EventTarget, Gamepad, ErrorEvent, MediaStream;
import "dart:web_audio" show AudioNode, AudioContext, GainNode, AudioBuffer;
import "dart:web_gl" show ContextAttributes, RenderingContext, Program, Buffer, Framebuffer, UniformLocation, Texture, ContextEvent, Renderbuffer;
import "dart:math" show Rectangle;

part "babylon_manual_types.dart";

// Module babylonjs
/* WARNING: export assignment not yet supported. */

// End module babylonjs

// Module BABYLON
/// Defines how the parser contract is defined.
/// These parsers are used to parse a list of specific assets (like particle systems, etc..)
typedef void BabylonFileParser(dynamic parsedData, Scene scene, AssetContainer container, String rootUrl);

/// Defines how the individual parser contract is defined.
/// These parser can parse an individual asset
typedef dynamic IndividualBabylonFileParser(dynamic parsedData, Scene scene, String rootUrl);

/// Base class of the scene acting as a container for the different elements composing a scene.
/// This class is dynamically extended by the different components of the scene increasing
/// flexibility and reducing coupling
@JS("BABYLON.AbstractScene")
abstract class AbstractScene {
    // @Ignore
    AbstractScene .fakeConstructor$();

    /// Stores the list of available parsers in the application.
    external static get JS$_BabylonFileParsers;

    external static set JS$_BabylonFileParsers(v);

    /// Stores the list of available individual parsers in the application.
    external static get JS$_IndividualBabylonFileParsers;

    external static set JS$_IndividualBabylonFileParsers(v);

    /// Adds a parser in the list of available ones
    external static void AddParser(String name, BabylonFileParser parser);

    /// Gets a general parser from the list of avaialble ones
    external static BabylonFileParser/*BabylonFileParser|Null*/ GetParser(String name);

    /// Adds n individual parser in the list of available ones
    external static void AddIndividualParser(String name, IndividualBabylonFileParser parser);

    /// Gets an individual parser from the list of avaialble ones
    external static IndividualBabylonFileParser/*IndividualBabylonFileParser|Null*/ GetIndividualParser(String name);

    /// Parser json data and populate both a scene and its associated container object
    external static void Parse(dynamic jsonData, Scene scene, AssetContainer container, String rootUrl);

    /// Gets the list of root nodes (ie. nodes with no parent)
    external List<Node> get rootNodes;

    external set rootNodes(List<Node> v);

    /// All of the cameras added to this scene
    /// @see http://doc.babylonjs.com/babylon101/cameras
    external List<Camera> get cameras;

    external set cameras(List<Camera> v);

    /// All of the lights added to this scene
    /// @see http://doc.babylonjs.com/babylon101/lights
    external List<Light> get lights;

    external set lights(List<Light> v);

    /// All of the (abstract) meshes added to this scene
    external List<AbstractMesh> get meshes;

    external set meshes(List<AbstractMesh> v);

    /// The list of skeletons added to the scene
    /// @see http://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons
    external List<Skeleton> get skeletons;

    external set skeletons(List<Skeleton> v);

    /// All of the particle systems added to this scene
    /// @see http://doc.babylonjs.com/babylon101/particles
    external List<IParticleSystem> get particleSystems;

    external set particleSystems(List<IParticleSystem> v);

    /// Gets a list of Animations associated with the scene
    external List<Animation> get animations;

    external set animations(List<Animation> v);

    /// All of the animation groups added to this scene
    /// @see http://doc.babylonjs.com/how_to/group
    external List<AnimationGroup> get animationGroups;

    external set animationGroups(List<AnimationGroup> v);

    /// All of the multi-materials added to this scene
    /// @see http://doc.babylonjs.com/how_to/multi_materials
    external List<MultiMaterial> get multiMaterials;

    external set multiMaterials(List<MultiMaterial> v);

    /// All of the materials added to this scene
    /// @see http://doc.babylonjs.com/babylon101/materials
    external List<Material> get materials;

    external set materials(List<Material> v);

    /// The list of morph target managers added to the scene
    /// @see http://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh
    external List<MorphTargetManager> get morphTargetManagers;

    external set morphTargetManagers(List<MorphTargetManager> v);

    /// The list of geometries used in the scene.
    external List<Geometry> get geometries;

    external set geometries(List<Geometry> v);

    /// All of the tranform nodes added to this scene
    /// @see http://doc.babylonjs.com/how_to/transformnode
    external List<TransformNode> get transformNodes;

    external set transformNodes(List<TransformNode> v);

    /// ActionManagers available on the scene.
    external List<ActionManager> get actionManagers;

    external set actionManagers(List<ActionManager> v);

    /// Textures to keep.
    external List<BaseTexture> get textures;

    external set textures(List<BaseTexture> v);

    /// The list of sounds used in the scene.
    external List<Sound>/*List<Sound>|Null*/ get sounds;

    external set sounds(List<Sound>/*List<Sound>|Null*/ v);

    /// The list of effect layers (highlights/glow) added to the scene
    /// @see http://doc.babylonjs.com/how_to/highlight_layer
    /// @see http://doc.babylonjs.com/how_to/glow_layer
    external List<EffectLayer> get effectLayers;

    external set effectLayers(List<EffectLayer> v);

    /// Removes the given effect layer from this scene.
    external num removeEffectLayer(EffectLayer toRemove);

    /// Adds the given effect layer to this scene
    external void addEffectLayer(EffectLayer newEffectLayer);

    /// Return a the first highlight layer of the scene with a given name.
    external GlowLayer/*GlowLayer|Null*/ getGlowLayerByName(String name);

    /// Return a the first highlight layer of the scene with a given name.
    external HighlightLayer/*HighlightLayer|Null*/ getHighlightLayerByName(String name);

    /// The list of layers (background and foreground) of the scene
    external List<Layer> get layers;

    external set layers(List<Layer> v);

    /// The list of lens flare system added to the scene
    /// @see http://doc.babylonjs.com/how_to/how_to_use_lens_flares
    external List<LensFlareSystem> get lensFlareSystems;

    external set lensFlareSystems(List<LensFlareSystem> v);

    /// Removes the given lens flare system from this scene.
    external num removeLensFlareSystem(LensFlareSystem toRemove);

    /// Adds the given lens flare system to this scene
    external void addLensFlareSystem(LensFlareSystem newLensFlareSystem);

    /// Gets a lens flare system using its name
    external LensFlareSystem/*LensFlareSystem|Null*/ getLensFlareSystemByName(String name);

    /// Gets a lens flare system using its id
    external LensFlareSystem/*LensFlareSystem|Null*/ getLensFlareSystemByID(String id);

    /// The list of procedural textures added to the scene
    /// @see http://doc.babylonjs.com/how_to/how_to_use_procedural_textures
    external List<ProceduralTexture> get proceduralTextures;

    external set proceduralTextures(List<ProceduralTexture> v);
}

@JS("BABYLON.KeepAssets")
class KeepAssets extends AbstractScene {
    // @Ignore
    KeepAssets .fakeConstructor$() : super.fakeConstructor$();
}

@JS("BABYLON.AssetContainer")
class AssetContainer extends AbstractScene {
    // @Ignore
    AssetContainer .fakeConstructor$() : super.fakeConstructor$();
    external Scene get scene;

    external set scene(Scene v);

    external factory AssetContainer(Scene scene);

    external void addAllToScene();

    external void removeAllFromScene();

    external get JS$_moveAssets;

    external set JS$_moveAssets(v);

    external void moveAllFromScene([KeepAssets keepAssets]);

    external Mesh createRootMesh();
}

typedef Func0<Node> NodeConstructor(String name, Scene scene, [dynamic options]);

@JS("BABYLON.Node")
class Node implements IBehaviorAware<Node> {
    // @Ignore
    Node .fakeConstructor$();

    external static get JS$_NodeConstructors;

    external static set JS$_NodeConstructors(v);

    external static void AddNodeConstructor(String type, NodeConstructor constructorFunc);

    external static Func0<Node>/*Func0<Node>|Null*/ Construct(String type, String name, Scene scene, [dynamic options]);

    external String get name;

    external set name(String v);

    external String get id;

    external set id(String v);

    external num get uniqueId;

    external set uniqueId(num v);

    external String get state;

    external set state(String v);

    external dynamic get metadata;

    external set metadata(dynamic v);

    external bool get doNotSerialize;

    external set doNotSerialize(bool v);

    external bool get JS$_isDisposed;

    external set JS$_isDisposed(bool v);

    external List<Animation> get animations;

    external set animations(List<Animation> v);

    external dynamic/*JSMap of <String,AnimationRange|Null>*/ get JS$_ranges;

    external set JS$_ranges(dynamic/*JSMap of <String,AnimationRange|Null>*/ v);

    external VoidFunc1<Node> get onReady;

    external set onReady(VoidFunc1<Node> v);

    external get JS$_isEnabled;

    external set JS$_isEnabled(v);

    external get JS$_isParentEnabled;

    external set JS$_isParentEnabled(v);

    external get JS$_isReady;

    external set JS$_isReady(v);

    external num get JS$_currentRenderId;

    external set JS$_currentRenderId(num v);

    external get JS$_parentRenderId;

    external set JS$_parentRenderId(v);

    external num get JS$_childRenderId;

    external set JS$_childRenderId(num v);

    external String/*String|Null*/ get JS$_waitingParentId;

    external set JS$_waitingParentId(String/*String|Null*/ v);

    external Scene get JS$_scene;

    external set JS$_scene(Scene v);

    external dynamic get JS$_cache;

    external set JS$_cache(dynamic v);

    external get JS$_parentNode;

    external set JS$_parentNode(v);

    external get JS$_children;

    external set JS$_children(v);

    external Matrix get JS$_worldMatrix;

    external set JS$_worldMatrix(Matrix v);

    external num get JS$_worldMatrixDeterminant;

    external set JS$_worldMatrixDeterminant(num v);

    external get JS$_sceneRootNodesIndex;

    external set JS$_sceneRootNodesIndex(v);

    external bool isDisposed();

    external Node/*Node|Null*/ get parent;

    external set parent(Node/*Node|Null*/ v);

    external get addToSceneRootNodes;

    external set addToSceneRootNodes(v);

    external get removeFromSceneRootNodes;

    external set removeFromSceneRootNodes(v);

    external get JS$_animationPropertiesOverride;

    external set JS$_animationPropertiesOverride(v);

    external AnimationPropertiesOverride/*AnimationPropertiesOverride|Null*/ get animationPropertiesOverride;

    external set animationPropertiesOverride(AnimationPropertiesOverride/*AnimationPropertiesOverride|Null*/ v);

    external String getClassName();

    external Observable<Node> get onDisposeObservable;

    external set onDisposeObservable(Observable<Node> v);

    external get JS$_onDisposeObserver;

    external set JS$_onDisposeObserver(v);

    external VoidFunc0 get onDispose;

    external set onDispose(VoidFunc0 v);

    external factory Node(String name, [Scene/*Scene|Null*/ scene]);

    external Scene getScene();

    external Engine getEngine();

    external get JS$_behaviors;

    external set JS$_behaviors(v);

    external Node addBehavior(Behavior<Node> behavior, [bool attachImmediately]);

    external Node removeBehavior(Behavior<Node> behavior);

    external List<Behavior<Node>> get behaviors;

    external set behaviors(List<Behavior<Node>> v);

    external Behavior<Node>/*Behavior<Node>|Null*/ getBehaviorByName(String name);

    external Matrix getWorldMatrix();

    external num JS$_getWorldMatrixDeterminant();

    external Matrix get worldMatrixFromCache;

    external set worldMatrixFromCache(Matrix v);

    external void JS$_initCache();

    external void updateCache([bool force]);

    external void JS$_updateCache([bool ignoreParentClass]);

    external bool JS$_isSynchronized();

    external void JS$_markSyncedWithParent();

    external bool isSynchronizedWithParent();

    external bool isSynchronized();

    external bool isReady([bool completeCheck]);

    external bool isEnabled([bool checkAncestors]);

    external void JS$_syncParentEnabledState();

    external void setEnabled(bool value);

    external bool isDescendantOf(Node ancestor);

    external void JS$_getDescendants(List<Node> results, [bool directDescendantsOnly, bool predicate(Node node)]);

    external List<Node> getDescendants([bool directDescendantsOnly, bool predicate(Node node)]);

    external List<AbstractMesh> getChildMeshes([bool directDescendantsOnly, bool predicate(Node node)]);

    external List<TransformNode> getChildTransformNodes([bool directDescendantsOnly, bool predicate(Node node)]);

    external List<Node> getChildren([bool predicate(Node node)]);

    external void JS$_setReady(bool state);

    external Animation/*Animation|Null*/ getAnimationByName(String name);

    external void createAnimationRange(String name, num from, num to);

    external void deleteAnimationRange(String name, [bool deleteFrames]);

    external AnimationRange/*AnimationRange|Null*/ getAnimationRange(String name);

    external Animatable/*Animatable|Null*/ beginAnimation(String name, [bool loop, num speedRatio, void onAnimationEnd()]);

    external dynamic serializeAnimationRanges();

    external Matrix computeWorldMatrix([bool force]);

    external void dispose([bool doNotRecurse, bool disposeMaterialAndTextures]);

    external static void ParseAnimationRanges(Node node, dynamic parsedNode, Scene scene);
}

@anonymous
@JS()
abstract class IDisposable {
    external void dispose();
}

@JS("BABYLON.RenderingGroupInfo")
class RenderingGroupInfo {
    // @Ignore
    RenderingGroupInfo .fakeConstructor$();

    external Scene get scene;

    external set scene(Scene v);

    external Camera/*Camera|Null*/ get camera;

    external set camera(Camera/*Camera|Null*/ v);

    external num get renderingGroupId;

    external set renderingGroupId(num v);
}

@JS("BABYLON.Scene")
class Scene extends AbstractScene implements IAnimatable {
    // @Ignore
    Scene .fakeConstructor$() : super.fakeConstructor$();
    external static get JS$_uniqueIdCounter;

    external static set JS$_uniqueIdCounter(v);

    external static num get FOGMODE_NONE;

    external static set FOGMODE_NONE(num v);

    external static num get FOGMODE_EXP;

    external static set FOGMODE_EXP(num v);

    external static num get FOGMODE_EXP2;

    external static set FOGMODE_EXP2(num v);

    external static num get FOGMODE_LINEAR;

    external static set FOGMODE_LINEAR(num v);

    external static num get MinDeltaTime;

    external static set MinDeltaTime(num v);

    external static num get MaxDeltaTime;

    external static set MaxDeltaTime(num v);

    external bool get autoClear;

    external set autoClear(bool v);

    external bool get autoClearDepthAndStencil;

    external set autoClearDepthAndStencil(bool v);

    external Color4 get clearColor;

    external set clearColor(Color4 v);

    external Color3 get ambientColor;

    external set ambientColor(Color3 v);

    external BaseTexture get JS$_environmentBRDFTexture;

    external set JS$_environmentBRDFTexture(BaseTexture v);

    external BaseTexture get JS$_environmentTexture;

    external set JS$_environmentTexture(BaseTexture v);

    external BaseTexture get environmentTexture;

    external set environmentTexture(BaseTexture v);

    external ImageProcessingConfiguration get JS$_imageProcessingConfiguration;

    external set JS$_imageProcessingConfiguration(ImageProcessingConfiguration v);

    external ImageProcessingConfiguration get imageProcessingConfiguration;

    external set imageProcessingConfiguration(ImageProcessingConfiguration v);

    external get JS$_forceWireframe;

    external set JS$_forceWireframe(v);

    external bool get forceWireframe;

    external set forceWireframe(bool v);

    external get JS$_forcePointsCloud;

    external set JS$_forcePointsCloud(v);

    external bool get forcePointsCloud;

    external set forcePointsCloud(bool v);

    external Plane/*Plane|Null*/ get clipPlane;

    external set clipPlane(Plane/*Plane|Null*/ v);

    external Plane/*Plane|Null*/ get clipPlane2;

    external set clipPlane2(Plane/*Plane|Null*/ v);

    external Plane/*Plane|Null*/ get clipPlane3;

    external set clipPlane3(Plane/*Plane|Null*/ v);

    external Plane/*Plane|Null*/ get clipPlane4;

    external set clipPlane4(Plane/*Plane|Null*/ v);

    external bool get animationsEnabled;

    external set animationsEnabled(bool v);

    external get JS$_animationPropertiesOverride;

    external set JS$_animationPropertiesOverride(v);

    external AnimationPropertiesOverride/*AnimationPropertiesOverride|Null*/ get animationPropertiesOverride;

    external set animationPropertiesOverride(AnimationPropertiesOverride/*AnimationPropertiesOverride|Null*/ v);

    external bool get useConstantAnimationDeltaTime;

    external set useConstantAnimationDeltaTime(bool v);

    external bool get constantlyUpdateMeshUnderPointer;

    external set constantlyUpdateMeshUnderPointer(bool v);

    external String get hoverCursor;

    external set hoverCursor(String v);

    external String get defaultCursor;

    external set defaultCursor(String v);

    external bool get preventDefaultOnPointerDown;

    external set preventDefaultOnPointerDown(bool v);

    external dynamic get metadata;

    external set metadata(dynamic v);

    external String get loadingPluginName;

    external set loadingPluginName(String v);

    external List<RegExp> get disableOfflineSupportExceptionRules;

    external set disableOfflineSupportExceptionRules(List<RegExp> v);

    external Observable<Scene> get onDisposeObservable;

    external set onDisposeObservable(Observable<Scene> v);

    external get JS$_onDisposeObserver;

    external set JS$_onDisposeObserver(v);

    external VoidFunc0 get onDispose;

    external set onDispose(VoidFunc0 v);

    external Observable<Scene> get onBeforeRenderObservable;

    external set onBeforeRenderObservable(Observable<Scene> v);

    external get JS$_onBeforeRenderObserver;

    external set JS$_onBeforeRenderObserver(v);

    external VoidFunc0/*VoidFunc0|Null*/ get beforeRender;

    external set beforeRender(VoidFunc0/*VoidFunc0|Null*/ v);

    external Observable<Scene> get onAfterRenderObservable;

    external set onAfterRenderObservable(Observable<Scene> v);

    external get JS$_onAfterRenderObserver;

    external set JS$_onAfterRenderObserver(v);

    external VoidFunc0/*VoidFunc0|Null*/ get afterRender;

    external set afterRender(VoidFunc0/*VoidFunc0|Null*/ v);

    external Observable<Scene> get onBeforeAnimationsObservable;

    external set onBeforeAnimationsObservable(Observable<Scene> v);

    external Observable<Scene> get onAfterAnimationsObservable;

    external set onAfterAnimationsObservable(Observable<Scene> v);

    external Observable<Scene> get onBeforeDrawPhaseObservable;

    external set onBeforeDrawPhaseObservable(Observable<Scene> v);

    external Observable<Scene> get onAfterDrawPhaseObservable;

    external set onAfterDrawPhaseObservable(Observable<Scene> v);

    external Observable<Scene> get onReadyObservable;

    external set onReadyObservable(Observable<Scene> v);

    external Observable<Camera> get onBeforeCameraRenderObservable;

    external set onBeforeCameraRenderObservable(Observable<Camera> v);

    external get JS$_onBeforeCameraRenderObserver;

    external set JS$_onBeforeCameraRenderObserver(v);

    external VoidFunc0 get beforeCameraRender;

    external set beforeCameraRender(VoidFunc0 v);

    external Observable<Camera> get onAfterCameraRenderObservable;

    external set onAfterCameraRenderObservable(Observable<Camera> v);

    external get JS$_onAfterCameraRenderObserver;

    external set JS$_onAfterCameraRenderObserver(v);

    external VoidFunc0 get afterCameraRender;

    external set afterCameraRender(VoidFunc0 v);

    external Observable<Scene> get onBeforeActiveMeshesEvaluationObservable;

    external set onBeforeActiveMeshesEvaluationObservable(Observable<Scene> v);

    external Observable<Scene> get onAfterActiveMeshesEvaluationObservable;

    external set onAfterActiveMeshesEvaluationObservable(Observable<Scene> v);

    external Observable<Scene> get onBeforeParticlesRenderingObservable;

    external set onBeforeParticlesRenderingObservable(Observable<Scene> v);

    external Observable<Scene> get onAfterParticlesRenderingObservable;

    external set onAfterParticlesRenderingObservable(Observable<Scene> v);

    external Observable<Scene> get onDataLoadedObservable;

    external set onDataLoadedObservable(Observable<Scene> v);

    external Observable<Camera> get onNewCameraAddedObservable;

    external set onNewCameraAddedObservable(Observable<Camera> v);

    external Observable<Camera> get onCameraRemovedObservable;

    external set onCameraRemovedObservable(Observable<Camera> v);

    external Observable<Light> get onNewLightAddedObservable;

    external set onNewLightAddedObservable(Observable<Light> v);

    external Observable<Light> get onLightRemovedObservable;

    external set onLightRemovedObservable(Observable<Light> v);

    external Observable<Geometry> get onNewGeometryAddedObservable;

    external set onNewGeometryAddedObservable(Observable<Geometry> v);

    external Observable<Geometry> get onGeometryRemovedObservable;

    external set onGeometryRemovedObservable(Observable<Geometry> v);

    external Observable<TransformNode> get onNewTransformNodeAddedObservable;

    external set onNewTransformNodeAddedObservable(Observable<TransformNode> v);

    external Observable<TransformNode> get onTransformNodeRemovedObservable;

    external set onTransformNodeRemovedObservable(Observable<TransformNode> v);

    external Observable<AbstractMesh> get onNewMeshAddedObservable;

    external set onNewMeshAddedObservable(Observable<AbstractMesh> v);

    external Observable<AbstractMesh> get onMeshRemovedObservable;

    external set onMeshRemovedObservable(Observable<AbstractMesh> v);

    external Observable<Material> get onNewMaterialAddedObservable;

    external set onNewMaterialAddedObservable(Observable<Material> v);

    external Observable<Material> get onMaterialRemovedObservable;

    external set onMaterialRemovedObservable(Observable<Material> v);

    external Observable<BaseTexture> get onNewTextureAddedObservable;

    external set onNewTextureAddedObservable(Observable<BaseTexture> v);

    external Observable<BaseTexture> get onTextureRemovedObservable;

    external set onTextureRemovedObservable(Observable<BaseTexture> v);

    external Observable<Scene> get onBeforeRenderTargetsRenderObservable;

    external set onBeforeRenderTargetsRenderObservable(Observable<Scene> v);

    external Observable<Scene> get onAfterRenderTargetsRenderObservable;

    external set onAfterRenderTargetsRenderObservable(Observable<Scene> v);

    external Observable<Scene> get onBeforeStepObservable;

    external set onBeforeStepObservable(Observable<Scene> v);

    external Observable<Scene> get onAfterStepObservable;

    external set onAfterStepObservable(Observable<Scene> v);

    external Observable<RenderingGroupInfo> get onBeforeRenderingGroupObservable;

    external set onBeforeRenderingGroupObservable(Observable<RenderingGroupInfo> v);

    external Observable<RenderingGroupInfo> get onAfterRenderingGroupObservable;

    external set onAfterRenderingGroupObservable(Observable<RenderingGroupInfo> v);

    external Observable<AbstractMesh> get onMeshImportedObservable;

    external set onMeshImportedObservable(Observable<AbstractMesh> v);

    external get JS$_registeredForLateAnimationBindings;

    external set JS$_registeredForLateAnimationBindings(v);

    external Func1<AbstractMesh, bool> get pointerDownPredicate;

    external set pointerDownPredicate(Func1<AbstractMesh, bool> v);

    external Func1<AbstractMesh, bool> get pointerUpPredicate;

    external set pointerUpPredicate(Func1<AbstractMesh, bool> v);

    external Func1<AbstractMesh, bool> get pointerMovePredicate;

    external set pointerMovePredicate(Func1<AbstractMesh, bool> v);

    external get JS$_onPointerMove;

    external set JS$_onPointerMove(v);

    external get JS$_onPointerDown;

    external set JS$_onPointerDown(v);

    external get JS$_onPointerUp;

    external set JS$_onPointerUp(v);

    external VoidFunc3<PointerEvent, PickingInfo, PointerEventTypes> get onPointerMove;

    external set onPointerMove(VoidFunc3<PointerEvent, PickingInfo, PointerEventTypes> v);

    external VoidFunc3<PointerEvent, PickingInfo, PointerEventTypes> get onPointerDown;

    external set onPointerDown(VoidFunc3<PointerEvent, PickingInfo, PointerEventTypes> v);

    external VoidFunc3<PointerEvent, PickingInfo/*PickingInfo|Null*/, PointerEventTypes> get onPointerUp;

    external set onPointerUp(VoidFunc3<PointerEvent, PickingInfo/*PickingInfo|Null*/, PointerEventTypes> v);

    external VoidFunc2<PointerEvent, PickingInfo> get onPointerPick;

    external set onPointerPick(VoidFunc2<PointerEvent, PickingInfo> v);

    external Observable<PointerInfoPre> get onPrePointerObservable;

    external set onPrePointerObservable(Observable<PointerInfoPre> v);

    external Observable<PointerInfo> get onPointerObservable;

    external set onPointerObservable(Observable<PointerInfo> v);

    external Vector2 get unTranslatedPointer;

    external set unTranslatedPointer(Vector2 v);

    external static num get DragMovementThreshold;

    external static set DragMovementThreshold(num v);

    external static num get LongPressDelay;

    external static set LongPressDelay(num v);

    external static num get DoubleClickDelay;

    external static set DoubleClickDelay(num v);

    external static bool get ExclusiveDoubleClickMode;

    external static set ExclusiveDoubleClickMode(bool v);

    external get JS$_initClickEvent;

    external set JS$_initClickEvent(v);

    external get JS$_initActionManager;

    external set JS$_initActionManager(v);

    external get JS$_delayedSimpleClick;

    external set JS$_delayedSimpleClick(v);

    external get JS$_delayedSimpleClickTimeout;

    external set JS$_delayedSimpleClickTimeout(v);

    external get JS$_previousDelayedSimpleClickTimeout;

    external set JS$_previousDelayedSimpleClickTimeout(v);

    external get JS$_meshPickProceed;

    external set JS$_meshPickProceed(v);

    external get JS$_previousButtonPressed;

    external set JS$_previousButtonPressed(v);

    external get JS$_currentPickResult;

    external set JS$_currentPickResult(v);

    external get JS$_previousPickResult;

    external set JS$_previousPickResult(v);

    external get JS$_totalPointersPressed;

    external set JS$_totalPointersPressed(v);

    external get JS$_doubleClickOccured;

    external set JS$_doubleClickOccured(v);

    external Camera/*Camera|Null*/ get cameraToUseForPointers;

    external set cameraToUseForPointers(Camera/*Camera|Null*/ v);

    external get JS$_pointerX;

    external set JS$_pointerX(v);

    external get JS$_pointerY;

    external set JS$_pointerY(v);

    external get JS$_unTranslatedPointerX;

    external set JS$_unTranslatedPointerX(v);

    external get JS$_unTranslatedPointerY;

    external set JS$_unTranslatedPointerY(v);

    external get JS$_startingPointerPosition;

    external set JS$_startingPointerPosition(v);

    external get JS$_previousStartingPointerPosition;

    external set JS$_previousStartingPointerPosition(v);

    external get JS$_startingPointerTime;

    external set JS$_startingPointerTime(v);

    external get JS$_previousStartingPointerTime;

    external set JS$_previousStartingPointerTime(v);

    external get JS$_pointerCaptures;

    external set JS$_pointerCaptures(v);

    external get JS$_timeAccumulator;

    external set JS$_timeAccumulator(v);

    external get JS$_currentStepId;

    external set JS$_currentStepId(v);

    external get JS$_currentInternalStep;

    external set JS$_currentInternalStep(v);

    external Vector3/*Vector3|Null*/ get JS$_mirroredCameraPosition;

    external set JS$_mirroredCameraPosition(Vector3/*Vector3|Null*/ v);

    external Observable<KeyboardInfoPre> get onPreKeyboardObservable;

    external set onPreKeyboardObservable(Observable<KeyboardInfoPre> v);

    external Observable<KeyboardInfo> get onKeyboardObservable;

    external set onKeyboardObservable(Observable<KeyboardInfo> v);

    external get JS$_onKeyDown;

    external set JS$_onKeyDown(v);

    external get JS$_onKeyUp;

    external set JS$_onKeyUp(v);

    external get JS$_onCanvasFocusObserver;

    external set JS$_onCanvasFocusObserver(v);

    external get JS$_onCanvasBlurObserver;

    external set JS$_onCanvasBlurObserver(v);

    external get JS$_useRightHandedSystem;

    external set JS$_useRightHandedSystem(v);

    external bool get useRightHandedSystem;

    external set useRightHandedSystem(bool v);

    external void setStepId(num newStepId);

    external num getStepId();

    external num getInternalStep();

    external get JS$_fogEnabled;

    external set JS$_fogEnabled(v);

    external bool get fogEnabled;

    external set fogEnabled(bool v);

    external get JS$_fogMode;

    external set JS$_fogMode(v);

    external num get fogMode;

    external set fogMode(num v);

    external Color3 get fogColor;

    external set fogColor(Color3 v);

    external num get fogDensity;

    external set fogDensity(num v);

    external num get fogStart;

    external set fogStart(num v);

    external num get fogEnd;

    external set fogEnd(num v);

    external get JS$_shadowsEnabled;

    external set JS$_shadowsEnabled(v);

    external bool get shadowsEnabled;

    external set shadowsEnabled(bool v);

    external get JS$_lightsEnabled;

    external set JS$_lightsEnabled(v);

    external bool get lightsEnabled;

    external set lightsEnabled(bool v);

    external List<Camera> get activeCameras;

    external set activeCameras(List<Camera> v);

    external Camera/*Camera|Null*/ get activeCamera;

    external set activeCamera(Camera/*Camera|Null*/ v);

    external get JS$_defaultMaterial;

    external set JS$_defaultMaterial(v);

    external Material get defaultMaterial;

    external set defaultMaterial(Material v);

    external get JS$_texturesEnabled;

    external set JS$_texturesEnabled(v);

    external bool get texturesEnabled;

    external set texturesEnabled(bool v);

    external bool get particlesEnabled;

    external set particlesEnabled(bool v);

    external bool get spritesEnabled;

    external set spritesEnabled(bool v);

    external get JS$_skeletonsEnabled;

    external set JS$_skeletonsEnabled(v);

    external bool get skeletonsEnabled;

    external set skeletonsEnabled(bool v);

    external bool get lensFlaresEnabled;

    external set lensFlaresEnabled(bool v);

    external bool get collisionsEnabled;

    external set collisionsEnabled(bool v);

    external get JS$_workerCollisions;

    external set JS$_workerCollisions(v);

    external ICollisionCoordinator get collisionCoordinator;

    external set collisionCoordinator(ICollisionCoordinator v);

    external Vector3 get gravity;

    external set gravity(Vector3 v);

    external bool get postProcessesEnabled;

    external set postProcessesEnabled(bool v);

    external List<PostProcess> get postProcesses;

    external set postProcesses(List<PostProcess> v);

    external PostProcessManager get postProcessManager;

    external set postProcessManager(PostProcessManager v);

    external bool get renderTargetsEnabled;

    external set renderTargetsEnabled(bool v);

    external bool get dumpNextRenderTargets;

    external set dumpNextRenderTargets(bool v);

    external List<RenderTargetTexture> get customRenderTargets;

    external set customRenderTargets(List<RenderTargetTexture> v);

    external bool get useDelayedTextureLoading;

    external set useDelayedTextureLoading(bool v);

    external List<String> get importedMeshesFiles;

    external set importedMeshesFiles(List<String> v);

    external bool get probesEnabled;

    external set probesEnabled(bool v);

    external Database get database;

    external set database(Database v);

    external ActionManager get actionManager;

    external set actionManager(ActionManager v);

    external get JS$_meshesForIntersections;

    external set JS$_meshesForIntersections(v);

    external bool get proceduralTexturesEnabled;

    external set proceduralTexturesEnabled(bool v);

    external get JS$_engine;

    external set JS$_engine(v);

    external get JS$_totalVertices;

    external set JS$_totalVertices(v);

    external PerfCounter get JS$_activeIndices;

    external set JS$_activeIndices(PerfCounter v);

    external PerfCounter get JS$_activeParticles;

    external set JS$_activeParticles(PerfCounter v);

    external PerfCounter get JS$_activeBones;

    external set JS$_activeBones(PerfCounter v);

    external get JS$_animationRatio;

    external set JS$_animationRatio(v);

    external get JS$_animationTimeLast;

    external set JS$_animationTimeLast(v);

    external get JS$_animationTime;

    external set JS$_animationTime(v);

    external num get animationTimeScale;

    external set animationTimeScale(num v);

    external Material/*Material|Null*/ get JS$_cachedMaterial;

    external set JS$_cachedMaterial(Material/*Material|Null*/ v);

    external Effect/*Effect|Null*/ get JS$_cachedEffect;

    external set JS$_cachedEffect(Effect/*Effect|Null*/ v);

    external num/*num|Null*/ get JS$_cachedVisibility;

    external set JS$_cachedVisibility(num/*num|Null*/ v);

    external get JS$_renderId;

    external set JS$_renderId(v);

    external get JS$_frameId;

    external set JS$_frameId(v);

    external get JS$_executeWhenReadyTimeoutId;

    external set JS$_executeWhenReadyTimeoutId(v);

    external get JS$_intermediateRendering;

    external set JS$_intermediateRendering(v);

    external get JS$_viewUpdateFlag;

    external set JS$_viewUpdateFlag(v);

    external get JS$_projectionUpdateFlag;

    external set JS$_projectionUpdateFlag(v);

    external get JS$_alternateViewUpdateFlag;

    external set JS$_alternateViewUpdateFlag(v);

    external get JS$_alternateProjectionUpdateFlag;

    external set JS$_alternateProjectionUpdateFlag(v);

    external List<IDisposable /*IDisposable|Null*/> get JS$_toBeDisposed;

    external set JS$_toBeDisposed(List<IDisposable /*IDisposable|Null*/> v);

    external get JS$_activeRequests;

    external set JS$_activeRequests(v);

    external get JS$_pendingData;

    external set JS$_pendingData(v);

    external get JS$_isDisposed;

    external set JS$_isDisposed(v);

    external bool get dispatchAllSubMeshesOfActiveMeshes;

    external set dispatchAllSubMeshesOfActiveMeshes(bool v);

    external get JS$_activeMeshes;

    external set JS$_activeMeshes(v);

    external get JS$_processedMaterials;

    external set JS$_processedMaterials(v);

    external get JS$_renderTargets;

    external set JS$_renderTargets(v);

    external SmartArray<IParticleSystem> get JS$_activeParticleSystems;

    external set JS$_activeParticleSystems(SmartArray<IParticleSystem> v);

    external get JS$_activeSkeletons;

    external set JS$_activeSkeletons(v);

    external get JS$_softwareSkinnedMeshes;

    external set JS$_softwareSkinnedMeshes(v);

    external get JS$_renderingManager;

    external set JS$_renderingManager(v);

    external List<Animatable> get JS$_activeAnimatables;

    external set JS$_activeAnimatables(List<Animatable> v);

    external get JS$_transformMatrix;

    external set JS$_transformMatrix(v);

    external get JS$_sceneUbo;

    external set JS$_sceneUbo(v);

    external get JS$_alternateSceneUbo;

    external set JS$_alternateSceneUbo(v);

    external get JS$_pickWithRayInverseMatrix;

    external set JS$_pickWithRayInverseMatrix(v);

    external get JS$_viewMatrix;

    external set JS$_viewMatrix(v);

    external get JS$_projectionMatrix;

    external set JS$_projectionMatrix(v);

    external get JS$_alternateViewMatrix;

    external set JS$_alternateViewMatrix(v);

    external get JS$_alternateProjectionMatrix;

    external set JS$_alternateProjectionMatrix(v);

    external get JS$_alternateTransformMatrix;

    external set JS$_alternateTransformMatrix(v);

    external get JS$_useAlternateCameraConfiguration;

    external set JS$_useAlternateCameraConfiguration(v);

    external get JS$_alternateRendering;

    external set JS$_alternateRendering(v);

    external Vector3/*Vector3|Null*/ get JS$_forcedViewPosition;

    external set JS$_forcedViewPosition(Vector3/*Vector3|Null*/ v);

    external bool get JS$_isAlternateRenderingEnabled;

    external set JS$_isAlternateRenderingEnabled(bool v);

    external get JS$_frustumPlanes;

    external set JS$_frustumPlanes(v);

    external List<Plane> get frustumPlanes;

    external set frustumPlanes(List<Plane> v);

    external bool get requireLightSorting;

    external set requireLightSorting(bool v);

    external get JS$_pointerOverMesh;

    external set JS$_pointerOverMesh(v);

    external get JS$_pickedDownMesh;

    external set JS$_pickedDownMesh(v);

    external get JS$_pickedUpMesh;

    external set JS$_pickedUpMesh(v);

    external get JS$_externalData;

    external set JS$_externalData(v);

    external get JS$_uid;

    external set JS$_uid(v);

    external List<ISceneComponent> get JS$_components;

    external set JS$_components(List<ISceneComponent> v);

    external List<ISceneSerializableComponent> get JS$_serializableComponents;

    external set JS$_serializableComponents(List<ISceneSerializableComponent> v);

    external get JS$_transientComponents;

    external set JS$_transientComponents(v);

    external get JS$_registerTransientComponents;

    external set JS$_registerTransientComponents(v);

    external void JS$_addComponent(ISceneComponent component);

    external ISceneComponent/*ISceneComponent|Null*/ JS$_getComponent(String name);

    external Stage<SimpleStageAction> get JS$_beforeCameraUpdateStage;

    external set JS$_beforeCameraUpdateStage(Stage<SimpleStageAction> v);

    external Stage<SimpleStageAction> get JS$_beforeClearStage;

    external set JS$_beforeClearStage(Stage<SimpleStageAction> v);

    external Stage<RenderTargetsStageAction> get JS$_gatherRenderTargetsStage;

    external set JS$_gatherRenderTargetsStage(Stage<RenderTargetsStageAction> v);

    external Stage<RenderTargetsStageAction> get JS$_gatherActiveCameraRenderTargetsStage;

    external set JS$_gatherActiveCameraRenderTargetsStage(Stage<RenderTargetsStageAction> v);

    external Stage<MeshStageAction> get JS$_isReadyForMeshStage;

    external set JS$_isReadyForMeshStage(Stage<MeshStageAction> v);

    external Stage<SimpleStageAction> get JS$_beforeEvaluateActiveMeshStage;

    external set JS$_beforeEvaluateActiveMeshStage(Stage<SimpleStageAction> v);

    external Stage<EvaluateSubMeshStageAction> get JS$_evaluateSubMeshStage;

    external set JS$_evaluateSubMeshStage(Stage<EvaluateSubMeshStageAction> v);

    external Stage<ActiveMeshStageAction> get JS$_activeMeshStage;

    external set JS$_activeMeshStage(Stage<ActiveMeshStageAction> v);

    external Stage<CameraStageAction> get JS$_cameraDrawRenderTargetStage;

    external set JS$_cameraDrawRenderTargetStage(Stage<CameraStageAction> v);

    external Stage<CameraStageAction> get JS$_beforeCameraDrawStage;

    external set JS$_beforeCameraDrawStage(Stage<CameraStageAction> v);

    external Stage<RenderingGroupStageAction> get JS$_beforeRenderingGroupDrawStage;

    external set JS$_beforeRenderingGroupDrawStage(Stage<RenderingGroupStageAction> v);

    external Stage<RenderingMeshStageAction> get JS$_beforeRenderingMeshStage;

    external set JS$_beforeRenderingMeshStage(Stage<RenderingMeshStageAction> v);

    external Stage<RenderingMeshStageAction> get JS$_afterRenderingMeshStage;

    external set JS$_afterRenderingMeshStage(Stage<RenderingMeshStageAction> v);

    external Stage<RenderingGroupStageAction> get JS$_afterRenderingGroupDrawStage;

    external set JS$_afterRenderingGroupDrawStage(Stage<RenderingGroupStageAction> v);

    external Stage<CameraStageAction> get JS$_afterCameraDrawStage;

    external set JS$_afterCameraDrawStage(Stage<CameraStageAction> v);

    external Stage<SimpleStageAction> get JS$_afterRenderStage;

    external set JS$_afterRenderStage(Stage<SimpleStageAction> v);

    external Stage<PointerMoveStageAction> get JS$_pointerMoveStage;

    external set JS$_pointerMoveStage(Stage<PointerMoveStageAction> v);

    external Stage<PointerUpDownStageAction> get JS$_pointerDownStage;

    external set JS$_pointerDownStage(Stage<PointerUpDownStageAction> v);

    external Stage<PointerUpDownStageAction> get JS$_pointerUpStage;

    external set JS$_pointerUpStage(Stage<PointerUpDownStageAction> v);

    external factory Scene(Engine engine);

    external get JS$_defaultMeshCandidates;

    external set JS$_defaultMeshCandidates(v);

    external ISmartArrayLike<AbstractMesh> JS$_getDefaultMeshCandidates();

    external get JS$_defaultSubMeshCandidates;

    external set JS$_defaultSubMeshCandidates(v);

    external ISmartArrayLike<SubMesh> JS$_getDefaultSubMeshCandidates(AbstractMesh mesh);

    external void setDefaultCandidateProviders();

    external bool get workerCollisions;

    external set workerCollisions(bool v);

    external AbstractMesh/*AbstractMesh|Null*/ get meshUnderPointer;

    external set meshUnderPointer(AbstractMesh/*AbstractMesh|Null*/ v);

    external num get pointerX;

    external set pointerX(num v);

    external num get pointerY;

    external set pointerY(num v);

    external Material/*Material|Null*/ getCachedMaterial();

    external Effect/*Effect|Null*/ getCachedEffect();

    external num/*num|Null*/ getCachedVisibility();

    external bool isCachedMaterialInvalid(Material material, Effect effect, [num visibility]);

    external Engine getEngine();

    external num getTotalVertices();

    external PerfCounter get totalVerticesPerfCounter;

    external set totalVerticesPerfCounter(PerfCounter v);

    external num getActiveIndices();

    external PerfCounter get totalActiveIndicesPerfCounter;

    external set totalActiveIndicesPerfCounter(PerfCounter v);

    external num getActiveParticles();

    external PerfCounter get activeParticlesPerfCounter;

    external set activeParticlesPerfCounter(PerfCounter v);

    external num getActiveBones();

    external PerfCounter get activeBonesPerfCounter;

    external set activeBonesPerfCounter(PerfCounter v);

    external num getInterFramePerfCounter();

    external PerfCounter/*PerfCounter|Null*/ get interFramePerfCounter;

    external set interFramePerfCounter(PerfCounter/*PerfCounter|Null*/ v);

    external num getLastFrameDuration();

    external PerfCounter/*PerfCounter|Null*/ get lastFramePerfCounter;

    external set lastFramePerfCounter(PerfCounter/*PerfCounter|Null*/ v);

    external num getEvaluateActiveMeshesDuration();

    external PerfCounter/*PerfCounter|Null*/ get evaluateActiveMeshesDurationPerfCounter;

    external set evaluateActiveMeshesDurationPerfCounter(PerfCounter/*PerfCounter|Null*/ v);

    external SmartArray<AbstractMesh> getActiveMeshes();

    external num getRenderTargetsDuration();

    external num getRenderDuration();

    external PerfCounter/*PerfCounter|Null*/ get renderDurationPerfCounter;

    external set renderDurationPerfCounter(PerfCounter/*PerfCounter|Null*/ v);

    external num getParticlesDuration();

    external PerfCounter/*PerfCounter|Null*/ get particlesDurationPerfCounter;

    external set particlesDurationPerfCounter(PerfCounter/*PerfCounter|Null*/ v);

    external num getSpritesDuration();

    external PerfCounter/*PerfCounter|Null*/ get spriteDuractionPerfCounter;

    external set spriteDuractionPerfCounter(PerfCounter/*PerfCounter|Null*/ v);

    external num getAnimationRatio();

    external num getRenderId();

    external num getFrameId();

    external void incrementRenderId();

    external get JS$_updatePointerPosition;

    external set JS$_updatePointerPosition(v);

    external get JS$_createUbo;

    external set JS$_createUbo(v);

    external get JS$_createAlternateUbo;

    external set JS$_createAlternateUbo(v);

    external get JS$_setRayOnPointerInfo;

    external set JS$_setRayOnPointerInfo(v);

    external Scene simulatePointerMove(PickingInfo pickResult, [PointerEventInit pointerEventInit]);

    external get JS$_processPointerMove;

    external set JS$_processPointerMove(v);

    external get JS$_checkPrePointerObservable;

    external set JS$_checkPrePointerObservable(v);

    external Scene simulatePointerDown(PickingInfo pickResult, [PointerEventInit pointerEventInit]);

    external get JS$_processPointerDown;

    external set JS$_processPointerDown(v);

    external Scene simulatePointerUp(PickingInfo pickResult, [PointerEventInit pointerEventInit]);

    external get JS$_processPointerUp;

    external set JS$_processPointerUp(v);

    external bool isPointerCaptured([num pointerId]);

    external bool JS$_isPointerSwiping();

    external void attachControl([bool attachUp, bool attachDown, bool attachMove]);

    external void detachControl();

    external bool isReady();

    external void resetCachedMaterial();

    external void registerBeforeRender(void func());

    external void unregisterBeforeRender(void func());

    external void registerAfterRender(void func());

    external void unregisterAfterRender(void func());

    external get JS$_executeOnceBeforeRender;

    external set JS$_executeOnceBeforeRender(v);

    external void executeOnceBeforeRender(void func(), [num timeout]);

    external void JS$_addPendingData(dynamic data);

    external void JS$_removePendingData(dynamic data);

    external num getWaitingItemsCount();

    external bool get isLoading;

    external set isLoading(bool v);

    external void executeWhenReady(void func());

    external Promise<Null> whenReadyAsync();

    external void JS$_checkIsReady();

    external Animatable beginWeightedAnimation(dynamic target, num from, num to, [num weight, bool loop, num speedRatio, void onAnimationEnd(), Animatable animatable, bool targetMask(dynamic target)]);

    external Animatable beginAnimation(dynamic target, num from, num to, [bool loop, num speedRatio, void onAnimationEnd(), Animatable animatable, bool stopCurrent, bool targetMask(dynamic target)]);

    external Animatable beginDirectAnimation(dynamic target, List<Animation> animations, num from, num to, [bool loop, num speedRatio, void onAnimationEnd()]);

    external List<Animatable> beginDirectHierarchyAnimation(Node target, bool directDescendantsOnly, List<Animation> animations, num from, num to, [bool loop, num speedRatio, void onAnimationEnd()]);

    external Animatable/*Animatable|Null*/ getAnimatableByTarget(dynamic target);

    external List<Animatable> getAllAnimatablesByTarget(dynamic target);

    external List<Animatable> get animatables;

    external set animatables(List<Animatable> v);

    external void stopAnimation(dynamic target, [String animationName, bool targetMask(dynamic target)]);

    external void stopAllAnimations();

    external get JS$_animate;

    external set JS$_animate(v);

    external void JS$_registerTargetForLateAnimationBinding(RuntimeAnimation runtimeAnimation, dynamic originalValue);

    external get JS$_processLateAnimationBindingsForMatrices;

    external set JS$_processLateAnimationBindingsForMatrices(v);

    external get JS$_processLateAnimationBindingsForQuaternions;

    external set JS$_processLateAnimationBindingsForQuaternions(v);

    external get JS$_processLateAnimationBindings;

    external set JS$_processLateAnimationBindings(v);

    external void JS$_switchToAlternateCameraConfiguration(bool active);

    external Matrix getViewMatrix();

    external Matrix getProjectionMatrix();

    external Matrix getTransformMatrix();

    external void setTransformMatrix(Matrix view, Matrix projection);

    external void JS$_setAlternateTransformMatrix(Matrix view, Matrix projection);

    external UniformBuffer getSceneUniformBuffer();

    external num getUniqueId();

    external void addMesh(AbstractMesh newMesh, [bool recursive]);

    external num removeMesh(AbstractMesh toRemove, [bool recursive]);

    external void addTransformNode(TransformNode newTransformNode);

    external num removeTransformNode(TransformNode toRemove);

    external num removeSkeleton(Skeleton toRemove);

    external num removeMorphTargetManager(MorphTargetManager toRemove);

    external num removeLight(Light toRemove);

    external num removeCamera(Camera toRemove);

    external num removeParticleSystem(IParticleSystem toRemove);

    external num removeAnimation(Animation toRemove);

    external num removeAnimationGroup(AnimationGroup toRemove);

    external num removeMultiMaterial(MultiMaterial toRemove);

    external num removeMaterial(Material toRemove);

    external num removeActionManager(ActionManager toRemove);

    external num removeTexture(BaseTexture toRemove);

    external void addLight(Light newLight);

    external void sortLightsByPriority();

    external void addCamera(Camera newCamera);

    external void addSkeleton(Skeleton newSkeleton);

    external void addParticleSystem(IParticleSystem newParticleSystem);

    external void addAnimation(Animation newAnimation);

    external void addAnimationGroup(AnimationGroup newAnimationGroup);

    external void addMultiMaterial(MultiMaterial newMultiMaterial);

    external void addMaterial(Material newMaterial);

    external void addMorphTargetManager(MorphTargetManager newMorphTargetManager);

    external void addGeometry(Geometry newGeometry);

    external void addActionManager(ActionManager newActionManager);

    external void addTexture(BaseTexture newTexture);

    external void switchActiveCamera(Camera newCamera, [bool attachControl]);

    external Camera/*Camera|Null*/ setActiveCameraByID(String id);

    external Camera/*Camera|Null*/ setActiveCameraByName(String name);

    external AnimationGroup/*AnimationGroup|Null*/ getAnimationGroupByName(String name);

    external Material/*Material|Null*/ getMaterialByID(String id);

    external Material/*Material|Null*/ getMaterialByName(String name);

    external Camera/*Camera|Null*/ getCameraByID(String id);

    external Camera/*Camera|Null*/ getCameraByUniqueID(num uniqueId);

    external Camera/*Camera|Null*/ getCameraByName(String name);

    external Bone/*Bone|Null*/ getBoneByID(String id);

    external Bone/*Bone|Null*/ getBoneByName(String name);

    external Light/*Light|Null*/ getLightByName(String name);

    external Light/*Light|Null*/ getLightByID(String id);

    external Light/*Light|Null*/ getLightByUniqueID(num uniqueId);

    external IParticleSystem/*IParticleSystem|Null*/ getParticleSystemByID(String id);

    external Geometry/*Geometry|Null*/ getGeometryByID(String id);

    external bool pushGeometry(Geometry geometry, [bool force]);

    external bool removeGeometry(Geometry geometry);

    external List<Geometry> getGeometries();

    external AbstractMesh/*AbstractMesh|Null*/ getMeshByID(String id);

    external List<AbstractMesh> getMeshesByID(String id);

    external TransformNode/*TransformNode|Null*/ getTransformNodeByID(String id);

    external List<TransformNode> getTransformNodesByID(String id);

    external AbstractMesh/*AbstractMesh|Null*/ getMeshByUniqueID(num uniqueId);

    external AbstractMesh/*AbstractMesh|Null*/ getLastMeshByID(String id);

    external Node/*Node|Null*/ getLastEntryByID(String id);

    external Node/*Node|Null*/ getNodeByID(String id);

    external Node/*Node|Null*/ getNodeByName(String name);

    external AbstractMesh/*AbstractMesh|Null*/ getMeshByName(String name);

    external TransformNode/*TransformNode|Null*/ getTransformNodeByName(String name);

    external Skeleton/*Skeleton|Null*/ getLastSkeletonByID(String id);

    external Skeleton/*Skeleton|Null*/ getSkeletonById(String id);

    external Skeleton/*Skeleton|Null*/ getSkeletonByName(String name);

    external MorphTargetManager/*MorphTargetManager|Null*/ getMorphTargetManagerById(num id);

    external bool isActiveMesh(AbstractMesh mesh);

    external String get uid;

    external set uid(String v);

    external bool addExternalData /*<T>*/(String key, dynamic/*=T*/ data);

    external dynamic/*T|Null*/ getExternalData /*<T>*/(String key);

    external dynamic/*=T*/ getOrAddExternalDataWithFactory /*<T>*/(String key, dynamic/*=T*/ JS$factory(String k));

    external bool removeExternalData(String key);

    external get JS$_evaluateSubMesh;

    external set JS$_evaluateSubMesh(v);

    external void freeProcessedMaterials();

    external void freeActiveMeshes();

    external void freeRenderingGroups();

    external bool JS$_isInIntermediateRendering();

    external Func0<ISmartArrayLike<AbstractMesh>> get getActiveMeshCandidates;

    external set getActiveMeshCandidates(Func0<ISmartArrayLike<AbstractMesh>> v);

    external Func1<AbstractMesh, ISmartArrayLike<SubMesh>> get getActiveSubMeshCandidates;

    external set getActiveSubMeshCandidates(Func1<AbstractMesh, ISmartArrayLike<SubMesh>> v);

    external Func2<AbstractMesh, Ray, ISmartArrayLike<SubMesh>> get getIntersectingSubMeshCandidates;

    external set getIntersectingSubMeshCandidates(Func2<AbstractMesh, Ray, ISmartArrayLike<SubMesh>> v);

    external Func2<AbstractMesh, Collider, ISmartArrayLike<SubMesh>> get getCollidingSubMeshCandidates;

    external set getCollidingSubMeshCandidates(Func2<AbstractMesh, Collider, ISmartArrayLike<SubMesh>> v);

    external get JS$_activeMeshesFrozen;

    external set JS$_activeMeshesFrozen(v);

    external Scene freezeActiveMeshes();

    external Scene unfreezeActiveMeshes();

    external get JS$_evaluateActiveMeshes;

    external set JS$_evaluateActiveMeshes(v);

    external get JS$_activeMesh;

    external set JS$_activeMesh(v);

    external void updateTransformMatrix([bool force]);

    external void updateAlternateTransformMatrix(Camera alternateCamera);

    external bool get JS$_allowPostProcessClearColor;

    external set JS$_allowPostProcessClearColor(bool v);

    external get JS$_renderForCamera;

    external set JS$_renderForCamera(v);

    external get JS$_processSubCameras;

    external set JS$_processSubCameras(v);

    external get JS$_checkIntersections;

    external set JS$_checkIntersections(v);

    external void JS$_advancePhysicsEngineStep(num step);

    external Func0<num> get getDeterministicFrameTime;

    external set getDeterministicFrameTime(Func0<num> v);

    external void render([bool updateCameras]);

    external void freezeMaterials();

    external void unfreezeMaterials();

    external void dispose();

    external bool get isDisposed;

    external set isDisposed(bool v);

    external void clearCachedVertexData();

    external void cleanCachedTextureBuffer();

    external dynamic/*{
            min: Vector3;
            max: Vector3;
        }*/
    getWorldExtends([bool filterPredicate(AbstractMesh mesh)]);

    external Ray createPickingRay(num x, num y, Matrix world, Camera/*Camera|Null*/ camera, [bool cameraViewSpace]);

    external Scene createPickingRayToRef(num x, num y, Matrix world, Ray result, Camera/*Camera|Null*/ camera, [bool cameraViewSpace]);

    external Ray createPickingRayInCameraSpace(num x, num y, [Camera camera]);

    external Scene createPickingRayInCameraSpaceToRef(num x, num y, Ray result, [Camera camera]);

    external get JS$_internalPick;

    external set JS$_internalPick(v);

    external get JS$_internalMultiPick;

    external set JS$_internalMultiPick(v);

    external get JS$_tempPickingRay;

    external set JS$_tempPickingRay(v);

    external PickingInfo/*PickingInfo|Null*/ pick(num x, num y, [bool predicate(AbstractMesh mesh), bool fastCheck, Camera/*Camera|Null*/ camera]);

    external get JS$_cachedRayForTransform;

    external set JS$_cachedRayForTransform(v);

    external PickingInfo/*PickingInfo|Null*/ pickWithRay(Ray ray, [bool predicate(AbstractMesh mesh), bool fastCheck]);

    external List<PickingInfo>/*List<PickingInfo>|Null*/ multiPick(num x, num y, [bool predicate(AbstractMesh mesh), Camera camera]);

    external List<PickingInfo>/*List<PickingInfo>|Null*/ multiPickWithRay(Ray ray, bool predicate(AbstractMesh mesh));

    external void setPointerOverMesh(AbstractMesh/*AbstractMesh|Null*/ mesh);

    external AbstractMesh/*AbstractMesh|Null*/ getPointerOverMesh();

    external void JS$_rebuildGeometries();

    external void JS$_rebuildTextures();

    external get JS$_getByTags;

    external set JS$_getByTags(v);

    external List<Mesh> getMeshesByTags(String tagsQuery, [void forEach(AbstractMesh mesh)]);

    external List<Camera> getCamerasByTags(String tagsQuery, [void forEach(Camera camera)]);

    external List<Light> getLightsByTags(String tagsQuery, [void forEach(Light light)]);

    external List<Material> getMaterialByTags(String tagsQuery, [void forEach(Material material)]);

    external void setRenderingOrder(num renderingGroupId, [Func2<SubMesh, SubMesh, num>/*Func2<SubMesh, SubMesh, num>|Null*/ opaqueSortCompareFn, Func2<SubMesh, SubMesh, num>/*Func2<SubMesh, SubMesh, num>|Null*/ alphaTestSortCompareFn, Func2<SubMesh, SubMesh, num>/*Func2<SubMesh, SubMesh, num>|Null*/ transparentSortCompareFn]);

    external void setRenderingAutoClearDepthStencil(num renderingGroupId, bool autoClearDepthStencil, [bool depth, bool stencil]);

    external IRenderingManagerAutoClearSetup getAutoClearDepthStencilSetup(num index);

    external get JS$_blockMaterialDirtyMechanism;

    external set JS$_blockMaterialDirtyMechanism(v);

    external bool get blockMaterialDirtyMechanism;

    external set blockMaterialDirtyMechanism(bool v);

    external void markAllMaterialsAsDirty(num flag, [bool predicate(Material mat)]);

    external IFileRequest JS$_loadFile(String url, void onSuccess(dynamic/*String|ByteBuffer*/ data, [String responseURL]), [void onProgress(dynamic data), bool useDatabase, bool useArrayBuffer, void onError([HttpRequest request, dynamic exception])]);

    external Promise<dynamic /*String|ByteBuffer*/> JS$_loadFileAsync(String url, [bool useDatabase, bool useArrayBuffer]);

    external SoundTrack get JS$_mainSoundTrack;

    external set JS$_mainSoundTrack(SoundTrack v);

    external SoundTrack get mainSoundTrack;

    external set mainSoundTrack(SoundTrack v);

    external List<SoundTrack>/*List<SoundTrack>|Null*/ get soundTracks;

    external set soundTracks(List<SoundTrack>/*List<SoundTrack>|Null*/ v);

    external Sound/*Sound|Null*/ getSoundByName(String name);

    external bool get audioEnabled;

    external set audioEnabled(bool v);

    external bool get headphone;

    external set headphone(bool v);

    external DebugLayer get JS$_debugLayer;

    external set JS$_debugLayer(DebugLayer v);

    external DebugLayer get debugLayer;

    external set debugLayer(DebugLayer v);

    external GamepadManager/*GamepadManager|Null*/ get JS$_gamepadManager;

    external set JS$_gamepadManager(GamepadManager/*GamepadManager|Null*/ v);

    external GamepadManager get gamepadManager;

    external set gamepadManager(GamepadManager v);

    external void createDefaultLight([bool replace]);

    external void createDefaultCamera([bool createArcRotateCamera, bool replace, bool attachCameraControls]);

    external void createDefaultCameraOrLight([bool createArcRotateCamera, bool replace, bool attachCameraControls]);

    external Mesh/*Mesh|Null*/ createDefaultSkybox([BaseTexture environmentTexture, bool pbr, num scale, num blur, bool setGlobalEnvTexture]);

    external EnvironmentHelper/*EnvironmentHelper|Null*/ createDefaultEnvironment([Partial<IEnvironmentHelperOptions> options]);

    external VRExperienceHelper createDefaultVRExperience([VRExperienceHelperOptions webVROptions]);

    external SimplificationQueue get JS$_simplificationQueue;

    external set JS$_simplificationQueue(SimplificationQueue v);

    external SimplificationQueue get simplificationQueue;

    external set simplificationQueue(SimplificationQueue v);

    external IPhysicsEngine/*IPhysicsEngine|Null*/ get JS$_physicsEngine;

    external set JS$_physicsEngine(IPhysicsEngine/*IPhysicsEngine|Null*/ v);

    external IPhysicsEngine/*IPhysicsEngine|Null*/ getPhysicsEngine();

    external bool enablePhysics(Vector3/*Vector3|Null*/ gravity, [IPhysicsEnginePlugin plugin]);

    external void disablePhysicsEngine();

    external bool isPhysicsEnabled();

    external void deleteCompoundImpostor(dynamic compound);

    external Observable<Scene> get onBeforePhysicsObservable;

    external set onBeforePhysicsObservable(Observable<Scene> v);

    external Observable<Scene> get onAfterPhysicsObservable;

    external set onAfterPhysicsObservable(Observable<Scene> v);

    external List<ReflectionProbe> get reflectionProbes;

    external set reflectionProbes(List<ReflectionProbe> v);

    external BoundingBoxRenderer get JS$_boundingBoxRenderer;

    external set JS$_boundingBoxRenderer(BoundingBoxRenderer v);

    external bool get JS$_forceShowBoundingBoxes;

    external set JS$_forceShowBoundingBoxes(bool v);

    external bool get forceShowBoundingBoxes;

    external set forceShowBoundingBoxes(bool v);

    external BoundingBoxRenderer getBoundingBoxRenderer();

    external dynamic/*JSMap of <String,DepthRenderer>*/ get JS$_depthRenderer;

    external set JS$_depthRenderer(dynamic/*JSMap of <String,DepthRenderer>*/ v);

    external DepthRenderer enableDepthRenderer([Camera/*Camera|Null*/ camera]);

    external void disableDepthRenderer([Camera/*Camera|Null*/ camera]);

    external GeometryBufferRenderer/*GeometryBufferRenderer|Null*/ get JS$_geometryBufferRenderer;

    external set JS$_geometryBufferRenderer(GeometryBufferRenderer/*GeometryBufferRenderer|Null*/ v);

    external GeometryBufferRenderer/*GeometryBufferRenderer|Null*/ get geometryBufferRenderer;

    external set geometryBufferRenderer(GeometryBufferRenderer/*GeometryBufferRenderer|Null*/ v);

    external GeometryBufferRenderer/*GeometryBufferRenderer|Null*/ enableGeometryBufferRenderer([num ratio]);

    external void disableGeometryBufferRenderer();

    external OutlineRenderer get JS$_outlineRenderer;

    external set JS$_outlineRenderer(OutlineRenderer v);

    external OutlineRenderer getOutlineRenderer();

    external Sprite/*Sprite|Null*/ get JS$_pointerOverSprite;

    external set JS$_pointerOverSprite(Sprite/*Sprite|Null*/ v);

    external Sprite/*Sprite|Null*/ get JS$_pickedDownSprite;

    external set JS$_pickedDownSprite(Sprite/*Sprite|Null*/ v);

    external Ray/*Ray|Null*/ get JS$_tempSpritePickingRay;

    external set JS$_tempSpritePickingRay(Ray/*Ray|Null*/ v);

    external List<ISpriteManager> get spriteManagers;

    external set spriteManagers(List<ISpriteManager> v);

    external Observable<Scene> get onBeforeSpritesRenderingObservable;

    external set onBeforeSpritesRenderingObservable(Observable<Scene> v);

    external Observable<Scene> get onAfterSpritesRenderingObservable;

    external set onAfterSpritesRenderingObservable(Observable<Scene> v);

    external PickingInfo/*PickingInfo|Null*/ JS$_internalPickSprites(Ray ray, [bool predicate(Sprite sprite), bool fastCheck, Camera camera]);

    external PickingInfo/*PickingInfo|Null*/ pickSprite(num x, num y, [bool predicate(Sprite sprite), bool fastCheck, Camera camera]);

    external PickingInfo/*PickingInfo|Null*/ pickSpriteWithRay(Ray ray, [bool predicate(Sprite sprite), bool fastCheck, Camera camera]);

    external void setPointerOverSprite(Sprite/*Sprite|Null*/ sprite);

    external Sprite/*Sprite|Null*/ getPointerOverSprite();

    external Octree<AbstractMesh> get JS$_selectionOctree;

    external set JS$_selectionOctree(Octree<AbstractMesh> v);

    external Octree<AbstractMesh> get selectionOctree;

    external set selectionOctree(Octree<AbstractMesh> v);

    external Octree<AbstractMesh> createOrUpdateSelectionOctree([num maxCapacity, num maxDepth]);

    external PostProcessRenderPipelineManager get JS$_postProcessRenderPipelineManager;

    external set JS$_postProcessRenderPipelineManager(PostProcessRenderPipelineManager v);

    external PostProcessRenderPipelineManager get postProcessRenderPipelineManager;

    external set postProcessRenderPipelineManager(PostProcessRenderPipelineManager v);
}

@JS("BABYLON.SceneComponentConstants")
class SceneComponentConstants {
    // @Ignore
    SceneComponentConstants .fakeConstructor$();

    external static String get NAME_EFFECTLAYER;

    external static set NAME_EFFECTLAYER(String v);

    external static String get NAME_LAYER;

    external static set NAME_LAYER(String v);

    external static String get NAME_LENSFLARESYSTEM;

    external static set NAME_LENSFLARESYSTEM(String v);

    external static String get NAME_BOUNDINGBOXRENDERER;

    external static set NAME_BOUNDINGBOXRENDERER(String v);

    external static String get NAME_PARTICLESYSTEM;

    external static set NAME_PARTICLESYSTEM(String v);

    external static String get NAME_GAMEPAD;

    external static set NAME_GAMEPAD(String v);

    external static String get NAME_SIMPLIFICATIONQUEUE;

    external static set NAME_SIMPLIFICATIONQUEUE(String v);

    external static String get NAME_GEOMETRYBUFFERRENDERER;

    external static set NAME_GEOMETRYBUFFERRENDERER(String v);

    external static String get NAME_DEPTHRENDERER;

    external static set NAME_DEPTHRENDERER(String v);

    external static String get NAME_POSTPROCESSRENDERPIPELINEMANAGER;

    external static set NAME_POSTPROCESSRENDERPIPELINEMANAGER(String v);

    external static String get NAME_SPRITE;

    external static set NAME_SPRITE(String v);

    external static String get NAME_OUTLINERENDERER;

    external static set NAME_OUTLINERENDERER(String v);

    external static String get NAME_PROCEDURALTEXTURE;

    external static set NAME_PROCEDURALTEXTURE(String v);

    external static String get NAME_SHADOWGENERATOR;

    external static set NAME_SHADOWGENERATOR(String v);

    external static String get NAME_OCTREE;

    external static set NAME_OCTREE(String v);

    external static String get NAME_PHYSICSENGINE;

    external static set NAME_PHYSICSENGINE(String v);

    external static String get NAME_AUDIO;

    external static set NAME_AUDIO(String v);

    external static num get STEP_ISREADYFORMESH_EFFECTLAYER;

    external static set STEP_ISREADYFORMESH_EFFECTLAYER(num v);

    external static num get STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER;

    external static set STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER(num v);

    external static num get STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER;

    external static set STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER(num v);

    external static num get STEP_ACTIVEMESH_BOUNDINGBOXRENDERER;

    external static set STEP_ACTIVEMESH_BOUNDINGBOXRENDERER(num v);

    external static num get STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER;

    external static set STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER(num v);

    external static num get STEP_BEFORECAMERADRAW_EFFECTLAYER;

    external static set STEP_BEFORECAMERADRAW_EFFECTLAYER(num v);

    external static num get STEP_BEFORECAMERADRAW_LAYER;

    external static set STEP_BEFORECAMERADRAW_LAYER(num v);

    external static num get STEP_BEFORERENDERINGMESH_OUTLINE;

    external static set STEP_BEFORERENDERINGMESH_OUTLINE(num v);

    external static num get STEP_AFTERRENDERINGMESH_OUTLINE;

    external static set STEP_AFTERRENDERINGMESH_OUTLINE(num v);

    external static num get STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW;

    external static set STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW(num v);

    external static num get STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER;

    external static set STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER(num v);

    external static num get STEP_BEFORECAMERAUPDATE_SIMPLIFICATIONQUEUE;

    external static set STEP_BEFORECAMERAUPDATE_SIMPLIFICATIONQUEUE(num v);

    external static num get STEP_BEFORECAMERAUPDATE_GAMEPAD;

    external static set STEP_BEFORECAMERAUPDATE_GAMEPAD(num v);

    external static num get STEP_BEFORECLEAR_PROCEDURALTEXTURE;

    external static set STEP_BEFORECLEAR_PROCEDURALTEXTURE(num v);

    external static num get STEP_AFTERCAMERADRAW_EFFECTLAYER;

    external static set STEP_AFTERCAMERADRAW_EFFECTLAYER(num v);

    external static num get STEP_AFTERCAMERADRAW_LENSFLARESYSTEM;

    external static set STEP_AFTERCAMERADRAW_LENSFLARESYSTEM(num v);

    external static num get STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW;

    external static set STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW(num v);

    external static num get STEP_AFTERCAMERADRAW_LAYER;

    external static set STEP_AFTERCAMERADRAW_LAYER(num v);

    external static num get STEP_AFTERRENDER_AUDIO;

    external static set STEP_AFTERRENDER_AUDIO(num v);

    external static num get STEP_GATHERRENDERTARGETS_SHADOWGENERATOR;

    external static set STEP_GATHERRENDERTARGETS_SHADOWGENERATOR(num v);

    external static num get STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER;

    external static set STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER(num v);

    external static num get STEP_GATHERRENDERTARGETS_DEPTHRENDERER;

    external static set STEP_GATHERRENDERTARGETS_DEPTHRENDERER(num v);

    external static num get STEP_GATHERRENDERTARGETS_POSTPROCESSRENDERPIPELINEMANAGER;

    external static set STEP_GATHERRENDERTARGETS_POSTPROCESSRENDERPIPELINEMANAGER(num v);

    external static num get STEP_GATHERACTIVECAMERARENDERTARGETS_DEPTHRENDERER;

    external static set STEP_GATHERACTIVECAMERARENDERTARGETS_DEPTHRENDERER(num v);

    external static num get STEP_POINTERMOVE_SPRITE;

    external static set STEP_POINTERMOVE_SPRITE(num v);

    external static num get STEP_POINTERDOWN_SPRITE;

    external static set STEP_POINTERDOWN_SPRITE(num v);

    external static num get STEP_POINTERUP_SPRITE;

    external static set STEP_POINTERUP_SPRITE(num v);
}

@anonymous
@JS()
abstract class ISceneComponent {
    external String get name;

    external set name(String v);

    external Scene get scene;

    external set scene(Scene v);

    external void register();

    external void rebuild();

    external void dispose();
}

@anonymous
@JS()
abstract class ISceneSerializableComponent
    implements ISceneComponent {
    external void addFromContainer(AbstractScene container);

    external void removeFromContainer(AbstractScene container);

    external void serialize(dynamic serializationObject);
}

typedef bool MeshStageAction(AbstractMesh mesh, bool hardwareInstancedRendering);
typedef void EvaluateSubMeshStageAction(AbstractMesh mesh, SubMesh subMesh);
typedef void ActiveMeshStageAction(AbstractMesh sourceMesh, AbstractMesh mesh);
typedef void CameraStageAction(Camera camera);
typedef void RenderingGroupStageAction(num renderingGroupId);
typedef void RenderingMeshStageAction(AbstractMesh mesh, SubMesh subMesh, JS$_InstancesBatch batch);
typedef void SimpleStageAction();
typedef void RenderTargetsStageAction(SmartArrayNoDuplicate<RenderTargetTexture> renderTargets);
typedef PickingInfo/*PickingInfo|Null*/ PointerMoveStageAction(num unTranslatedPointerX, num unTranslatedPointerY, PickingInfo/*PickingInfo|Null*/ pickResult, bool isMeshPicked, CanvasElement canvas);
typedef PickingInfo/*PickingInfo|Null*/ PointerUpDownStageAction(num unTranslatedPointerX, num unTranslatedPointerY, PickingInfo/*PickingInfo|Null*/ pickResult, PointerEvent evt);

@JS("BABYLON.Stage")
class Stage<T extends Function> extends List<dynamic /*{
        index: number;
        component: ISceneComponent;
        action: T;
    }*/> {
    // @Ignore
    Stage .fakeConstructor$() : super.fakeConstructor$();

    external factory Stage();

    external static Stage<dynamic /*=T*/> Create /*<T extends Function>*/();

    external void registerStep(num index, ISceneComponent component, T action);

    external void clear();
}

/*type Nullable<T> = T | null;*/
/*type float = number;*/
/*type double = number;*/
/*type int = number;*/
/*type FloatArray = number[] | Float32Array;*/
/*type IndicesArray = number[] | Int32Array | Uint32Array | Uint16Array;*/
/*type DataArray = number[] | ArrayBuffer | ArrayBufferView;*/
@JS("BABYLON.Action")
class Action {
    // @Ignore
    Action .fakeConstructor$();

    external dynamic get triggerOptions;

    external set triggerOptions(dynamic v);

    external num get trigger;

    external set trigger(num v);

    external ActionManager get JS$_actionManager;

    external set JS$_actionManager(ActionManager v);

    external get JS$_nextActiveAction;

    external set JS$_nextActiveAction(v);

    external get JS$_child;

    external set JS$_child(v);

    external get JS$_condition;

    external set JS$_condition(v);

    external get JS$_triggerParameter;

    external set JS$_triggerParameter(v);

    external Observable<Action> get onBeforeExecuteObservable;

    external set onBeforeExecuteObservable(Observable<Action> v);

    external factory Action(dynamic triggerOptions, [Condition condition]);

    external void JS$_prepare();

    external dynamic getTriggerParameter();

    external void JS$_executeCurrent([ActionEvent evt]);

    external void execute([ActionEvent evt]);

    external void skipToNextActiveAction();

    external Action then(Action action);

    external String JS$_getProperty(String propertyPath);

    external dynamic JS$_getEffectiveTarget(dynamic target, String propertyPath);

    external dynamic serialize(dynamic parent);

    external dynamic JS$_serialize(dynamic serializedAction, [dynamic parent]);

    external static Func1<dynamic, String> get JS$_SerializeValueAsString;

    external static set JS$_SerializeValueAsString(Func1<dynamic, String> v);

    external static Func1<dynamic/*Scene|Node*/,
        dynamic /*{
            name: string;
            targetType: string;
            value: string;
        }*/> get JS$_GetTargetProperty;

    external static set JS$_GetTargetProperty(Func1<dynamic/*Scene|Node*/,
        dynamic /*{
            name: string;
            targetType: string;
            value: string;
        }*/> v);
}

@JS("BABYLON.ActionEvent")
class ActionEvent {
    // @Ignore
    ActionEvent .fakeConstructor$();

    external dynamic get source;

    external set source(dynamic v);

    external num get pointerX;

    external set pointerX(num v);

    external num get pointerY;

    external set pointerY(num v);

    external AbstractMesh/*AbstractMesh|Null*/ get meshUnderPointer;

    external set meshUnderPointer(AbstractMesh/*AbstractMesh|Null*/ v);

    external dynamic get sourceEvent;

    external set sourceEvent(dynamic v);

    external dynamic get additionalData;

    external set additionalData(dynamic v);

    external factory ActionEvent(dynamic source, num pointerX, num pointerY, AbstractMesh/*AbstractMesh|Null*/ meshUnderPointer, [dynamic sourceEvent, dynamic additionalData]);

    external static ActionEvent CreateNew(AbstractMesh source, [Event evt, dynamic additionalData]);

    external static ActionEvent CreateNewFromSprite(Sprite source, Scene scene, [Event evt, dynamic additionalData]);

    external static ActionEvent CreateNewFromScene(Scene scene, Event evt);

    external static ActionEvent CreateNewFromPrimitive(dynamic prim, Vector2 pointerPos, [Event evt, dynamic additionalData]);
}

@JS("BABYLON.ActionManager")
class ActionManager {
    // @Ignore
    ActionManager .fakeConstructor$();

    external static num get NothingTrigger;

    external static set NothingTrigger(num v);

    external static num get OnPickTrigger;

    external static set OnPickTrigger(num v);

    external static num get OnLeftPickTrigger;

    external static set OnLeftPickTrigger(num v);

    external static num get OnRightPickTrigger;

    external static set OnRightPickTrigger(num v);

    external static num get OnCenterPickTrigger;

    external static set OnCenterPickTrigger(num v);

    external static num get OnPickDownTrigger;

    external static set OnPickDownTrigger(num v);

    external static num get OnDoublePickTrigger;

    external static set OnDoublePickTrigger(num v);

    external static num get OnPickUpTrigger;

    external static set OnPickUpTrigger(num v);

    external static num get OnPickOutTrigger;

    external static set OnPickOutTrigger(num v);

    external static num get OnLongPressTrigger;

    external static set OnLongPressTrigger(num v);

    external static num get OnPointerOverTrigger;

    external static set OnPointerOverTrigger(num v);

    external static num get OnPointerOutTrigger;

    external static set OnPointerOutTrigger(num v);

    external static num get OnEveryFrameTrigger;

    external static set OnEveryFrameTrigger(num v);

    external static num get OnIntersectionEnterTrigger;

    external static set OnIntersectionEnterTrigger(num v);

    external static num get OnIntersectionExitTrigger;

    external static set OnIntersectionExitTrigger(num v);

    external static num get OnKeyDownTrigger;

    external static set OnKeyDownTrigger(num v);

    external static num get OnKeyUpTrigger;

    external static set OnKeyUpTrigger(num v);

    external static dynamic/*JSMap of <String,num>*/ get Triggers;

    external static set Triggers(dynamic/*JSMap of <String,num>*/ v);

    external List<Action> get actions;

    external set actions(List<Action> v);

    external String get hoverCursor;

    external set hoverCursor(String v);

    external get JS$_scene;

    external set JS$_scene(v);

    external factory ActionManager(Scene scene);

    external void dispose();

    external Scene getScene();

    external bool hasSpecificTriggers(List<num> triggers);

    external bool hasSpecificTriggers2(num triggerA, num triggerB);

    external bool hasSpecificTrigger(num trigger, [bool parameterPredicate(dynamic parameter)]);

    external bool get hasPointerTriggers;

    external set hasPointerTriggers(bool v);

    external bool get hasPickTriggers;

    external set hasPickTriggers(bool v);

    external static bool get HasTriggers;

    external static set HasTriggers(bool v);

    external static bool get HasPickTriggers;

    external static set HasPickTriggers(bool v);

    external static bool HasSpecificTrigger(num trigger);

    external Action/*Action|Null*/ registerAction(Action action);

    external bool unregisterAction(Action action);

    external void processTrigger(num trigger, [ActionEvent evt]);

    external dynamic JS$_getEffectiveTarget(dynamic target, String propertyPath);

    external String JS$_getProperty(String propertyPath);

    external dynamic serialize(String name);

    external static void Parse(dynamic parsedActions, AbstractMesh/*AbstractMesh|Null*/ object, Scene scene);

    external static String GetTriggerName(num trigger);
}

@JS("BABYLON.Condition")
class Condition {
    // @Ignore
    Condition .fakeConstructor$();

    external ActionManager get JS$_actionManager;

    external set JS$_actionManager(ActionManager v);

    external num get JS$_evaluationId;

    external set JS$_evaluationId(num v);

    external bool get JS$_currentResult;

    external set JS$_currentResult(bool v);

    external factory Condition(ActionManager actionManager);

    external bool isValid();

    external String JS$_getProperty(String propertyPath);

    external dynamic JS$_getEffectiveTarget(dynamic target, String propertyPath);

    external dynamic serialize();

    external dynamic JS$_serialize(dynamic serializedCondition);
}

@JS("BABYLON.ValueCondition")
class ValueCondition extends Condition {
    // @Ignore
    ValueCondition .fakeConstructor$() : super.fakeConstructor$();
    external String get propertyPath;

    external set propertyPath(String v);

    external dynamic get value;

    external set value(dynamic v);

    external num get JS$operator;

    external set JS$operator(num v);

    external static get JS$_IsEqual;

    external static set JS$_IsEqual(v);

    external static get JS$_IsDifferent;

    external static set JS$_IsDifferent(v);

    external static get JS$_IsGreater;

    external static set JS$_IsGreater(v);

    external static get JS$_IsLesser;

    external static set JS$_IsLesser(v);

    external static num get IsEqual;

    external static set IsEqual(num v);

    external static num get IsDifferent;

    external static set IsDifferent(num v);

    external static num get IsGreater;

    external static set IsGreater(num v);

    external static num get IsLesser;

    external static set IsLesser(num v);

    external ActionManager get JS$_actionManager;

    external set JS$_actionManager(ActionManager v);

    external get JS$_target;

    external set JS$_target(v);

    external get JS$_effectiveTarget;

    external set JS$_effectiveTarget(v);

    external get JS$_property;

    external set JS$_property(v);

    external factory ValueCondition(ActionManager actionManager, dynamic target, String propertyPath, dynamic value, [num JS$operator]);

    external bool isValid();

    external dynamic serialize();

    external static String GetOperatorName(num JS$operator);
}

@JS("BABYLON.PredicateCondition")
class PredicateCondition extends Condition {
    // @Ignore
    PredicateCondition .fakeConstructor$() : super.fakeConstructor$();
    external Func0<bool> get predicate;

    external set predicate(Func0<bool> v);

    external ActionManager get JS$_actionManager;

    external set JS$_actionManager(ActionManager v);

    external factory PredicateCondition(ActionManager actionManager, bool predicate());

    external bool isValid();
}

@JS("BABYLON.StateCondition")
class StateCondition extends Condition {
    // @Ignore
    StateCondition .fakeConstructor$() : super.fakeConstructor$();
    external String get value;

    external set value(String v);

    external ActionManager get JS$_actionManager;

    external set JS$_actionManager(ActionManager v);

    external get JS$_target;

    external set JS$_target(v);

    external factory StateCondition(ActionManager actionManager, dynamic target, String value);

    external bool isValid();

    external dynamic serialize();
}

@JS("BABYLON.SwitchBooleanAction")
class SwitchBooleanAction extends Action {
    // @Ignore
    SwitchBooleanAction .fakeConstructor$() : super.fakeConstructor$();
    external String get propertyPath;

    external set propertyPath(String v);

    external get JS$_target;

    external set JS$_target(v);

    external get JS$_effectiveTarget;

    external set JS$_effectiveTarget(v);

    external get JS$_property;

    external set JS$_property(v);

    external factory SwitchBooleanAction(dynamic triggerOptions, dynamic target, String propertyPath, [Condition condition]);

    external void JS$_prepare();

    external void execute();

    external dynamic serialize(dynamic parent);
}

@JS("BABYLON.SetStateAction")
class SetStateAction extends Action {
    // @Ignore
    SetStateAction .fakeConstructor$() : super.fakeConstructor$();
    external String get value;

    external set value(String v);

    external get JS$_target;

    external set JS$_target(v);

    external factory SetStateAction(dynamic triggerOptions, dynamic target, String value, [Condition condition]);

    external void execute();

    external dynamic serialize(dynamic parent);
}

@JS("BABYLON.SetValueAction")
class SetValueAction extends Action {
    // @Ignore
    SetValueAction .fakeConstructor$() : super.fakeConstructor$();
    external String get propertyPath;

    external set propertyPath(String v);

    external dynamic get value;

    external set value(dynamic v);

    external get JS$_target;

    external set JS$_target(v);

    external get JS$_effectiveTarget;

    external set JS$_effectiveTarget(v);

    external get JS$_property;

    external set JS$_property(v);

    external factory SetValueAction(dynamic triggerOptions, dynamic target, String propertyPath, dynamic value, [Condition condition]);

    external void JS$_prepare();

    external void execute();

    external dynamic serialize(dynamic parent);
}

@JS("BABYLON.IncrementValueAction")
class IncrementValueAction extends Action {
    // @Ignore
    IncrementValueAction .fakeConstructor$() : super.fakeConstructor$();
    external String get propertyPath;

    external set propertyPath(String v);

    external dynamic get value;

    external set value(dynamic v);

    external get JS$_target;

    external set JS$_target(v);

    external get JS$_effectiveTarget;

    external set JS$_effectiveTarget(v);

    external get JS$_property;

    external set JS$_property(v);

    external factory IncrementValueAction(dynamic triggerOptions, dynamic target, String propertyPath, dynamic value, [Condition condition]);

    external void JS$_prepare();

    external void execute();

    external dynamic serialize(dynamic parent);
}

@JS("BABYLON.PlayAnimationAction")
class PlayAnimationAction extends Action {
    // @Ignore
    PlayAnimationAction .fakeConstructor$() : super.fakeConstructor$();
    external num get from;

    external set from(num v);

    external num get to;

    external set to(num v);

    external bool get loop;

    external set loop(bool v);

    external get JS$_target;

    external set JS$_target(v);

    external factory PlayAnimationAction(dynamic triggerOptions, dynamic target, num from, num to, [bool loop, Condition condition]);

    external void JS$_prepare();

    external void execute();

    external dynamic serialize(dynamic parent);
}

@JS("BABYLON.StopAnimationAction")
class StopAnimationAction extends Action {
    // @Ignore
    StopAnimationAction .fakeConstructor$() : super.fakeConstructor$();
    external get JS$_target;

    external set JS$_target(v);

    external factory StopAnimationAction(dynamic triggerOptions, dynamic target, [Condition condition]);

    external void JS$_prepare();

    external void execute();

    external dynamic serialize(dynamic parent);
}

@JS("BABYLON.DoNothingAction")
class DoNothingAction extends Action {
    // @Ignore
    DoNothingAction .fakeConstructor$() : super.fakeConstructor$();

    external factory DoNothingAction([dynamic triggerOptions, Condition condition]);

    external void execute();

    external dynamic serialize(dynamic parent);
}

@JS("BABYLON.CombineAction")
class CombineAction extends Action {
    // @Ignore
    CombineAction .fakeConstructor$() : super.fakeConstructor$();
    external List<Action> get children;

    external set children(List<Action> v);

    external factory CombineAction(dynamic triggerOptions, List<Action> children, [Condition condition]);

    external void JS$_prepare();

    external void execute(ActionEvent evt);

    external dynamic serialize(dynamic parent);
}

@JS("BABYLON.ExecuteCodeAction")
class ExecuteCodeAction extends Action {
    // @Ignore
    ExecuteCodeAction .fakeConstructor$() : super.fakeConstructor$();
    external VoidFunc1<ActionEvent> get func;

    external set func(VoidFunc1<ActionEvent> v);

    external factory ExecuteCodeAction(dynamic triggerOptions, void func(ActionEvent evt), [Condition condition]);

    external void execute(ActionEvent evt);
}

@JS("BABYLON.SetParentAction")
class SetParentAction extends Action {
    // @Ignore
    SetParentAction .fakeConstructor$() : super.fakeConstructor$();
    external get JS$_parent;

    external set JS$_parent(v);

    external get JS$_target;

    external set JS$_target(v);

    external factory SetParentAction(dynamic triggerOptions, dynamic target, dynamic parent, [Condition condition]);

    external void JS$_prepare();

    external void execute();

    external dynamic serialize(dynamic parent);
}

@JS("BABYLON.PlaySoundAction")
class PlaySoundAction extends Action {
    // @Ignore
    PlaySoundAction .fakeConstructor$() : super.fakeConstructor$();
    external get JS$_sound;

    external set JS$_sound(v);

    external factory PlaySoundAction(dynamic triggerOptions, Sound sound, [Condition condition]);

    external void JS$_prepare();

    external void execute();

    external dynamic serialize(dynamic parent);
}

@JS("BABYLON.StopSoundAction")
class StopSoundAction extends Action {
    // @Ignore
    StopSoundAction .fakeConstructor$() : super.fakeConstructor$();
    external get JS$_sound;

    external set JS$_sound(v);

    external factory StopSoundAction(dynamic triggerOptions, Sound sound, [Condition condition]);

    external void JS$_prepare();

    external void execute();

    external dynamic serialize(dynamic parent);
}

@JS("BABYLON.InterpolateValueAction")
class InterpolateValueAction extends Action {
    // @Ignore
    InterpolateValueAction .fakeConstructor$() : super.fakeConstructor$();
    external String get propertyPath;

    external set propertyPath(String v);

    external dynamic get value;

    external set value(dynamic v);

    external num get duration;

    external set duration(num v);

    external bool get stopOtherAnimations;

    external set stopOtherAnimations(bool v);

    external VoidFunc0 get onInterpolationDone;

    external set onInterpolationDone(VoidFunc0 v);

    external Observable<InterpolateValueAction> get onInterpolationDoneObservable;

    external set onInterpolationDoneObservable(Observable<InterpolateValueAction> v);

    external get JS$_target;

    external set JS$_target(v);

    external get JS$_effectiveTarget;

    external set JS$_effectiveTarget(v);

    external get JS$_property;

    external set JS$_property(v);

    external factory InterpolateValueAction(dynamic triggerOptions, dynamic target, String propertyPath, dynamic value, [num duration, Condition condition, bool stopOtherAnimations, void onInterpolationDone()]);

    external void JS$_prepare();

    external void execute();

    external dynamic serialize(dynamic parent);
}

@JS("BABYLON.Analyser")
class Analyser {
    // @Ignore
    Analyser .fakeConstructor$();

    external num get SMOOTHING;

    external set SMOOTHING(num v);

    external num get FFT_SIZE;

    external set FFT_SIZE(num v);

    external num get BARGRAPHAMPLITUDE;

    external set BARGRAPHAMPLITUDE(num v);

    external dynamic/*{
            x: number;
            y: number;
        }*/ get DEBUGCANVASPOS;

    external set DEBUGCANVASPOS(dynamic/*{
            x: number;
            y: number;
        }*/
    v);

    external dynamic/*{
            width: number;
            height: number;
        }*/ get DEBUGCANVASSIZE;

    external set DEBUGCANVASSIZE(dynamic/*{
            width: number;
            height: number;
        }*/
    v);

    external get JS$_byteFreqs;

    external set JS$_byteFreqs(v);

    external get JS$_byteTime;

    external set JS$_byteTime(v);

    external get JS$_floatFreqs;

    external set JS$_floatFreqs(v);

    external get JS$_webAudioAnalyser;

    external set JS$_webAudioAnalyser(v);

    external get JS$_debugCanvas;

    external set JS$_debugCanvas(v);

    external get JS$_debugCanvasContext;

    external set JS$_debugCanvasContext(v);

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_registerFunc;

    external set JS$_registerFunc(v);

    external get JS$_audioEngine;

    external set JS$_audioEngine(v);

    external factory Analyser(Scene scene);

    external num getFrequencyBinCount();

    external Uint8List getByteFrequencyData();

    external Uint8List getByteTimeDomainData();

    external Float32List getFloatFrequencyData();

    external void drawDebugCanvas();

    external void stopDebugCanvas();

    external void connectAudioNodes(AudioNode inputAudioNode, AudioNode outputAudioNode);

    external void dispose();
}

@anonymous
@JS()
abstract class IAudioEngine
    implements IDisposable {
    external bool get canUseWebAudio;

    external set canUseWebAudio(bool v);

    external AudioContext/*AudioContext|Null*/ get audioContext;

    external set audioContext(AudioContext/*AudioContext|Null*/ v);

    external GainNode get masterGain;

    external set masterGain(GainNode v);

    external bool get isMP3supported;

    external set isMP3supported(bool v);

    external bool get isOGGsupported;

    external set isOGGsupported(bool v);

    external bool get WarnedWebAudioUnsupported;

    external set WarnedWebAudioUnsupported(bool v);

    external bool get useCustomUnlockedButton;

    external set useCustomUnlockedButton(bool v);

    external bool get unlocked;

    external set unlocked(bool v);

    external Observable<AudioEngine> get onAudioUnlockedObservable;

    external set onAudioUnlockedObservable(Observable<AudioEngine> v);

    external Observable<AudioEngine> get onAudioLockedObservable;

    external set onAudioLockedObservable(Observable<AudioEngine> v);

    external void lock();

    external void unlock();
}

@JS("BABYLON.AudioEngine")
class AudioEngine implements IAudioEngine {
    // @Ignore
    AudioEngine .fakeConstructor$();

    external get JS$_audioContext;

    external set JS$_audioContext(v);

    external get JS$_audioContextInitialized;

    external set JS$_audioContextInitialized(v);

    external get JS$_muteButton;

    external set JS$_muteButton(v);

    external get JS$_hostElement;

    external set JS$_hostElement(v);

    external bool get canUseWebAudio;

    external set canUseWebAudio(bool v);

    external GainNode get masterGain;

    external set masterGain(GainNode v);

    external bool get WarnedWebAudioUnsupported;

    external set WarnedWebAudioUnsupported(bool v);

    external bool get isMP3supported;

    external set isMP3supported(bool v);

    external bool get isOGGsupported;

    external set isOGGsupported(bool v);

    external bool get unlocked;

    external set unlocked(bool v);

    external bool get useCustomUnlockedButton;

    external set useCustomUnlockedButton(bool v);

    external Observable<AudioEngine> get onAudioUnlockedObservable;

    external set onAudioUnlockedObservable(Observable<AudioEngine> v);

    external Observable<AudioEngine> get onAudioLockedObservable;

    external set onAudioLockedObservable(Observable<AudioEngine> v);

    external AudioContext/*AudioContext|Null*/ get audioContext;

    external set audioContext(AudioContext/*AudioContext|Null*/ v);

    external get JS$_connectedAnalyser;

    external set JS$_connectedAnalyser(v);

    external factory AudioEngine([HtmlElement/*HtmlElement|Null*/ hostElement]);

    external void lock();

    external void unlock();

    external get JS$_resumeAudioContext;

    external set JS$_resumeAudioContext(v);

    external get JS$_initializeAudioContext;

    external set JS$_initializeAudioContext(v);

    external get JS$_tryToRun;

    external set JS$_tryToRun(v);

    external get JS$_triggerRunningState;

    external set JS$_triggerRunningState(v);

    external get JS$_triggerSuspendedState;

    external set JS$_triggerSuspendedState(v);

    external get JS$_displayMuteButton;

    external set JS$_displayMuteButton(v);

    external get JS$_moveButtonToTopLeft;

    external set JS$_moveButtonToTopLeft(v);

    external get JS$_onResize;

    external set JS$_onResize(v);

    external get JS$_hideMuteButton;

    external set JS$_hideMuteButton(v);

    external void dispose();

    external num getGlobalVolume();

    external void setGlobalVolume(num newVolume);

    external void connectToAnalyser(Analyser analyser);
}

@anonymous
@JS()
abstract class AbstractScene {
    external List<Sound>/*List<Sound>|Null*/ get sounds;

    external set sounds(List<Sound>/*List<Sound>|Null*/ v);
}

@anonymous
@JS()
abstract class Scene {
    external SoundTrack get JS$_mainSoundTrack;

    external set JS$_mainSoundTrack(SoundTrack v);

    external SoundTrack get mainSoundTrack;

    external set mainSoundTrack(SoundTrack v);

    external List<SoundTrack>/*List<SoundTrack>|Null*/ get soundTracks;

    external set soundTracks(List<SoundTrack>/*List<SoundTrack>|Null*/ v);

    external Sound/*Sound|Null*/ getSoundByName(String name);

    external bool get audioEnabled;

    external set audioEnabled(bool v);

    external bool get headphone;

    external set headphone(bool v);
}

@JS("BABYLON.AudioSceneComponent")
class AudioSceneComponent implements ISceneSerializableComponent {
    // @Ignore
    AudioSceneComponent .fakeConstructor$();

    external String get name;

    external set name(String v);

    external Scene get scene;

    external set scene(Scene v);

    external get JS$_audioEnabled;

    external set JS$_audioEnabled(v);

    external bool get audioEnabled;

    external set audioEnabled(bool v);

    external get JS$_headphone;

    external set JS$_headphone(v);

    external bool get headphone;

    external set headphone(bool v);

    external factory AudioSceneComponent(Scene scene);

    external void register();

    external void rebuild();

    external void serialize(dynamic serializationObject);

    external void addFromContainer(AbstractScene container);

    external void removeFromContainer(AbstractScene container);

    external void dispose();

    external void disableAudio();

    external void enableAudio();

    external void switchAudioModeForHeadphones();

    external void switchAudioModeForNormalSpeakers();

    external get JS$_afterRender;

    external set JS$_afterRender(v);
}

@JS("BABYLON.Sound")
class Sound {
    // @Ignore
    Sound .fakeConstructor$();

    external String get name;

    external set name(String v);

    external bool get autoplay;

    external set autoplay(bool v);

    external bool get loop;

    external set loop(bool v);

    external bool get useCustomAttenuation;

    external set useCustomAttenuation(bool v);

    external num get soundTrackId;

    external set soundTrackId(num v);

    external bool get isPlaying;

    external set isPlaying(bool v);

    external bool get isPaused;

    external set isPaused(bool v);

    external bool get spatialSound;

    external set spatialSound(bool v);

    external num get refDistance;

    external set refDistance(num v);

    external num get rolloffFactor;

    external set rolloffFactor(num v);

    external num get maxDistance;

    external set maxDistance(num v);

    external String get distanceModel;

    external set distanceModel(String v);

    external Func0<dynamic> get onended;

    external set onended(Func0<dynamic> v);

    external Observable<Sound> get onEndedObservable;

    external set onEndedObservable(Observable<Sound> v);

    external get JS$_panningModel;

    external set JS$_panningModel(v);

    external get JS$_playbackRate;

    external set JS$_playbackRate(v);

    external get JS$_streaming;

    external set JS$_streaming(v);

    external get JS$_startTime;

    external set JS$_startTime(v);

    external get JS$_startOffset;

    external set JS$_startOffset(v);

    external get JS$_position;

    external set JS$_position(v);

    external bool get JS$_positionInEmitterSpace;

    external set JS$_positionInEmitterSpace(bool v);

    external get JS$_localDirection;

    external set JS$_localDirection(v);

    external get JS$_volume;

    external set JS$_volume(v);

    external get JS$_isReadyToPlay;

    external set JS$_isReadyToPlay(v);

    external get JS$_isDirectional;

    external set JS$_isDirectional(v);

    external get JS$_readyToPlayCallback;

    external set JS$_readyToPlayCallback(v);

    external get JS$_audioBuffer;

    external set JS$_audioBuffer(v);

    external get JS$_soundSource;

    external set JS$_soundSource(v);

    external get JS$_streamingSource;

    external set JS$_streamingSource(v);

    external get JS$_soundPanner;

    external set JS$_soundPanner(v);

    external get JS$_soundGain;

    external set JS$_soundGain(v);

    external get JS$_inputAudioNode;

    external set JS$_inputAudioNode(v);

    external get JS$_outputAudioNode;

    external set JS$_outputAudioNode(v);

    external get JS$_coneInnerAngle;

    external set JS$_coneInnerAngle(v);

    external get JS$_coneOuterAngle;

    external set JS$_coneOuterAngle(v);

    external get JS$_coneOuterGain;

    external set JS$_coneOuterGain(v);

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_connectedMesh;

    external set JS$_connectedMesh(v);

    external get JS$_customAttenuationFunction;

    external set JS$_customAttenuationFunction(v);

    external get JS$_registerFunc;

    external set JS$_registerFunc(v);

    external get JS$_isOutputConnected;

    external set JS$_isOutputConnected(v);

    external get JS$_htmlAudioElement;

    external set JS$_htmlAudioElement(v);

    external get JS$_urlType;

    external set JS$_urlType(v);

    external factory Sound(String name, dynamic urlOrArrayBuffer, Scene scene, [VoidFunc0/*VoidFunc0|Null*/ readyToPlayCallback, dynamic options]);

    external void dispose();

    external bool isReady();

    external get JS$_soundLoaded;

    external set JS$_soundLoaded(v);

    external void setAudioBuffer(AudioBuffer audioBuffer);

    external void updateOptions(dynamic options);

    external get JS$_createSpatialParameters;

    external set JS$_createSpatialParameters(v);

    external get JS$_updateSpatialParameters;

    external set JS$_updateSpatialParameters(v);

    external void switchPanningModelToHRTF();

    external void switchPanningModelToEqualPower();

    external get JS$_switchPanningModel;

    external set JS$_switchPanningModel(v);

    external void connectToSoundTrackAudioNode(AudioNode soundTrackAudioNode);

    external void setDirectionalCone(num coneInnerAngle, num coneOuterAngle, num coneOuterGain);

    external num get directionalConeInnerAngle;

    external set directionalConeInnerAngle(num v);

    external num get directionalConeOuterAngle;

    external set directionalConeOuterAngle(num v);

    external void setPosition(Vector3 newPosition);

    external void setLocalDirectionToMesh(Vector3 newLocalDirection);

    external get JS$_updateDirection;

    external set JS$_updateDirection(v);

    external void updateDistanceFromListener();

    external void setAttenuationFunction(num callback(num currentVolume, num currentDistance, num maxDistance, num refDistance, num rolloffFactor));

    external void play([num time, num offset]);

    external get JS$_onended;

    external set JS$_onended(v);

    external void stop([num time]);

    external void pause();

    external void setVolume(num newVolume, [num time]);

    external void setPlaybackRate(num newPlaybackRate);

    external num getVolume();

    external void attachToMesh(AbstractMesh meshToConnectTo);

    external void detachFromMesh();

    external get JS$_onRegisterAfterWorldMatrixUpdate;

    external set JS$_onRegisterAfterWorldMatrixUpdate(v);

    external Sound/*Sound|Null*/ clone();

    external AudioBuffer/*AudioBuffer|Null*/ getAudioBuffer();

    external dynamic serialize();

    external static Sound Parse(dynamic parsedSound, Scene scene, String rootUrl, [Sound sourceSound]);
}

@anonymous
@JS()
abstract class ISoundTrackOptions {
    external num get volume;

    external set volume(num v);

    external bool get mainTrack;

    external set mainTrack(bool v);

    external factory ISoundTrackOptions({ num volume, bool mainTrack});
}

@JS("BABYLON.SoundTrack")
class SoundTrack {
    // @Ignore
    SoundTrack .fakeConstructor$();

    external num get id;

    external set id(num v);

    external List<Sound> get soundCollection;

    external set soundCollection(List<Sound> v);

    external get JS$_outputAudioNode;

    external set JS$_outputAudioNode(v);

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_isMainTrack;

    external set JS$_isMainTrack(v);

    external get JS$_connectedAnalyser;

    external set JS$_connectedAnalyser(v);

    external get JS$_options;

    external set JS$_options(v);

    external get JS$_isInitialized;

    external set JS$_isInitialized(v);

    external factory SoundTrack(Scene scene, [ISoundTrackOptions options]);

    external get JS$_initializeSoundTrackAudioGraph;

    external set JS$_initializeSoundTrackAudioGraph(v);

    external void dispose();

    external void AddSound(Sound sound);

    external void RemoveSound(Sound sound);

    external void setVolume(num newVolume);

    external void switchPanningModelToHRTF();

    external void switchPanningModelToEqualPower();

    external void connectToAnalyser(Analyser analyser);
}

@JS("BABYLON.WeightedSound")
class WeightedSound {
    // @Ignore
    WeightedSound .fakeConstructor$();

    external bool get loop;

    external set loop(bool v);

    external get JS$_coneInnerAngle;

    external set JS$_coneInnerAngle(v);

    external get JS$_coneOuterAngle;

    external set JS$_coneOuterAngle(v);

    external get JS$_volume;

    external set JS$_volume(v);

    external bool get isPlaying;

    external set isPlaying(bool v);

    external bool get isPaused;

    external set isPaused(bool v);

    external get JS$_sounds;

    external set JS$_sounds(v);

    external get JS$_weights;

    external set JS$_weights(v);

    external get JS$_currentIndex;

    external set JS$_currentIndex(v);

    external factory WeightedSound(bool loop, List<Sound> sounds, List<num> weights);

    external num get directionalConeInnerAngle;

    external set directionalConeInnerAngle(num v);

    external num get directionalConeOuterAngle;

    external set directionalConeOuterAngle(num v);

    external num get volume;

    external set volume(num v);

    external get JS$_onended;

    external set JS$_onended(v);

    external void pause();

    external void stop();

    external void play([num startOffset]);
}

@JS("BABYLON.Animatable")
class Animatable {
    // @Ignore
    Animatable .fakeConstructor$();

    external dynamic get target;

    external set target(dynamic v);

    external num get fromFrame;

    external set fromFrame(num v);

    external num get toFrame;

    external set toFrame(num v);

    external bool get loopAnimation;

    external set loopAnimation(bool v);

    external dynamic/*VoidFunc0|Null|dynamic*/ get onAnimationEnd;

    external set onAnimationEnd(dynamic/*VoidFunc0|Null|dynamic*/ v);

    external get JS$_localDelayOffset;

    external set JS$_localDelayOffset(v);

    external get JS$_pausedDelay;

    external set JS$_pausedDelay(v);

    external get JS$_runtimeAnimations;

    external set JS$_runtimeAnimations(v);

    external get JS$_paused;

    external set JS$_paused(v);

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_speedRatio;

    external set JS$_speedRatio(v);

    external get JS$_weight;

    external set JS$_weight(v);

    external get JS$_syncRoot;

    external set JS$_syncRoot(v);

    external bool get disposeOnEnd;

    external set disposeOnEnd(bool v);

    external bool get animationStarted;

    external set animationStarted(bool v);

    external Observable<Animatable> get onAnimationEndObservable;

    external set onAnimationEndObservable(Observable<Animatable> v);

    external Animatable get syncRoot;

    external set syncRoot(Animatable v);

    external num get masterFrame;

    external set masterFrame(num v);

    external num get weight;

    external set weight(num v);

    external num get speedRatio;

    external set speedRatio(num v);

    external factory Animatable(Scene scene, dynamic target, [num fromFrame, num toFrame, bool loopAnimation, num speedRatio, dynamic/*VoidFunc0|Null|dynamic*/ onAnimationEnd, List<Animation> animations]);

    external Animatable syncWith(Animatable root);

    external List<RuntimeAnimation> getAnimations();

    external void appendAnimations(dynamic target, List<Animation> animations);

    external Animation/*Animation|Null*/ getAnimationByTargetProperty(String property);

    external RuntimeAnimation/*RuntimeAnimation|Null*/ getRuntimeAnimationByTargetProperty(String property);

    external void reset();

    external void enableBlending(num blendingSpeed);

    external void disableBlending();

    external void goToFrame(num frame);

    external void pause();

    external void restart();

    external get JS$_raiseOnAnimationEnd;

    external set JS$_raiseOnAnimationEnd(v);

    external void stop([String animationName, bool targetMask(dynamic target)]);

    external Promise<Animatable> waitAsync();

    external bool JS$_animate(num delay);
}

@JS("BABYLON.AnimationRange")
class AnimationRange {
    // @Ignore
    AnimationRange .fakeConstructor$();

    external String get name;

    external set name(String v);

    external num get from;

    external set from(num v);

    external num get to;

    external set to(num v);

    external factory AnimationRange(String name, num from, num to);

    external AnimationRange clone();
}

@JS("BABYLON.AnimationEvent")
class AnimationEvent {
    // @Ignore
    AnimationEvent .fakeConstructor$();

    external num get frame;

    external set frame(num v);

    external VoidFunc1<num> get action;

    external set action(VoidFunc1<num> v);

    external dynamic/*bool|dynamic*/ get onlyOnce;

    external set onlyOnce(dynamic/*bool|dynamic*/ v);

    external bool get isDone;

    external set isDone(bool v);

    external factory AnimationEvent(num frame, void action(num currentFrame), [dynamic/*bool|dynamic*/ onlyOnce]);

    external AnimationEvent JS$_clone();
}

@JS("BABYLON.PathCursor")
class PathCursor {
    // @Ignore
    PathCursor .fakeConstructor$();

    external get path;

    external set path(v);

    external get JS$_onchange;

    external set JS$_onchange(v);

    external num get value;

    external set value(num v);

    external List<Animation> get animations;

    external set animations(List<Animation> v);

    external factory PathCursor(Path2 path);

    external Vector3 getPoint();

    external PathCursor moveAhead([num step]);

    external PathCursor moveBack([num step]);

    external PathCursor move(num step);

    external get ensureLimits;

    external set ensureLimits(v);

    external get raiseOnChange;

    external set raiseOnChange(v);

    external PathCursor onchange(void f(PathCursor cursor));
}

@anonymous
@JS()
abstract class IAnimationKey {
    external num get frame;

    external set frame(num v);

    external dynamic get value;

    external set value(dynamic v);

    external dynamic get inTangent;

    external set inTangent(dynamic v);

    external dynamic get outTangent;

    external set outTangent(dynamic v);

    external num/*enum AnimationKeyInterpolation*/ get interpolation;

    external set interpolation(num/*enum AnimationKeyInterpolation*/ v);

    external factory IAnimationKey({ num frame, dynamic value, dynamic inTangent, dynamic outTangent, num/*enum AnimationKeyInterpolation*/ interpolation});
}

@JS("BABYLON.AnimationKeyInterpolation")
class AnimationKeyInterpolation {
    external static num get STEP;
}

@JS("BABYLON.Animation")
class Animation {
    // @Ignore
    Animation .fakeConstructor$();

    external String get name;

    external set name(String v);

    external String get targetProperty;

    external set targetProperty(String v);

    external num get framePerSecond;

    external set framePerSecond(num v);

    external num get dataType;

    external set dataType(num v);

    external dynamic/*num|dynamic*/ get loopMode;

    external set loopMode(dynamic/*num|dynamic*/ v);

    external dynamic/*bool|dynamic*/ get enableBlending;

    external set enableBlending(dynamic/*bool|dynamic*/ v);

    external static bool get AllowMatricesInterpolation;

    external static set AllowMatricesInterpolation(bool v);

    external static bool get AllowMatrixDecomposeForInterpolation;

    external static set AllowMatrixDecomposeForInterpolation(bool v);

    external get JS$_keys;

    external set JS$_keys(v);

    external get JS$_easingFunction;

    external set JS$_easingFunction(v);

    external List<RuntimeAnimation> get JS$_runtimeAnimations;

    external set JS$_runtimeAnimations(List<RuntimeAnimation> v);

    external get JS$_events;

    external set JS$_events(v);

    external List<String> get targetPropertyPath;

    external set targetPropertyPath(List<String> v);

    external num get blendingSpeed;

    external set blendingSpeed(num v);

    external get JS$_ranges;

    external set JS$_ranges(v);

    external static Animation/*Animation|Null*/ JS$_PrepareAnimation(String name, String targetProperty, num framePerSecond, num totalFrame, dynamic from, dynamic to, [num loopMode, EasingFunction easingFunction]);

    external static Animation CreateAnimation(String property, num animationType, num framePerSecond, EasingFunction easingFunction);

    external static Animatable/*Animatable|Null*/ CreateAndStartAnimation(String name, Node node, String targetProperty, num framePerSecond, num totalFrame, dynamic from, dynamic to, [num loopMode, EasingFunction easingFunction, void onAnimationEnd()]);

    external static List<Animatable>/*List<Animatable>|Null*/ CreateAndStartHierarchyAnimation(String name, Node node, bool directDescendantsOnly, String targetProperty, num framePerSecond, num totalFrame, dynamic from, dynamic to, [num loopMode, EasingFunction easingFunction, void onAnimationEnd()]);

    external static Animatable/*Animatable|Null*/ CreateMergeAndStartAnimation(String name, Node node, String targetProperty, num framePerSecond, num totalFrame, dynamic from, dynamic to, [num loopMode, EasingFunction easingFunction, void onAnimationEnd()]);

    external static Animatable/*Animatable|Null*/ TransitionTo(String property, dynamic targetValue, dynamic host, Scene scene, num frameRate, Animation transition, num duration, [VoidFunc0/*VoidFunc0|Null*/ onAnimationEnd]);

    external List<RuntimeAnimation> get runtimeAnimations;

    external set runtimeAnimations(List<RuntimeAnimation> v);

    external bool get hasRunningRuntimeAnimations;

    external set hasRunningRuntimeAnimations(bool v);

    external factory Animation(String name, String targetProperty, num framePerSecond, num dataType, [dynamic/*num|dynamic*/ loopMode, dynamic/*bool|dynamic*/ enableBlending]);

    external String toString([bool fullDetails]);

    external void addEvent(AnimationEvent event);

    external void removeEvents(num frame);

    external List<AnimationEvent> getEvents();

    external void createRange(String name, num from, num to);

    external void deleteRange(String name, [bool deleteFrames]);

    external AnimationRange/*AnimationRange|Null*/ getRange(String name);

    external List<IAnimationKey> getKeys();

    external num getHighestFrame();

    external IEasingFunction getEasingFunction();

    external void setEasingFunction(EasingFunction easingFunction);

    external num floatInterpolateFunction(num startValue, num endValue, num gradient);

    external num floatInterpolateFunctionWithTangents(num startValue, num outTangent, num endValue, num inTangent, num gradient);

    external Quaternion quaternionInterpolateFunction(Quaternion startValue, Quaternion endValue, num gradient);

    external Quaternion quaternionInterpolateFunctionWithTangents(Quaternion startValue, Quaternion outTangent, Quaternion endValue, Quaternion inTangent, num gradient);

    external Vector3 vector3InterpolateFunction(Vector3 startValue, Vector3 endValue, num gradient);

    external Vector3 vector3InterpolateFunctionWithTangents(Vector3 startValue, Vector3 outTangent, Vector3 endValue, Vector3 inTangent, num gradient);

    external Vector2 vector2InterpolateFunction(Vector2 startValue, Vector2 endValue, num gradient);

    external Vector2 vector2InterpolateFunctionWithTangents(Vector2 startValue, Vector2 outTangent, Vector2 endValue, Vector2 inTangent, num gradient);

    external Size sizeInterpolateFunction(Size startValue, Size endValue, num gradient);

    external Color3 color3InterpolateFunction(Color3 startValue, Color3 endValue, num gradient);

    external dynamic JS$_getKeyValue(dynamic value);

    external dynamic JS$_interpolate(num currentFrame, num repeatCount, [dynamic workValue, num loopMode, dynamic offsetValue, dynamic highLimitValue]);

    external Matrix matrixInterpolateFunction(Matrix startValue, Matrix endValue, num gradient, [Matrix result]);

    external Animation clone();

    external void setKeys(List<IAnimationKey> values);

    external dynamic serialize();

    external static get JS$_ANIMATIONTYPE_FLOAT;

    external static set JS$_ANIMATIONTYPE_FLOAT(v);

    external static get JS$_ANIMATIONTYPE_VECTOR3;

    external static set JS$_ANIMATIONTYPE_VECTOR3(v);

    external static get JS$_ANIMATIONTYPE_QUATERNION;

    external static set JS$_ANIMATIONTYPE_QUATERNION(v);

    external static get JS$_ANIMATIONTYPE_MATRIX;

    external static set JS$_ANIMATIONTYPE_MATRIX(v);

    external static get JS$_ANIMATIONTYPE_COLOR3;

    external static set JS$_ANIMATIONTYPE_COLOR3(v);

    external static get JS$_ANIMATIONTYPE_VECTOR2;

    external static set JS$_ANIMATIONTYPE_VECTOR2(v);

    external static get JS$_ANIMATIONTYPE_SIZE;

    external static set JS$_ANIMATIONTYPE_SIZE(v);

    external static get JS$_ANIMATIONLOOPMODE_RELATIVE;

    external static set JS$_ANIMATIONLOOPMODE_RELATIVE(v);

    external static get JS$_ANIMATIONLOOPMODE_CYCLE;

    external static set JS$_ANIMATIONLOOPMODE_CYCLE(v);

    external static get JS$_ANIMATIONLOOPMODE_CONSTANT;

    external static set JS$_ANIMATIONLOOPMODE_CONSTANT(v);

    external static num get ANIMATIONTYPE_FLOAT;

    external static set ANIMATIONTYPE_FLOAT(num v);

    external static num get ANIMATIONTYPE_VECTOR3;

    external static set ANIMATIONTYPE_VECTOR3(num v);

    external static num get ANIMATIONTYPE_VECTOR2;

    external static set ANIMATIONTYPE_VECTOR2(num v);

    external static num get ANIMATIONTYPE_SIZE;

    external static set ANIMATIONTYPE_SIZE(num v);

    external static num get ANIMATIONTYPE_QUATERNION;

    external static set ANIMATIONTYPE_QUATERNION(num v);

    external static num get ANIMATIONTYPE_MATRIX;

    external static set ANIMATIONTYPE_MATRIX(num v);

    external static num get ANIMATIONTYPE_COLOR3;

    external static set ANIMATIONTYPE_COLOR3(num v);

    external static num get ANIMATIONLOOPMODE_RELATIVE;

    external static set ANIMATIONLOOPMODE_RELATIVE(num v);

    external static num get ANIMATIONLOOPMODE_CYCLE;

    external static set ANIMATIONLOOPMODE_CYCLE(num v);

    external static num get ANIMATIONLOOPMODE_CONSTANT;

    external static set ANIMATIONLOOPMODE_CONSTANT(num v);

    external static dynamic JS$_UniversalLerp(dynamic left, dynamic right, num amount);

    external static Animation Parse(dynamic parsedAnimation);

    external static void AppendSerializedAnimations(IAnimatable source, dynamic destination);
}

@JS("BABYLON.TargetedAnimation")
class TargetedAnimation {
    // @Ignore
    TargetedAnimation .fakeConstructor$();

    external Animation get animation;

    external set animation(Animation v);

    external dynamic get target;

    external set target(dynamic v);
}

@JS("BABYLON.AnimationGroup")
class AnimationGroup implements IDisposable {
    // @Ignore
    AnimationGroup .fakeConstructor$();

    external String get name;

    external set name(String v);

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_targetedAnimations;

    external set JS$_targetedAnimations(v);

    external get JS$_animatables;

    external set JS$_animatables(v);

    external get JS$_from;

    external set JS$_from(v);

    external get JS$_to;

    external set JS$_to(v);

    external get JS$_isStarted;

    external set JS$_isStarted(v);

    external get JS$_speedRatio;

    external set JS$_speedRatio(v);

    external Observable<TargetedAnimation> get onAnimationEndObservable;

    external set onAnimationEndObservable(Observable<TargetedAnimation> v);

    external Observable<AnimationGroup> get onAnimationGroupEndObservable;

    external set onAnimationGroupEndObservable(Observable<AnimationGroup> v);

    external Observable<AnimationGroup> get onAnimationGroupPauseObservable;

    external set onAnimationGroupPauseObservable(Observable<AnimationGroup> v);

    external num get from;

    external set from(num v);

    external num get to;

    external set to(num v);

    external bool get isStarted;

    external set isStarted(bool v);

    external num get speedRatio;

    external set speedRatio(num v);

    external List<TargetedAnimation> get targetedAnimations;

    external set targetedAnimations(List<TargetedAnimation> v);

    external List<Animatable> get animatables;

    external set animatables(List<Animatable> v);

    external factory AnimationGroup(String name, [Scene/*Scene|Null*/ scene]);

    external TargetedAnimation addTargetedAnimation(Animation animation, dynamic target);

    external AnimationGroup normalize([num/*num|Null*/ beginFrame, num/*num|Null*/ endFrame]);

    external AnimationGroup start([bool loop, num speedRatio, num from, num to]);

    external AnimationGroup pause();

    external AnimationGroup play([bool loop]);

    external AnimationGroup reset();

    external AnimationGroup restart();

    external AnimationGroup stop();

    external AnimationGroup setWeightForAllAnimatables(num weight);

    external AnimationGroup syncAllAnimationsWith(Animatable root);

    external AnimationGroup goToFrame(num frame);

    external void dispose();

    external get JS$_checkAnimationGroupEnded;

    external set JS$_checkAnimationGroupEnded(v);

    external static AnimationGroup Parse(dynamic parsedAnimationGroup, Scene scene);

    external String getClassName();

    external String toString([bool fullDetails]);
}

@JS("BABYLON.AnimationPropertiesOverride")
class AnimationPropertiesOverride {
    // @Ignore
    AnimationPropertiesOverride .fakeConstructor$();

    external bool get enableBlending;

    external set enableBlending(bool v);

    external num get blendingSpeed;

    external set blendingSpeed(num v);

    external num get loopMode;

    external set loopMode(num v);
}

@anonymous
@JS()
abstract class IEasingFunction {
    external num ease(num gradient);
}

@JS("BABYLON.EasingFunction")
class EasingFunction implements IEasingFunction {
    // @Ignore
    EasingFunction .fakeConstructor$();

    external static num get EASINGMODE_EASEIN;

    external static set EASINGMODE_EASEIN(num v);

    external static num get EASINGMODE_EASEOUT;

    external static set EASINGMODE_EASEOUT(num v);

    external static num get EASINGMODE_EASEINOUT;

    external static set EASINGMODE_EASEINOUT(num v);

    external get JS$_easingMode;

    external set JS$_easingMode(v);

    external void setEasingMode(num easingMode);

    external num getEasingMode();

    external num easeInCore(num gradient);

    external num ease(num gradient);
}

@JS("BABYLON.CircleEase")
class CircleEase extends EasingFunction implements IEasingFunction {
    // @Ignore
    CircleEase .fakeConstructor$() : super.fakeConstructor$();
    external num easeInCore(num gradient);
}

@JS("BABYLON.BackEase")
class BackEase extends EasingFunction implements IEasingFunction {
    // @Ignore
    BackEase .fakeConstructor$() : super.fakeConstructor$();
    external num get amplitude;

    external set amplitude(num v);

    external factory BackEase([num amplitude]);

    external num easeInCore(num gradient);
}

@JS("BABYLON.BounceEase")
class BounceEase extends EasingFunction implements IEasingFunction {
    // @Ignore
    BounceEase .fakeConstructor$() : super.fakeConstructor$();
    external num get bounces;

    external set bounces(num v);

    external num get bounciness;

    external set bounciness(num v);

    external factory BounceEase([num bounces, num bounciness]);

    external num easeInCore(num gradient);
}

@JS("BABYLON.CubicEase")
class CubicEase extends EasingFunction implements IEasingFunction {
    // @Ignore
    CubicEase .fakeConstructor$() : super.fakeConstructor$();
    external num easeInCore(num gradient);
}

@JS("BABYLON.ElasticEase")
class ElasticEase extends EasingFunction implements IEasingFunction {
    // @Ignore
    ElasticEase .fakeConstructor$() : super.fakeConstructor$();
    external num get oscillations;

    external set oscillations(num v);

    external num get springiness;

    external set springiness(num v);

    external factory ElasticEase([num oscillations, num springiness]);

    external num easeInCore(num gradient);
}

@JS("BABYLON.ExponentialEase")
class ExponentialEase extends EasingFunction implements IEasingFunction {
    // @Ignore
    ExponentialEase .fakeConstructor$() : super.fakeConstructor$();
    external num get exponent;

    external set exponent(num v);

    external factory ExponentialEase([num exponent]);

    external num easeInCore(num gradient);
}

@JS("BABYLON.PowerEase")
class PowerEase extends EasingFunction implements IEasingFunction {
    // @Ignore
    PowerEase .fakeConstructor$() : super.fakeConstructor$();
    external num get power;

    external set power(num v);

    external factory PowerEase([num power]);

    external num easeInCore(num gradient);
}

@JS("BABYLON.QuadraticEase")
class QuadraticEase extends EasingFunction implements IEasingFunction {
    // @Ignore
    QuadraticEase .fakeConstructor$() : super.fakeConstructor$();
    external num easeInCore(num gradient);
}

@JS("BABYLON.QuarticEase")
class QuarticEase extends EasingFunction implements IEasingFunction {
    // @Ignore
    QuarticEase .fakeConstructor$() : super.fakeConstructor$();
    external num easeInCore(num gradient);
}

@JS("BABYLON.QuinticEase")
class QuinticEase extends EasingFunction implements IEasingFunction {
    // @Ignore
    QuinticEase .fakeConstructor$() : super.fakeConstructor$();
    external num easeInCore(num gradient);
}

@JS("BABYLON.SineEase")
class SineEase extends EasingFunction implements IEasingFunction {
    // @Ignore
    SineEase .fakeConstructor$() : super.fakeConstructor$();
    external num easeInCore(num gradient);
}

@JS("BABYLON.BezierCurveEase")
class BezierCurveEase extends EasingFunction implements IEasingFunction {
    // @Ignore
    BezierCurveEase .fakeConstructor$() : super.fakeConstructor$();
    external num get x1;

    external set x1(num v);

    external num get y1;

    external set y1(num v);

    external num get x2;

    external set x2(num v);

    external num get y2;

    external set y2(num v);

    external factory BezierCurveEase([num x1, num y1, num x2, num y2]);

    external num easeInCore(num gradient);
}

@JS("BABYLON.RuntimeAnimation")
class RuntimeAnimation {
    // @Ignore
    RuntimeAnimation .fakeConstructor$();

    external get JS$_events;

    external set JS$_events(v);

    external get JS$_currentFrame;

    external set JS$_currentFrame(v);

    external get JS$_animation;

    external set JS$_animation(v);

    external get JS$_target;

    external set JS$_target(v);

    external get JS$_host;

    external set JS$_host(v);

    external get JS$_originalValue;

    external set JS$_originalValue(v);

    external get JS$_originalBlendValue;

    external set JS$_originalBlendValue(v);

    external get JS$_offsetsCache;

    external set JS$_offsetsCache(v);

    external get JS$_highLimitsCache;

    external set JS$_highLimitsCache(v);

    external get JS$_stopped;

    external set JS$_stopped(v);

    external get JS$_blendingFactor;

    external set JS$_blendingFactor(v);

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_currentValue;

    external set JS$_currentValue(v);

    external dynamic get JS$_workValue;

    external set JS$_workValue(dynamic v);

    external get JS$_activeTarget;

    external set JS$_activeTarget(v);

    external get JS$_targetPath;

    external set JS$_targetPath(v);

    external get JS$_weight;

    external set JS$_weight(v);

    external get JS$_ratioOffset;

    external set JS$_ratioOffset(v);

    external get JS$_previousDelay;

    external set JS$_previousDelay(v);

    external get JS$_previousRatio;

    external set JS$_previousRatio(v);

    external num get currentFrame;

    external set currentFrame(num v);

    external num get weight;

    external set weight(num v);

    external dynamic get currentValue;

    external set currentValue(dynamic v);

    external String get targetPath;

    external set targetPath(String v);

    external dynamic get target;

    external set target(dynamic v);

    external factory RuntimeAnimation(dynamic target, Animation animation, Scene scene, Animatable host);

    external Animation get animation;

    external set animation(Animation v);

    external void reset([bool restoreOriginal]);

    external bool isStopped();

    external void dispose();

    external get JS$_interpolate;

    external set JS$_interpolate(v);

    external void setValue(dynamic currentValue, [num weight]);

    external get JS$_setValue;

    external set JS$_setValue(v);

    external get JS$_getCorrectLoopMode;

    external set JS$_getCorrectLoopMode(v);

    external void goToFrame(num frame);

    external void JS$_prepareForSpeedRatioChange(num newSpeedRatio);

    external bool animate(num delay, num from, num to, bool loop, num speedRatio, [num weight]);
}

@anonymous
@JS()
abstract class Behavior<T> {
    external String get name;

    external set name(String v);

    external void init();

    external void attach(T target);

    external void detach();
}

@anonymous
@JS()
abstract class IBehaviorAware<T> {
    external T addBehavior(Behavior<T> behavior);

    external T removeBehavior(Behavior<T> behavior);

    external Behavior<T>/*Behavior<T>|Null*/ getBehaviorByName(String name);
}

@JS("BABYLON.Bone")
class Bone extends Node {
    // @Ignore
    Bone .fakeConstructor$() : super.fakeConstructor$();
    external String get name;

    external set name(String v);

    external static get JS$_tmpVecs;

    external static set JS$_tmpVecs(v);

    external static get JS$_tmpQuat;

    external static set JS$_tmpQuat(v);

    external static get JS$_tmpMats;

    external static set JS$_tmpMats(v);

    external List<Bone> get children;

    external set children(List<Bone> v);

    external List<Animation> get animations;

    external set animations(List<Animation> v);

    external num get length;

    external set length(num v);

    external num/*num|Null*/ get JS$_index;

    external set JS$_index(num/*num|Null*/ v);

    external get JS$_skeleton;

    external set JS$_skeleton(v);

    external get JS$_localMatrix;

    external set JS$_localMatrix(v);

    external get JS$_restPose;

    external set JS$_restPose(v);

    external get JS$_baseMatrix;

    external set JS$_baseMatrix(v);

    external get JS$_absoluteTransform;

    external set JS$_absoluteTransform(v);

    external get JS$_invertedAbsoluteTransform;

    external set JS$_invertedAbsoluteTransform(v);

    external get JS$_parent;

    external set JS$_parent(v);

    external get JS$_scalingDeterminant;

    external set JS$_scalingDeterminant(v);

    external get JS$_worldTransform;

    external set JS$_worldTransform(v);

    external get JS$_localScaling;

    external set JS$_localScaling(v);

    external get JS$_localRotation;

    external set JS$_localRotation(v);

    external get JS$_localPosition;

    external set JS$_localPosition(v);

    external get JS$_needToDecompose;

    external set JS$_needToDecompose(v);

    external get JS$_needToCompose;

    external set JS$_needToCompose(v);

    external Matrix get JS$_matrix;

    external set JS$_matrix(Matrix v);

    external factory Bone(String name, Skeleton skeleton, [Bone/*Bone|Null*/ parentBone, Matrix/*Matrix|Null*/ localMatrix, Matrix/*Matrix|Null*/ restPose, Matrix/*Matrix|Null*/ baseMatrix, num/*num|Null*/ index]);

    external Skeleton getSkeleton();

    external Bone/*Bone|Null*/ getParent();

    external void setParent(Bone/*Bone|Null*/ parent, [bool updateDifferenceMatrix]);

    external Matrix getLocalMatrix();

    external Matrix getBaseMatrix();

    external Matrix getRestPose();

    external Matrix getWorldMatrix();

    external void returnToRest();

    external Matrix getInvertedAbsoluteTransform();

    external Matrix getAbsoluteTransform();

    external Vector3 get position;

    external set position(Vector3 v);

    external Vector3 get rotation;

    external set rotation(Vector3 v);

    external Quaternion get rotationQuaternion;

    external set rotationQuaternion(Quaternion v);

    external Vector3 get scaling;

    external set scaling(Vector3 v);

    external AnimationPropertiesOverride/*AnimationPropertiesOverride|Null*/ get animationPropertiesOverride;

    external set animationPropertiesOverride(AnimationPropertiesOverride/*AnimationPropertiesOverride|Null*/ v);

    external get JS$_decompose;

    external set JS$_decompose(v);

    external get JS$_compose;

    external set JS$_compose(v);

    external void updateMatrix(Matrix matrix, [bool updateDifferenceMatrix, bool updateLocalMatrix]);

    external void JS$_updateDifferenceMatrix([Matrix rootMatrix, bool updateChildren]);

    external void markAsDirty();

    external get JS$_markAsDirtyAndCompose;

    external set JS$_markAsDirtyAndCompose(v);

    external get JS$_markAsDirtyAndDecompose;

    external set JS$_markAsDirtyAndDecompose(v);

    external bool copyAnimationRange(Bone source, String rangeName, num frameOffset, [bool rescaleAsRequired, Vector3/*Vector3|Null*/ skelDimensionsRatio]);

    external void translate(Vector3 vec, [num/*enum Space*/ space, AbstractMesh mesh]);

    external void setPosition(Vector3 position, [num/*enum Space*/ space, AbstractMesh mesh]);

    external void setAbsolutePosition(Vector3 position, [AbstractMesh mesh]);

    external void scale(num x, num y, num z, [bool scaleChildren]);

    external void setScale(Vector3 scale);

    external Vector3 getScale();

    external void getScaleToRef(Vector3 result);

    external void setYawPitchRoll(num yaw, num pitch, num roll, [num/*enum Space*/ space, AbstractMesh mesh]);

    external void rotate(Vector3 axis, num amount, [num/*enum Space*/ space, AbstractMesh mesh]);

    external void setAxisAngle(Vector3 axis, num angle, [num/*enum Space*/ space, AbstractMesh mesh]);

    external void setRotation(Vector3 rotation, [num/*enum Space*/ space, AbstractMesh mesh]);

    external void setRotationQuaternion(Quaternion quat, [num/*enum Space*/ space, AbstractMesh mesh]);

    external void setRotationMatrix(Matrix rotMat, [num/*enum Space*/ space, AbstractMesh mesh]);

    external get JS$_rotateWithMatrix;

    external set JS$_rotateWithMatrix(v);

    external get JS$_getNegativeRotationToRef;

    external set JS$_getNegativeRotationToRef(v);

    external Vector3 getPosition([num/*enum Space*/ space, AbstractMesh/*AbstractMesh|Null*/ mesh]);

    external void getPositionToRef(dynamic/*enum Space|dynamic*/ space, AbstractMesh/*AbstractMesh|Null*/ mesh, Vector3 result);

    external Vector3 getAbsolutePosition([AbstractMesh/*AbstractMesh|Null*/ mesh]);

    external void getAbsolutePositionToRef(AbstractMesh mesh, Vector3 result);

    external void computeAbsoluteTransforms();

    external Vector3 getDirection(Vector3 localAxis, [AbstractMesh/*AbstractMesh|Null*/ mesh]);

    external void getDirectionToRef(Vector3 localAxis, dynamic/*AbstractMesh|Null|dynamic*/ mesh, Vector3 result);

    external Vector3 getRotation([num/*enum Space*/ space, AbstractMesh/*AbstractMesh|Null*/ mesh]);

    external void getRotationToRef(dynamic/*enum Space|dynamic*/ space, dynamic/*AbstractMesh|Null|dynamic*/ mesh, Vector3 result);

    external Quaternion getRotationQuaternion([num/*enum Space*/ space, AbstractMesh/*AbstractMesh|Null*/ mesh]);

    external void getRotationQuaternionToRef(dynamic/*enum Space|dynamic*/ space, dynamic/*AbstractMesh|Null|dynamic*/ mesh, Quaternion result);

    external Matrix getRotationMatrix(dynamic/*enum Space|dynamic*/ space, AbstractMesh mesh);

    external void getRotationMatrixToRef(dynamic/*enum Space|dynamic*/ space, AbstractMesh mesh, Matrix result);

    external Vector3 getAbsolutePositionFromLocal(Vector3 position, [AbstractMesh/*AbstractMesh|Null*/ mesh]);

    external void getAbsolutePositionFromLocalToRef(Vector3 position, dynamic/*AbstractMesh|Null|dynamic*/ mesh, Vector3 result);

    external Vector3 getLocalPositionFromAbsolute(Vector3 position, [AbstractMesh/*AbstractMesh|Null*/ mesh]);

    external void getLocalPositionFromAbsoluteToRef(Vector3 position, dynamic/*AbstractMesh|Null|dynamic*/ mesh, Vector3 result);
}

@JS("BABYLON.BoneIKController")
class BoneIKController {
    // @Ignore
    BoneIKController .fakeConstructor$();

    external static get JS$_tmpVecs;

    external static set JS$_tmpVecs(v);

    external static get JS$_tmpQuat;

    external static set JS$_tmpQuat(v);

    external static get JS$_tmpMats;

    external static set JS$_tmpMats(v);

    external AbstractMesh get targetMesh;

    external set targetMesh(AbstractMesh v);

    external AbstractMesh get poleTargetMesh;

    external set poleTargetMesh(AbstractMesh v);

    external Bone/*Bone|Null*/ get poleTargetBone;

    external set poleTargetBone(Bone/*Bone|Null*/ v);

    external Vector3 get targetPosition;

    external set targetPosition(Vector3 v);

    external Vector3 get poleTargetPosition;

    external set poleTargetPosition(Vector3 v);

    external Vector3 get poleTargetLocalOffset;

    external set poleTargetLocalOffset(Vector3 v);

    external num get poleAngle;

    external set poleAngle(num v);

    external AbstractMesh get mesh;

    external set mesh(AbstractMesh v);

    external num get slerpAmount;

    external set slerpAmount(num v);

    external get JS$_bone1Quat;

    external set JS$_bone1Quat(v);

    external get JS$_bone1Mat;

    external set JS$_bone1Mat(v);

    external get JS$_bone2Ang;

    external set JS$_bone2Ang(v);

    external get JS$_bone1;

    external set JS$_bone1(v);

    external get JS$_bone2;

    external set JS$_bone2(v);

    external get JS$_bone1Length;

    external set JS$_bone1Length(v);

    external get JS$_bone2Length;

    external set JS$_bone2Length(v);

    external get JS$_maxAngle;

    external set JS$_maxAngle(v);

    external get JS$_maxReach;

    external set JS$_maxReach(v);

    external get JS$_rightHandedSystem;

    external set JS$_rightHandedSystem(v);

    external get JS$_bendAxis;

    external set JS$_bendAxis(v);

    external get JS$_slerping;

    external set JS$_slerping(v);

    external get JS$_adjustRoll;

    external set JS$_adjustRoll(v);

    external num get maxAngle;

    external set maxAngle(num v);

    external factory BoneIKController(AbstractMesh mesh, Bone bone, [dynamic/*{
            targetMesh?: AbstractMesh;
            poleTargetMesh?: AbstractMesh;
            poleTargetBone?: Bone;
            poleTargetLocalOffset?: Vector3;
            poleAngle?: number;
            bendAxis?: Vector3;
            maxAngle?: number;
            slerpAmount?: number;
        }*/
    options]);

    external get JS$_setMaxAngle;

    external set JS$_setMaxAngle(v);

    external void update();
}

@JS("BABYLON.BoneLookController")
class BoneLookController {
    // @Ignore
    BoneLookController .fakeConstructor$();

    external static get JS$_tmpVecs;

    external static set JS$_tmpVecs(v);

    external static get JS$_tmpQuat;

    external static set JS$_tmpQuat(v);

    external static get JS$_tmpMats;

    external static set JS$_tmpMats(v);

    external Vector3 get target;

    external set target(Vector3 v);

    external AbstractMesh get mesh;

    external set mesh(AbstractMesh v);

    external Bone get bone;

    external set bone(Bone v);

    external Vector3 get upAxis;

    external set upAxis(Vector3 v);

    external num/*enum Space*/ get upAxisSpace;

    external set upAxisSpace(num/*enum Space*/ v);

    external num get adjustYaw;

    external set adjustYaw(num v);

    external num get adjustPitch;

    external set adjustPitch(num v);

    external num get adjustRoll;

    external set adjustRoll(num v);

    external num get slerpAmount;

    external set slerpAmount(num v);

    external get JS$_minYaw;

    external set JS$_minYaw(v);

    external get JS$_maxYaw;

    external set JS$_maxYaw(v);

    external get JS$_minPitch;

    external set JS$_minPitch(v);

    external get JS$_maxPitch;

    external set JS$_maxPitch(v);

    external get JS$_minYawSin;

    external set JS$_minYawSin(v);

    external get JS$_minYawCos;

    external set JS$_minYawCos(v);

    external get JS$_maxYawSin;

    external set JS$_maxYawSin(v);

    external get JS$_maxYawCos;

    external set JS$_maxYawCos(v);

    external get JS$_midYawConstraint;

    external set JS$_midYawConstraint(v);

    external get JS$_minPitchTan;

    external set JS$_minPitchTan(v);

    external get JS$_maxPitchTan;

    external set JS$_maxPitchTan(v);

    external get JS$_boneQuat;

    external set JS$_boneQuat(v);

    external get JS$_slerping;

    external set JS$_slerping(v);

    external get JS$_transformYawPitch;

    external set JS$_transformYawPitch(v);

    external get JS$_transformYawPitchInv;

    external set JS$_transformYawPitchInv(v);

    external get JS$_firstFrameSkipped;

    external set JS$_firstFrameSkipped(v);

    external get JS$_yawRange;

    external set JS$_yawRange(v);

    external get JS$_fowardAxis;

    external set JS$_fowardAxis(v);

    external num get minYaw;

    external set minYaw(num v);

    external num get maxYaw;

    external set maxYaw(num v);

    external num get minPitch;

    external set minPitch(num v);

    external num get maxPitch;

    external set maxPitch(num v);

    external factory BoneLookController(AbstractMesh mesh, Bone bone, Vector3 target, [dynamic/*{
            maxYaw?: number;
            minYaw?: number;
            maxPitch?: number;
            minPitch?: number;
            slerpAmount?: number;
            upAxis?: Vector3;
            upAxisSpace?: Space;
            yawAxis?: Vector3;
            pitchAxis?: Vector3;
            adjustYaw?: number;
            adjustPitch?: number;
            adjustRoll?: number;
        }*/
    options]);

    external void update();

    external get JS$_getAngleDiff;

    external set JS$_getAngleDiff(v);

    external get JS$_getAngleBetween;

    external set JS$_getAngleBetween(v);

    external get JS$_isAngleBetween;

    external set JS$_isAngleBetween(v);
}

@JS("BABYLON.Skeleton")
class Skeleton implements IAnimatable {
    // @Ignore
    Skeleton .fakeConstructor$();

    external String get name;

    external set name(String v);

    external String get id;

    external set id(String v);

    external List<Bone> get bones;

    external set bones(List<Bone> v);

    external Vector3 get dimensionsAtRest;

    external set dimensionsAtRest(Vector3 v);

    external bool get needInitialSkinMatrix;

    external set needInitialSkinMatrix(bool v);

    external List<Animation> get animations;

    external set animations(List<Animation> v);

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_isDirty;

    external set JS$_isDirty(v);

    external get JS$_transformMatrices;

    external set JS$_transformMatrices(v);

    external get JS$_meshesWithPoseMatrix;

    external set JS$_meshesWithPoseMatrix(v);

    external get JS$_animatables;

    external set JS$_animatables(v);

    external get JS$_identity;

    external set JS$_identity(v);

    external get JS$_synchronizedWithMesh;

    external set JS$_synchronizedWithMesh(v);

    external get JS$_ranges;

    external set JS$_ranges(v);

    external get JS$_lastAbsoluteTransformsUpdateId;

    external set JS$_lastAbsoluteTransformsUpdateId(v);

    external bool get doNotSerialize;

    external set doNotSerialize(bool v);

    external get JS$_animationPropertiesOverride;

    external set JS$_animationPropertiesOverride(v);

    external AnimationPropertiesOverride/*AnimationPropertiesOverride|Null*/ get animationPropertiesOverride;

    external set animationPropertiesOverride(AnimationPropertiesOverride/*AnimationPropertiesOverride|Null*/ v);

    external Observable<Skeleton> get onBeforeComputeObservable;

    external set onBeforeComputeObservable(Observable<Skeleton> v);

    external factory Skeleton(String name, String id, Scene scene);

    external Float32List getTransformMatrices(AbstractMesh mesh);

    external Scene getScene();

    external String toString([bool fullDetails]);

    external num getBoneIndexByName(String name);

    external void createAnimationRange(String name, num from, num to);

    external void deleteAnimationRange(String name, [bool deleteFrames]);

    external AnimationRange/*AnimationRange|Null*/ getAnimationRange(String name);

    external List<AnimationRange /*AnimationRange|Null*/> getAnimationRanges();

    external bool copyAnimationRange(Skeleton source, String name, [bool rescaleAsRequired]);

    external void returnToRest();

    external get JS$_getHighestAnimationFrame;

    external set JS$_getHighestAnimationFrame(v);

    external Animatable/*Animatable|Null*/ beginAnimation(String name, [bool loop, num speedRatio, void onAnimationEnd()]);

    external void JS$_markAsDirty();

    external void JS$_registerMeshWithPoseMatrix(AbstractMesh mesh);

    external void JS$_unregisterMeshWithPoseMatrix(AbstractMesh mesh);

    external void JS$_computeTransformMatrices(Float32List targetMatrix, Matrix/*Matrix|Null*/ initialSkinMatrix);

    external void prepare();

    external List<IAnimatable> getAnimatables();

    external Skeleton clone(String name, String id);

    external void enableBlending([num blendingSpeed]);

    external void dispose();

    external dynamic serialize();

    external static Skeleton Parse(dynamic parsedSkeleton, Scene scene);

    external void computeAbsoluteTransforms([bool forceUpdate]);

    external Matrix/*Matrix|Null*/ getPoseMatrix();

    external void sortBones();

    external get JS$_sortBones;

    external set JS$_sortBones(v);
}

@JS("BABYLON.Collider")
class Collider {
    // @Ignore
    Collider .fakeConstructor$();

    external bool get collisionFound;

    external set collisionFound(bool v);

    external Vector3 get intersectionPoint;

    external set intersectionPoint(Vector3 v);

    external AbstractMesh/*AbstractMesh|Null*/ get collidedMesh;

    external set collidedMesh(AbstractMesh/*AbstractMesh|Null*/ v);

    external get JS$_collisionPoint;

    external set JS$_collisionPoint(v);

    external get JS$_planeIntersectionPoint;

    external set JS$_planeIntersectionPoint(v);

    external get JS$_tempVector;

    external set JS$_tempVector(v);

    external get JS$_tempVector2;

    external set JS$_tempVector2(v);

    external get JS$_tempVector3;

    external set JS$_tempVector3(v);

    external get JS$_tempVector4;

    external set JS$_tempVector4(v);

    external get JS$_edge;

    external set JS$_edge(v);

    external get JS$_baseToVertex;

    external set JS$_baseToVertex(v);

    external get JS$_destinationPoint;

    external set JS$_destinationPoint(v);

    external get JS$_slidePlaneNormal;

    external set JS$_slidePlaneNormal(v);

    external get JS$_displacementVector;

    external set JS$_displacementVector(v);

    external Vector3 get JS$_radius;

    external set JS$_radius(Vector3 v);

    external num get JS$_retry;

    external set JS$_retry(num v);

    external get JS$_velocity;

    external set JS$_velocity(v);

    external get JS$_basePoint;

    external set JS$_basePoint(v);

    external get JS$_epsilon;

    external set JS$_epsilon(v);

    external num get JS$_velocityWorldLength;

    external set JS$_velocityWorldLength(num v);

    external Vector3 get JS$_basePointWorld;

    external set JS$_basePointWorld(Vector3 v);

    external get JS$_velocityWorld;

    external set JS$_velocityWorld(v);

    external get JS$_normalizedVelocity;

    external set JS$_normalizedVelocity(v);

    external Vector3 get JS$_initialVelocity;

    external set JS$_initialVelocity(Vector3 v);

    external Vector3 get JS$_initialPosition;

    external set JS$_initialPosition(Vector3 v);

    external get JS$_nearestDistance;

    external set JS$_nearestDistance(v);

    external get JS$_collisionMask;

    external set JS$_collisionMask(v);

    external num get collisionMask;

    external set collisionMask(num v);

    external Vector3 get slidePlaneNormal;

    external set slidePlaneNormal(Vector3 v);

    external void JS$_initialize(Vector3 source, Vector3 dir, num e);

    external bool JS$_checkPointInTriangle(Vector3 point, Vector3 pa, Vector3 pb, Vector3 pc, Vector3 n);

    external bool JS$_canDoCollision(Vector3 sphereCenter, num sphereRadius, Vector3 vecMin, Vector3 vecMax);

    external void JS$_testTriangle(num faceIndex, List<Plane> trianglePlaneArray, Vector3 p1, Vector3 p2, Vector3 p3, bool hasMaterial);

    external void JS$_collide(List<Plane> trianglePlaneArray, List<Vector3> pts, dynamic/*List<num>|Int32List|Uint32List|Uint16List*/ indices, num indexStart, num indexEnd, num decal, bool hasMaterial);

    external void JS$_getResponse(Vector3 pos, Vector3 vel);
}

@JS("BABYLON.CollisionWorker")
external String get CollisionWorker;

@JS("BABYLON.CollisionWorker")
external set CollisionWorker(String v);

@anonymous
@JS()
abstract class ICollisionCoordinator {
    external void getNewPosition(Vector3 position, Vector3 displacement, Collider collider, num maximumRetry, AbstractMesh/*AbstractMesh|Null*/ excludedMesh, void onNewPosition(num collisionIndex, Vector3 newPosition, AbstractMesh/*AbstractMesh|Null*/ collidedMesh), num collisionIndex);

    external void init(Scene scene);

    external void destroy();

    external void onMeshAdded(AbstractMesh mesh);

    external void onMeshUpdated(AbstractMesh mesh);

    external void onMeshRemoved(AbstractMesh mesh);

    external void onGeometryAdded(Geometry geometry);

    external void onGeometryUpdated(Geometry geometry);

    external void onGeometryDeleted(Geometry geometry);
}

@anonymous
@JS()
abstract class SerializedMesh {
    external String get id;

    external set id(String v);

    external String get name;

    external set name(String v);

    external num get uniqueId;

    external set uniqueId(num v);

    external String/*String|Null*/ get geometryId;

    external set geometryId(String/*String|Null*/ v);

    external List<num> get sphereCenter;

    external set sphereCenter(List<num> v);

    external num get sphereRadius;

    external set sphereRadius(num v);

    external List<num> get boxMinimum;

    external set boxMinimum(List<num> v);

    external List<num> get boxMaximum;

    external set boxMaximum(List<num> v);

    external dynamic get worldMatrixFromCache;

    external set worldMatrixFromCache(dynamic v);

    external List<SerializedSubMesh> get subMeshes;

    external set subMeshes(List<SerializedSubMesh> v);

    external bool get checkCollisions;

    external set checkCollisions(bool v);

    external factory SerializedMesh({ String id, String name, num uniqueId, String/*String|Null*/ geometryId, List<num> sphereCenter, num sphereRadius, List<num> boxMinimum, List<num> boxMaximum, dynamic worldMatrixFromCache, List<SerializedSubMesh> subMeshes, bool checkCollisions});
}

@anonymous
@JS()
abstract class SerializedSubMesh {
    external num get position;

    external set position(num v);

    external num get verticesStart;

    external set verticesStart(num v);

    external num get verticesCount;

    external set verticesCount(num v);

    external num get indexStart;

    external set indexStart(num v);

    external num get indexCount;

    external set indexCount(num v);

    external bool get hasMaterial;

    external set hasMaterial(bool v);

    external List<num> get sphereCenter;

    external set sphereCenter(List<num> v);

    external num get sphereRadius;

    external set sphereRadius(num v);

    external List<num> get boxMinimum;

    external set boxMinimum(List<num> v);

    external List<num> get boxMaximum;

    external set boxMaximum(List<num> v);

    external factory SerializedSubMesh({ num position, num verticesStart, num verticesCount, num indexStart, num indexCount, bool hasMaterial, List<num> sphereCenter, num sphereRadius, List<num> boxMinimum, List<num> boxMaximum});
}

@anonymous
@JS()
abstract class SerializedGeometry {
    external String get id;

    external set id(String v);

    external Float32List get positions;

    external set positions(Float32List v);

    external Uint32List get indices;

    external set indices(Uint32List v);

    external Float32List get normals;

    external set normals(Float32List v);

    external factory SerializedGeometry({ String id, Float32List positions, Uint32List indices, Float32List normals});
}

@anonymous
@JS()
abstract class BabylonMessage {
    external num/*enum WorkerTaskType*/ get taskType;

    external set taskType(num/*enum WorkerTaskType*/ v);

    external dynamic/*InitPayload|CollidePayload|UpdatePayload*/ get payload;

    external set payload(dynamic/*InitPayload|CollidePayload|UpdatePayload*/ v);

    external factory BabylonMessage({ num/*enum WorkerTaskType*/ taskType, dynamic/*InitPayload|CollidePayload|UpdatePayload*/ payload});
}

@anonymous
@JS()
abstract class SerializedColliderToWorker {
    external List<num> get position;

    external set position(List<num> v);

    external List<num> get velocity;

    external set velocity(List<num> v);

    external List<num> get radius;

    external set radius(List<num> v);

    external factory SerializedColliderToWorker({ List<num> position, List<num> velocity, List<num> radius});
}

@JS("BABYLON.WorkerTaskType")
class WorkerTaskType {
    external static num get INIT;

    external static num get UPDATE;

    external static num get COLLIDE;
}

@anonymous
@JS()
abstract class WorkerReply {
    external num/*enum WorkerReplyType*/ get error;

    external set error(num/*enum WorkerReplyType*/ v);

    external num/*enum WorkerTaskType*/ get taskType;

    external set taskType(num/*enum WorkerTaskType*/ v);

    external dynamic get payload;

    external set payload(dynamic v);

    external factory WorkerReply({ num/*enum WorkerReplyType*/ error, num/*enum WorkerTaskType*/ taskType, dynamic payload});
}

@anonymous
@JS()
abstract class CollisionReplyPayload {
    external List<num> get newPosition;

    external set newPosition(List<num> v);

    external num get collisionId;

    external set collisionId(num v);

    external num get collidedMeshUniqueId;

    external set collidedMeshUniqueId(num v);

    external factory CollisionReplyPayload({ List<num> newPosition, num collisionId, num collidedMeshUniqueId});
}

@anonymous
@JS()
abstract class InitPayload {}

@anonymous
@JS()
abstract class CollidePayload {
    external num get collisionId;

    external set collisionId(num v);

    external SerializedColliderToWorker get collider;

    external set collider(SerializedColliderToWorker v);

    external num get maximumRetry;

    external set maximumRetry(num v);

    external num/*num|Null*/ get excludedMeshUniqueId;

    external set excludedMeshUniqueId(num/*num|Null*/ v);

    external factory CollidePayload({ num collisionId, SerializedColliderToWorker collider, num maximumRetry, num/*num|Null*/ excludedMeshUniqueId});
}

@anonymous
@JS()
abstract class UpdatePayload {
    external dynamic/*JSMap of <num,SerializedMesh>*/ get updatedMeshes;

    external set updatedMeshes(dynamic/*JSMap of <num,SerializedMesh>*/ v);

    external dynamic/*JSMap of <String,SerializedGeometry>*/ get updatedGeometries;

    external set updatedGeometries(dynamic/*JSMap of <String,SerializedGeometry>*/ v);

    external List<num> get removedMeshes;

    external set removedMeshes(List<num> v);

    external List<String> get removedGeometries;

    external set removedGeometries(List<String> v);

    external factory UpdatePayload({ dynamic/*JSMap of <num,SerializedMesh>*/ updatedMeshes, dynamic/*JSMap of <String,SerializedGeometry>*/ updatedGeometries, List<num> removedMeshes, List<String> removedGeometries});
}

@JS("BABYLON.WorkerReplyType")
class WorkerReplyType {
    external static num get SUCCESS;

    external static num get UNKNOWN_ERROR;
}

@JS("BABYLON.CollisionCoordinatorWorker")
class CollisionCoordinatorWorker implements ICollisionCoordinator {
    // @Ignore
    CollisionCoordinatorWorker .fakeConstructor$();

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_scaledPosition;

    external set JS$_scaledPosition(v);

    external get JS$_scaledVelocity;

    external set JS$_scaledVelocity(v);

    external get JS$_collisionsCallbackArray;

    external set JS$_collisionsCallbackArray(v);

    external get JS$_init;

    external set JS$_init(v);

    external get JS$_runningUpdated;

    external set JS$_runningUpdated(v);

    external get JS$_worker;

    external set JS$_worker(v);

    external get JS$_addUpdateMeshesList;

    external set JS$_addUpdateMeshesList(v);

    external get JS$_addUpdateGeometriesList;

    external set JS$_addUpdateGeometriesList(v);

    external get JS$_toRemoveMeshesArray;

    external set JS$_toRemoveMeshesArray(v);

    external get JS$_toRemoveGeometryArray;

    external set JS$_toRemoveGeometryArray(v);

    external factory CollisionCoordinatorWorker();

    external static Func1<AbstractMesh, SerializedMesh> get SerializeMesh;

    external static set SerializeMesh(Func1<AbstractMesh, SerializedMesh> v);

    external static Func1<Geometry, SerializedGeometry> get SerializeGeometry;

    external static set SerializeGeometry(Func1<Geometry, SerializedGeometry> v);

    external void getNewPosition(Vector3 position, Vector3 displacement, Collider collider, num maximumRetry, AbstractMesh excludedMesh, void onNewPosition(num collisionIndex, Vector3 newPosition, AbstractMesh/*AbstractMesh|Null*/ collidedMesh), num collisionIndex);

    external void init(Scene scene);

    external void destroy();

    external void onMeshAdded(AbstractMesh mesh);

    external VoidFunc1<TransformNode> get onMeshUpdated;

    external set onMeshUpdated(VoidFunc1<TransformNode> v);

    external void onMeshRemoved(AbstractMesh mesh);

    external void onGeometryAdded(Geometry geometry);

    external VoidFunc1<Geometry> get onGeometryUpdated;

    external set onGeometryUpdated(VoidFunc1<Geometry> v);

    external void onGeometryDeleted(Geometry geometry);

    external get JS$_afterRender;

    external set JS$_afterRender(v);

    external get JS$_onMessageFromWorker;

    external set JS$_onMessageFromWorker(v);
}

@JS("BABYLON.CollisionCoordinatorLegacy")
class CollisionCoordinatorLegacy implements ICollisionCoordinator {
    // @Ignore
    CollisionCoordinatorLegacy .fakeConstructor$();

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_scaledPosition;

    external set JS$_scaledPosition(v);

    external get JS$_scaledVelocity;

    external set JS$_scaledVelocity(v);

    external get JS$_finalPosition;

    external set JS$_finalPosition(v);

    external void getNewPosition(Vector3 position, Vector3 displacement, Collider collider, num maximumRetry, AbstractMesh excludedMesh, void onNewPosition(num collisionIndex, Vector3 newPosition, AbstractMesh/*AbstractMesh|Null*/ collidedMesh), num collisionIndex);

    external void init(Scene scene);

    external void destroy();

    external void onMeshAdded(AbstractMesh mesh);

    external void onMeshUpdated(AbstractMesh mesh);

    external void onMeshRemoved(AbstractMesh mesh);

    external void onGeometryAdded(Geometry geometry);

    external void onGeometryUpdated(Geometry geometry);

    external void onGeometryDeleted(Geometry geometry);

    external get JS$_collideWithWorld;

    external set JS$_collideWithWorld(v);
}

@JS("BABYLON.WorkerIncluded")
external bool get WorkerIncluded;

@JS("BABYLON.WorkerIncluded")
external set WorkerIncluded(bool v);

@JS("BABYLON.CollisionCache")
class CollisionCache {
    // @Ignore
    CollisionCache .fakeConstructor$();

    external get JS$_meshes;

    external set JS$_meshes(v);

    external get JS$_geometries;

    external set JS$_geometries(v);

    external dynamic/*JSMap of <num,SerializedMesh>*/ getMeshes();

    external dynamic/*JSMap of <num,SerializedGeometry>*/ getGeometries();

    external SerializedMesh getMesh(dynamic id);

    external void addMesh(SerializedMesh mesh);

    external void removeMesh(num uniqueId);

    external SerializedGeometry getGeometry(String id);

    external void addGeometry(SerializedGeometry geometry);

    external void removeGeometry(String id);
}

@JS("BABYLON.CollideWorker")
class CollideWorker {
    // @Ignore
    CollideWorker .fakeConstructor$();

    external Collider get collider;

    external set collider(Collider v);

    external get JS$_collisionCache;

    external set JS$_collisionCache(v);

    external get finalPosition;

    external set finalPosition(v);

    external get collisionsScalingMatrix;

    external set collisionsScalingMatrix(v);

    external get collisionTranformationMatrix;

    external set collisionTranformationMatrix(v);

    external factory CollideWorker(Collider collider, CollisionCache JS$_collisionCache, Vector3 finalPosition);

    external void collideWithWorld(Vector3 position, Vector3 velocity, num maximumRetry, num/*num|Null*/ excludedMeshUniqueId);

    external get checkCollision;

    external set checkCollision(v);

    external get processCollisionsForSubMeshes;

    external set processCollisionsForSubMeshes(v);

    external get collideForSubMesh;

    external set collideForSubMesh(v);

    external get checkSubmeshCollision;

    external set checkSubmeshCollision(v);
}

@anonymous
@JS()
abstract class ICollisionDetector {
    external void onInit(InitPayload payload);

    external void onUpdate(UpdatePayload payload);

    external void onCollision(CollidePayload payload);
}

@JS("BABYLON.CollisionDetectorTransferable")
class CollisionDetectorTransferable implements ICollisionDetector {
    // @Ignore
    CollisionDetectorTransferable .fakeConstructor$();

    external get JS$_collisionCache;

    external set JS$_collisionCache(v);

    external void onInit(InitPayload payload);

    external void onUpdate(UpdatePayload payload);

    external void onCollision(CollidePayload payload);
}

@JS("BABYLON.IntersectionInfo")
class IntersectionInfo {
    // @Ignore
    IntersectionInfo .fakeConstructor$();

    external num/*num|Null*/ get bu;

    external set bu(num/*num|Null*/ v);

    external num/*num|Null*/ get bv;

    external set bv(num/*num|Null*/ v);

    external num get distance;

    external set distance(num v);

    external num get faceId;

    external set faceId(num v);

    external num get subMeshId;

    external set subMeshId(num v);

    external factory IntersectionInfo(num/*num|Null*/ bu, num/*num|Null*/ bv, num distance);
}

@JS("BABYLON.PickingInfo")
class PickingInfo {
    // @Ignore
    PickingInfo .fakeConstructor$();

    external bool get hit;

    external set hit(bool v);

    external num get distance;

    external set distance(num v);

    external Vector3/*Vector3|Null*/ get pickedPoint;

    external set pickedPoint(Vector3/*Vector3|Null*/ v);

    external AbstractMesh/*AbstractMesh|Null*/ get pickedMesh;

    external set pickedMesh(AbstractMesh/*AbstractMesh|Null*/ v);

    external num get bu;

    external set bu(num v);

    external num get bv;

    external set bv(num v);

    external num get faceId;

    external set faceId(num v);

    external num get subMeshId;

    external set subMeshId(num v);

    external Sprite/*Sprite|Null*/ get pickedSprite;

    external set pickedSprite(Sprite/*Sprite|Null*/ v);

    external AbstractMesh/*AbstractMesh|Null*/ get originMesh;

    external set originMesh(AbstractMesh/*AbstractMesh|Null*/ v);

    external Ray/*Ray|Null*/ get ray;

    external set ray(Ray/*Ray|Null*/ v);

    external Vector3/*Vector3|Null*/ getNormal([bool useWorldCoordinates, bool useVerticesNormals]);

    external Vector2/*Vector2|Null*/ getTextureCoordinates();
}

@JS("BABYLON.ArcRotateCamera")
class ArcRotateCamera extends TargetCamera {
    // @Ignore
    ArcRotateCamera .fakeConstructor$() : super.fakeConstructor$();
    external num get alpha;

    external set alpha(num v);

    external num get beta;

    external set beta(num v);

    external num get radius;

    external set radius(num v);

    external Vector3 get JS$_target;

    external set JS$_target(Vector3 v);

    external AbstractMesh/*AbstractMesh|Null*/ get JS$_targetHost;

    external set JS$_targetHost(AbstractMesh/*AbstractMesh|Null*/ v);

    external Vector3 get target;

    external set target(Vector3 v);

    external num get inertialAlphaOffset;

    external set inertialAlphaOffset(num v);

    external num get inertialBetaOffset;

    external set inertialBetaOffset(num v);

    external num get inertialRadiusOffset;

    external set inertialRadiusOffset(num v);

    external num/*num|Null*/ get lowerAlphaLimit;

    external set lowerAlphaLimit(num/*num|Null*/ v);

    external num/*num|Null*/ get upperAlphaLimit;

    external set upperAlphaLimit(num/*num|Null*/ v);

    external num get lowerBetaLimit;

    external set lowerBetaLimit(num v);

    external num get upperBetaLimit;

    external set upperBetaLimit(num v);

    external num/*num|Null*/ get lowerRadiusLimit;

    external set lowerRadiusLimit(num/*num|Null*/ v);

    external num/*num|Null*/ get upperRadiusLimit;

    external set upperRadiusLimit(num/*num|Null*/ v);

    external num get inertialPanningX;

    external set inertialPanningX(num v);

    external num get inertialPanningY;

    external set inertialPanningY(num v);

    external num get pinchToPanMaxDistance;

    external set pinchToPanMaxDistance(num v);

    external num/*num|Null*/ get panningDistanceLimit;

    external set panningDistanceLimit(num/*num|Null*/ v);

    external Vector3 get panningOriginTarget;

    external set panningOriginTarget(Vector3 v);

    external num get panningInertia;

    external set panningInertia(num v);

    external num get angularSensibilityX;

    external set angularSensibilityX(num v);

    external num get angularSensibilityY;

    external set angularSensibilityY(num v);

    external num get pinchPrecision;

    external set pinchPrecision(num v);

    external num get pinchDeltaPercentage;

    external set pinchDeltaPercentage(num v);

    external num get panningSensibility;

    external set panningSensibility(num v);

    external List<num> get keysUp;

    external set keysUp(List<num> v);

    external List<num> get keysDown;

    external set keysDown(List<num> v);

    external List<num> get keysLeft;

    external set keysLeft(List<num> v);

    external List<num> get keysRight;

    external set keysRight(List<num> v);

    external num get wheelPrecision;

    external set wheelPrecision(num v);

    external num get wheelDeltaPercentage;

    external set wheelDeltaPercentage(num v);

    external num get zoomOnFactor;

    external set zoomOnFactor(num v);

    external Vector2 get targetScreenOffset;

    external set targetScreenOffset(Vector2 v);

    external bool get allowUpsideDown;

    external set allowUpsideDown(bool v);

    external bool get useInputToRestoreState;

    external set useInputToRestoreState(bool v);

    external Matrix get JS$_viewMatrix;

    external set JS$_viewMatrix(Matrix v);

    external bool get JS$_useCtrlForPanning;

    external set JS$_useCtrlForPanning(bool v);

    external num get JS$_panningMouseButton;

    external set JS$_panningMouseButton(num v);

    external ArcRotateCameraInputsManager get inputs;

    external set inputs(ArcRotateCameraInputsManager v);

    external VoidFunc0 get JS$_reset;

    external set JS$_reset(VoidFunc0 v);

    external Vector3 get panningAxis;

    external set panningAxis(Vector3 v);

    external Vector3 get JS$_localDirection;

    external set JS$_localDirection(Vector3 v);

    external Vector3 get JS$_transformedDirection;

    external set JS$_transformedDirection(Vector3 v);

    external get JS$_bouncingBehavior;

    external set JS$_bouncingBehavior(v);

    external BouncingBehavior/*BouncingBehavior|Null*/ get bouncingBehavior;

    external set bouncingBehavior(BouncingBehavior/*BouncingBehavior|Null*/ v);

    external bool get useBouncingBehavior;

    external set useBouncingBehavior(bool v);

    external get JS$_framingBehavior;

    external set JS$_framingBehavior(v);

    external FramingBehavior/*FramingBehavior|Null*/ get framingBehavior;

    external set framingBehavior(FramingBehavior/*FramingBehavior|Null*/ v);

    external bool get useFramingBehavior;

    external set useFramingBehavior(bool v);

    external get JS$_autoRotationBehavior;

    external set JS$_autoRotationBehavior(v);

    external AutoRotationBehavior/*AutoRotationBehavior|Null*/ get autoRotationBehavior;

    external set autoRotationBehavior(AutoRotationBehavior/*AutoRotationBehavior|Null*/ v);

    external bool get useAutoRotationBehavior;

    external set useAutoRotationBehavior(bool v);

    external Observable<AbstractMesh /*AbstractMesh|Null*/> get onMeshTargetChangedObservable;

    external set onMeshTargetChangedObservable(Observable<AbstractMesh /*AbstractMesh|Null*/> v);

    external VoidFunc1<AbstractMesh> get onCollide;

    external set onCollide(VoidFunc1<AbstractMesh> v);

    external bool get checkCollisions;

    external set checkCollisions(bool v);

    external Vector3 get collisionRadius;

    external set collisionRadius(Vector3 v);

    external Collider get JS$_collider;

    external set JS$_collider(Collider v);

    external Vector3 get JS$_previousPosition;

    external set JS$_previousPosition(Vector3 v);

    external Vector3 get JS$_collisionVelocity;

    external set JS$_collisionVelocity(Vector3 v);

    external Vector3 get JS$_newPosition;

    external set JS$_newPosition(Vector3 v);

    external num get JS$_previousAlpha;

    external set JS$_previousAlpha(num v);

    external num get JS$_previousBeta;

    external set JS$_previousBeta(num v);

    external num get JS$_previousRadius;

    external set JS$_previousRadius(num v);

    external bool get JS$_collisionTriggered;

    external set JS$_collisionTriggered(bool v);

    external Vector3/*Vector3|Null*/ get JS$_targetBoundingCenter;

    external set JS$_targetBoundingCenter(Vector3/*Vector3|Null*/ v);

    external get JS$_computationVector;

    external set JS$_computationVector(v);

    external factory ArcRotateCamera(String name, num alpha, num beta, num radius, Vector3 target, Scene scene, [bool setActiveOnSceneIfNoneActive]);

    external void JS$_initCache();

    external void JS$_updateCache([bool ignoreParentClass]);

    external Vector3 JS$_getTargetPosition();

    external get JS$_storedAlpha;

    external set JS$_storedAlpha(v);

    external get JS$_storedBeta;

    external set JS$_storedBeta(v);

    external get JS$_storedRadius;

    external set JS$_storedRadius(v);

    external get JS$_storedTarget;

    external set JS$_storedTarget(v);

    external Camera storeState();

    external bool JS$_restoreStateValues();

    external bool JS$_isSynchronizedViewMatrix();

    external void attachControl(HtmlElement element, [bool noPreventDefault, bool useCtrlForPanning, num panningMouseButton]);

    external void detachControl(HtmlElement element);

    external void JS$_checkInputs();

    external void JS$_checkLimits();

    external void rebuildAnglesAndRadius();

    external void setPosition(Vector3 position);

    external void setTarget(dynamic/*AbstractMesh|Vector3*/ target, [bool toBoundingCenter, bool allowSamePosition]);

    external Matrix JS$_getViewMatrix();

    external VoidFunc3Opt1<num, Vector3, AbstractMesh /*AbstractMesh|Null*/> get JS$_onCollisionPositionChange;

    external set JS$_onCollisionPositionChange(VoidFunc3Opt1<num, Vector3, AbstractMesh /*AbstractMesh|Null*/> v);

    external void zoomOn([List<AbstractMesh> meshes, bool doNotUpdateMaxZ]);

    external void focusOn(dynamic/*List<AbstractMesh>|{
            min: Vector3;
            max: Vector3;
            distance: number;
        }*/
    meshesOrMinMaxVectorAndDistance, [bool doNotUpdateMaxZ]);

    external Camera createRigCamera(String name, num cameraIndex);

    external void JS$_updateRigCameras();

    external void dispose();

    external String getClassName();
}

@JS("BABYLON.ArcRotateCameraInputsManager")
class ArcRotateCameraInputsManager extends CameraInputsManager<ArcRotateCamera> {
    // @Ignore
    ArcRotateCameraInputsManager .fakeConstructor$() : super.fakeConstructor$();

    external factory ArcRotateCameraInputsManager(ArcRotateCamera camera);

    external ArcRotateCameraInputsManager addMouseWheel();

    external ArcRotateCameraInputsManager addPointers();

    external ArcRotateCameraInputsManager addKeyboard();

    external ArcRotateCameraInputsManager addVRDeviceOrientation();

    external ArcRotateCameraInputsManager addGamepad();
}

@JS("BABYLON.Camera")
class Camera extends Node {
    // @Ignore
    Camera .fakeConstructor$() : super.fakeConstructor$();
    external static num get PERSPECTIVE_CAMERA;

    external static set PERSPECTIVE_CAMERA(num v);

    external static num get ORTHOGRAPHIC_CAMERA;

    external static set ORTHOGRAPHIC_CAMERA(num v);

    external static num get FOVMODE_VERTICAL_FIXED;

    external static set FOVMODE_VERTICAL_FIXED(num v);

    external static num get FOVMODE_HORIZONTAL_FIXED;

    external static set FOVMODE_HORIZONTAL_FIXED(num v);

    external static num get RIG_MODE_NONE;

    external static set RIG_MODE_NONE(num v);

    external static num get RIG_MODE_STEREOSCOPIC_ANAGLYPH;

    external static set RIG_MODE_STEREOSCOPIC_ANAGLYPH(num v);

    external static num get RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL;

    external static set RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL(num v);

    external static num get RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED;

    external static set RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED(num v);

    external static num get RIG_MODE_STEREOSCOPIC_OVERUNDER;

    external static set RIG_MODE_STEREOSCOPIC_OVERUNDER(num v);

    external static num get RIG_MODE_VR;

    external static set RIG_MODE_VR(num v);

    external static num get RIG_MODE_WEBVR;

    external static set RIG_MODE_WEBVR(num v);

    external static bool get ForceAttachControlToAlwaysPreventDefault;

    external static set ForceAttachControlToAlwaysPreventDefault(bool v);

    external static bool get UseAlternateWebVRRendering;

    external static set UseAlternateWebVRRendering(bool v);

    external CameraInputsManager<Camera> get inputs;

    external set inputs(CameraInputsManager<Camera> v);

    external Vector3 get position;

    external set position(Vector3 v);

    external Vector3 get upVector;

    external set upVector(Vector3 v);

    external num/*num|Null*/ get orthoLeft;

    external set orthoLeft(num/*num|Null*/ v);

    external num/*num|Null*/ get orthoRight;

    external set orthoRight(num/*num|Null*/ v);

    external num/*num|Null*/ get orthoBottom;

    external set orthoBottom(num/*num|Null*/ v);

    external num/*num|Null*/ get orthoTop;

    external set orthoTop(num/*num|Null*/ v);

    external num get fov;

    external set fov(num v);

    external num get minZ;

    external set minZ(num v);

    external num get maxZ;

    external set maxZ(num v);

    external num get inertia;

    external set inertia(num v);

    external num get mode;

    external set mode(num v);

    external bool get isIntermediate;

    external set isIntermediate(bool v);

    external Viewport get viewport;

    external set viewport(Viewport v);

    external num get layerMask;

    external set layerMask(num v);

    external num get fovMode;

    external set fovMode(num v);

    external num get cameraRigMode;

    external set cameraRigMode(num v);

    external num get interaxialDistance;

    external set interaxialDistance(num v);

    external bool get isStereoscopicSideBySide;

    external set isStereoscopicSideBySide(bool v);

    external List<RenderTargetTexture> get customRenderTargets;

    external set customRenderTargets(List<RenderTargetTexture> v);

    external Observable<Camera> get onViewMatrixChangedObservable;

    external set onViewMatrixChangedObservable(Observable<Camera> v);

    external Observable<Camera> get onProjectionMatrixChangedObservable;

    external set onProjectionMatrixChangedObservable(Observable<Camera> v);

    external Observable<Camera> get onAfterCheckInputsObservable;

    external set onAfterCheckInputsObservable(Observable<Camera> v);

    external Observable<Camera> get onRestoreStateObservable;

    external set onRestoreStateObservable(Observable<Camera> v);

    external dynamic get JS$_cameraRigParams;

    external set JS$_cameraRigParams(dynamic v);

    external List<Camera> get JS$_rigCameras;

    external set JS$_rigCameras(List<Camera> v);

    external PostProcess/*PostProcess|Null*/ get JS$_rigPostProcess;

    external set JS$_rigPostProcess(PostProcess/*PostProcess|Null*/ v);

    external Matrix get JS$_webvrViewMatrix;

    external set JS$_webvrViewMatrix(Matrix v);

    external bool get JS$_skipRendering;

    external set JS$_skipRendering(bool v);

    external Camera get JS$_alternateCamera;

    external set JS$_alternateCamera(Camera v);

    external Matrix get JS$_projectionMatrix;

    external set JS$_projectionMatrix(Matrix v);

    external List<PostProcess /*PostProcess|Null*/> get JS$_postProcesses;

    external set JS$_postProcesses(List<PostProcess /*PostProcess|Null*/> v);

    external SmartArray<AbstractMesh> get JS$_activeMeshes;

    external set JS$_activeMeshes(SmartArray<AbstractMesh> v);

    external Vector3 get JS$_globalPosition;

    external set JS$_globalPosition(Vector3 v);

    external get JS$_computedViewMatrix;

    external set JS$_computedViewMatrix(v);

    external get JS$_doNotComputeProjectionMatrix;

    external set JS$_doNotComputeProjectionMatrix(v);

    external get JS$_transformMatrix;

    external set JS$_transformMatrix(v);

    external get JS$_frustumPlanes;

    external set JS$_frustumPlanes(v);

    external get JS$_refreshFrustumPlanes;

    external set JS$_refreshFrustumPlanes(v);

    external get JS$_storedFov;

    external set JS$_storedFov(v);

    external get JS$_stateStored;

    external set JS$_stateStored(v);

    external factory Camera(String name, Vector3 position, Scene scene, [bool setActiveOnSceneIfNoneActive]);

    external Camera storeState();

    external bool JS$_restoreStateValues();

    external bool restoreState();

    external String getClassName();

    external String toString([bool fullDetails]);

    external Vector3 get globalPosition;

    external set globalPosition(Vector3 v);

    external SmartArray<AbstractMesh> getActiveMeshes();

    external bool isActiveMesh(Mesh mesh);

    external bool isReady([bool completeCheck]);

    external void JS$_initCache();

    external void JS$_updateCache([bool ignoreParentClass]);

    external bool JS$_isSynchronized();

    external bool JS$_isSynchronizedViewMatrix();

    external bool JS$_isSynchronizedProjectionMatrix();

    external void attachControl(HtmlElement element, [bool noPreventDefault]);

    external void detachControl(HtmlElement element);

    external void update();

    external void JS$_checkInputs();

    external List<Camera> get rigCameras;

    external set rigCameras(List<Camera> v);

    external PostProcess/*PostProcess|Null*/ get rigPostProcess;

    external set rigPostProcess(PostProcess/*PostProcess|Null*/ v);

    external PostProcess/*PostProcess|Null*/ JS$_getFirstPostProcess();

    external get JS$_cascadePostProcessesToRigCams;

    external set JS$_cascadePostProcessesToRigCams(v);

    external num attachPostProcess(PostProcess postProcess, [num/*num|Null*/ insertAt]);

    external void detachPostProcess(PostProcess postProcess);

    external Matrix getWorldMatrix();

    external Matrix JS$_getViewMatrix();

    external Matrix getViewMatrix([bool force]);

    external void freezeProjectionMatrix([Matrix projection]);

    external void unfreezeProjectionMatrix();

    external Matrix getProjectionMatrix([bool force]);

    external Matrix getTransformationMatrix();

    external get JS$_updateFrustumPlanes;

    external set JS$_updateFrustumPlanes(v);

    external bool isInFrustum(ICullable target);

    external bool isCompletelyInFrustum(ICullable target);

    external Ray getForwardRay([num length, Matrix transform, Vector3 origin]);

    external void dispose([bool doNotRecurse, bool disposeMaterialAndTextures]);

    external FreeCamera/*FreeCamera|Null*/ get leftCamera;

    external set leftCamera(FreeCamera/*FreeCamera|Null*/ v);

    external FreeCamera/*FreeCamera|Null*/ get rightCamera;

    external set rightCamera(FreeCamera/*FreeCamera|Null*/ v);

    external Vector3/*Vector3|Null*/ getLeftTarget();

    external Vector3/*Vector3|Null*/ getRightTarget();

    external void setCameraRigMode(num mode, dynamic rigParams);

    external get JS$_getVRProjectionMatrix;

    external set JS$_getVRProjectionMatrix(v);

    external void JS$_updateCameraRotationMatrix();

    external void JS$_updateWebVRCameraRotationMatrix();

    external Matrix JS$_getWebVRProjectionMatrix();

    external Matrix JS$_getWebVRViewMatrix();

    external void setCameraRigParameter(String name, dynamic value);

    external Camera/*Camera|Null*/ createRigCamera(String name, num cameraIndex);

    external void JS$_updateRigCameras();

    external void JS$_setupInputs();

    external dynamic serialize();

    external Camera clone(String name);

    external Vector3 getDirection(Vector3 localAxis);

    external void getDirectionToRef(Vector3 localAxis, Vector3 result);

    external static Func0<Camera> GetConstructorFromName(String type, String name, Scene scene, [num interaxial_distance, bool isStereoscopicSideBySide]);

    external Matrix computeWorldMatrix();

    external static Camera Parse(dynamic parsedCamera, Scene scene);
}

@JS("BABYLON.CameraInputTypes")
external dynamic/*{}*/
get CameraInputTypes;

@JS("BABYLON.CameraInputTypes")
external set CameraInputTypes(dynamic/*{}*/ v);

@anonymous
@JS()
abstract class ICameraInput<TCamera extends Camera> {
    external TCamera/*TCamera|Null*/ get camera;

    external set camera(TCamera/*TCamera|Null*/ v);

    external String getClassName();

    external String getSimpleName();

    external void attachControl(HtmlElement element, [bool noPreventDefault]);

    external void detachControl(HtmlElement/*HtmlElement|Null*/ element);

    external VoidFunc0 get checkInputs;

    external set checkInputs(VoidFunc0 v);
}

@anonymous
@JS()
abstract class CameraInputsMap<TCamera extends Camera> {
    /*/* Index signature is not yet supported by JavaScript interop. */*/
    /*/* Index signature is not yet supported by JavaScript interop. */*/
    /* Index signature is not yet supported by JavaScript interop. */
}

@JS("BABYLON.CameraInputsManager")
class CameraInputsManager<TCamera extends Camera> {
    // @Ignore
    CameraInputsManager .fakeConstructor$();

    external CameraInputsMap<TCamera> get attached;

    external set attached(CameraInputsMap<TCamera> v);

    external HtmlElement/*HtmlElement|Null*/ get attachedElement;

    external set attachedElement(HtmlElement/*HtmlElement|Null*/ v);

    external bool get noPreventDefault;

    external set noPreventDefault(bool v);

    external TCamera get camera;

    external set camera(TCamera v);

    external VoidFunc0 get checkInputs;

    external set checkInputs(VoidFunc0 v);

    external factory CameraInputsManager(TCamera camera);

    external void add(ICameraInput<TCamera> input);

    external void remove(ICameraInput<TCamera> inputToRemove);

    external void removeByType(String inputType);

    external get JS$_addCheckInputs;

    external set JS$_addCheckInputs(v);

    external void attachInput(ICameraInput<TCamera> input);

    external void attachElement(HtmlElement element, [bool noPreventDefault]);

    external void detachElement(HtmlElement element, [bool disconnect]);

    external void rebuildInputCheck();

    external void clear();

    external void serialize(dynamic serializedCamera);

    external void parse(dynamic parsedCamera);
}

@JS("BABYLON.DeviceOrientationCamera")
class DeviceOrientationCamera extends FreeCamera {
    // @Ignore
    DeviceOrientationCamera .fakeConstructor$() : super.fakeConstructor$();
    external get JS$_initialQuaternion;

    external set JS$_initialQuaternion(v);

    external get JS$_quaternionCache;

    external set JS$_quaternionCache(v);

    external factory DeviceOrientationCamera(String name, Vector3 position, Scene scene);

    external String getClassName();

    external void JS$_checkInputs();

    external void resetToCurrentRotation([Axis axis]);
}

@JS("BABYLON.FollowCamera")
class FollowCamera extends TargetCamera {
    // @Ignore
    FollowCamera .fakeConstructor$() : super.fakeConstructor$();
    external num get radius;

    external set radius(num v);

    external num get rotationOffset;

    external set rotationOffset(num v);

    external num get heightOffset;

    external set heightOffset(num v);

    external num get cameraAcceleration;

    external set cameraAcceleration(num v);

    external num get maxCameraSpeed;

    external set maxCameraSpeed(num v);

    external AbstractMesh/*AbstractMesh|Null*/ get lockedTarget;

    external set lockedTarget(AbstractMesh/*AbstractMesh|Null*/ v);

    external factory FollowCamera(String name, Vector3 position, Scene scene, [AbstractMesh/*AbstractMesh|Null*/ lockedTarget]);

    external get JS$_follow;

    external set JS$_follow(v);

    external void JS$_checkInputs();

    external String getClassName();
}

@JS("BABYLON.ArcFollowCamera")
class ArcFollowCamera extends TargetCamera {
    // @Ignore
    ArcFollowCamera .fakeConstructor$() : super.fakeConstructor$();
    external num get alpha;

    external set alpha(num v);

    external num get beta;

    external set beta(num v);

    external num get radius;

    external set radius(num v);

    external AbstractMesh/*AbstractMesh|Null*/ get target;

    external set target(AbstractMesh/*AbstractMesh|Null*/ v);

    external get JS$_cartesianCoordinates;

    external set JS$_cartesianCoordinates(v);

    external factory ArcFollowCamera(String name, num alpha, num beta, num radius, AbstractMesh/*AbstractMesh|Null*/ target, Scene scene);

    external get JS$_follow;

    external set JS$_follow(v);

    external void JS$_checkInputs();

    external String getClassName();
}

@JS("BABYLON.FreeCamera")
class FreeCamera extends TargetCamera {
    // @Ignore
    FreeCamera .fakeConstructor$() : super.fakeConstructor$();
    external Vector3 get ellipsoid;

    external set ellipsoid(Vector3 v);

    external Vector3 get ellipsoidOffset;

    external set ellipsoidOffset(Vector3 v);

    external bool get checkCollisions;

    external set checkCollisions(bool v);

    external bool get applyGravity;

    external set applyGravity(bool v);

    external FreeCameraInputsManager get inputs;

    external set inputs(FreeCameraInputsManager v);

    external num get angularSensibility;

    external set angularSensibility(num v);

    external List<num> get keysUp;

    external set keysUp(List<num> v);

    external List<num> get keysDown;

    external set keysDown(List<num> v);

    external List<num> get keysLeft;

    external set keysLeft(List<num> v);

    external List<num> get keysRight;

    external set keysRight(List<num> v);

    external VoidFunc1<AbstractMesh> get onCollide;

    external set onCollide(VoidFunc1<AbstractMesh> v);

    external get JS$_collider;

    external set JS$_collider(v);

    external get JS$_needMoveForGravity;

    external set JS$_needMoveForGravity(v);

    external get JS$_oldPosition;

    external set JS$_oldPosition(v);

    external get JS$_diffPosition;

    external set JS$_diffPosition(v);

    external get JS$_newPosition;

    external set JS$_newPosition(v);

    external Vector3 get JS$_localDirection;

    external set JS$_localDirection(Vector3 v);

    external Vector3 get JS$_transformedDirection;

    external set JS$_transformedDirection(Vector3 v);

    external factory FreeCamera(String name, Vector3 position, Scene scene, [bool setActiveOnSceneIfNoneActive]);

    external void attachControl(HtmlElement element, [bool noPreventDefault]);

    external void detachControl(HtmlElement element);

    external get JS$_collisionMask;

    external set JS$_collisionMask(v);

    external num get collisionMask;

    external set collisionMask(num v);

    external void JS$_collideWithWorld(Vector3 displacement);

    external get JS$_onCollisionPositionChange;

    external set JS$_onCollisionPositionChange(v);

    external void JS$_checkInputs();

    external bool JS$_decideIfNeedsToMove();

    external void JS$_updatePosition();

    external void dispose();

    external String getClassName();
}

@JS("BABYLON.FreeCameraInputsManager")
class FreeCameraInputsManager extends CameraInputsManager<FreeCamera> {
    // @Ignore
    FreeCameraInputsManager .fakeConstructor$() : super.fakeConstructor$();

    external factory FreeCameraInputsManager(FreeCamera camera);

    external FreeCameraInputsManager addKeyboard();

    external FreeCameraInputsManager addMouse([bool touchEnabled]);

    external FreeCameraInputsManager addDeviceOrientation();

    external FreeCameraInputsManager addTouch();

    external FreeCameraInputsManager addVirtualJoystick();

    external FreeCameraInputsManager addGamepad();
}

@JS("BABYLON.GamepadCamera")
class GamepadCamera extends UniversalCamera {
    // @Ignore
    GamepadCamera .fakeConstructor$() : super.fakeConstructor$();

    external factory GamepadCamera(String name, Vector3 position, Scene scene);

    external String getClassName();
}

@JS("BABYLON.TargetCamera")
class TargetCamera extends Camera {
    // @Ignore
    TargetCamera .fakeConstructor$() : super.fakeConstructor$();
    external Vector3 get cameraDirection;

    external set cameraDirection(Vector3 v);

    external Vector2 get cameraRotation;

    external set cameraRotation(Vector2 v);

    external Vector3 get rotation;

    external set rotation(Vector3 v);

    external Quaternion get rotationQuaternion;

    external set rotationQuaternion(Quaternion v);

    external num get speed;

    external set speed(num v);

    external bool get noRotationConstraint;

    external set noRotationConstraint(bool v);

    external dynamic get lockedTarget;

    external set lockedTarget(dynamic v);

    external Vector3 get JS$_currentTarget;

    external set JS$_currentTarget(Vector3 v);

    external Matrix get JS$_viewMatrix;

    external set JS$_viewMatrix(Matrix v);

    external Matrix get JS$_camMatrix;

    external set JS$_camMatrix(Matrix v);

    external Matrix get JS$_cameraTransformMatrix;

    external set JS$_cameraTransformMatrix(Matrix v);

    external Matrix get JS$_cameraRotationMatrix;

    external set JS$_cameraRotationMatrix(Matrix v);

    external get JS$_rigCamTransformMatrix;

    external set JS$_rigCamTransformMatrix(v);

    external Vector3 get JS$_referencePoint;

    external set JS$_referencePoint(Vector3 v);

    external Vector3 get JS$_transformedReferencePoint;

    external set JS$_transformedReferencePoint(Vector3 v);

    external Vector3 get JS$_globalCurrentTarget;

    external set JS$_globalCurrentTarget(Vector3 v);

    external Vector3 get JS$_globalCurrentUpVector;

    external set JS$_globalCurrentUpVector(Vector3 v);

    external VoidFunc0 get JS$_reset;

    external set JS$_reset(VoidFunc0 v);

    external get JS$_defaultUp;

    external set JS$_defaultUp(v);

    external factory TargetCamera(String name, Vector3 position, Scene scene, [bool setActiveOnSceneIfNoneActive]);

    external Vector3 getFrontPosition(num distance);

    external Vector3/*Vector3|Null*/ JS$_getLockedTargetPosition();

    external get JS$_storedPosition;

    external set JS$_storedPosition(v);

    external get JS$_storedRotation;

    external set JS$_storedRotation(v);

    external get JS$_storedRotationQuaternion;

    external set JS$_storedRotationQuaternion(v);

    external Camera storeState();

    external bool JS$_restoreStateValues();

    external void JS$_initCache();

    external void JS$_updateCache([bool ignoreParentClass]);

    external bool JS$_isSynchronizedViewMatrix();

    external num JS$_computeLocalCameraSpeed();

    external void setTarget(Vector3 target);

    external Vector3 getTarget();

    external bool JS$_decideIfNeedsToMove();

    external void JS$_updatePosition();

    external void JS$_checkInputs();

    external void JS$_updateCameraRotationMatrix();

    external get JS$_rotateUpVectorWithCameraRotationMatrix;

    external set JS$_rotateUpVectorWithCameraRotationMatrix(v);

    external get JS$_cachedRotationZ;

    external set JS$_cachedRotationZ(v);

    external get JS$_cachedQuaternionRotationZ;

    external set JS$_cachedQuaternionRotationZ(v);

    external Matrix JS$_getViewMatrix();

    external void JS$_computeViewMatrix(Vector3 position, Vector3 target, Vector3 up);

    external Camera/*Camera|Null*/ createRigCamera(String name, num cameraIndex);

    external void JS$_updateRigCameras();

    external get JS$_getRigCamPosition;

    external set JS$_getRigCamPosition(v);

    external String getClassName();
}

@JS("BABYLON.TouchCamera")
class TouchCamera extends FreeCamera {
    // @Ignore
    TouchCamera .fakeConstructor$() : super.fakeConstructor$();
    external num get touchAngularSensibility;

    external set touchAngularSensibility(num v);

    external num get touchMoveSensibility;

    external set touchMoveSensibility(num v);

    external factory TouchCamera(String name, Vector3 position, Scene scene);

    external String getClassName();

    external void JS$_setupInputs();
}

@JS("BABYLON.UniversalCamera")
class UniversalCamera extends TouchCamera {
    // @Ignore
    UniversalCamera .fakeConstructor$() : super.fakeConstructor$();
    external num get gamepadAngularSensibility;

    external set gamepadAngularSensibility(num v);

    external num get gamepadMoveSensibility;

    external set gamepadMoveSensibility(num v);

    external factory UniversalCamera(String name, Vector3 position, Scene scene);

    external String getClassName();
}

@JS("BABYLON.VirtualJoysticksCamera")
class VirtualJoysticksCamera extends FreeCamera {
    // @Ignore
    VirtualJoysticksCamera .fakeConstructor$() : super.fakeConstructor$();

    external factory VirtualJoysticksCamera(String name, Vector3 position, Scene scene);

    external String getClassName();
}


// Module Debug
@JS("BABYLON.Debug.AxesViewer")
class AxesViewer {
    // @Ignore
    AxesViewer .fakeConstructor$();

    external get JS$_xline;

    external set JS$_xline(v);

    external get JS$_yline;

    external set JS$_yline(v);

    external get JS$_zline;

    external set JS$_zline(v);

    external get JS$_xmesh;

    external set JS$_xmesh(v);

    external get JS$_ymesh;

    external set JS$_ymesh(v);

    external get JS$_zmesh;

    external set JS$_zmesh(v);

    external Scene/*Scene|Null*/ get scene;

    external set scene(Scene/*Scene|Null*/ v);

    external num get scaleLines;

    external set scaleLines(num v);

    external factory AxesViewer(Scene scene, [num scaleLines]);

    external void update(Vector3 position, Vector3 xaxis, Vector3 yaxis, Vector3 zaxis);

    external void dispose();
}


// End module Debug

// Module Debug
@JS("BABYLON.Debug.BoneAxesViewer")
class BoneAxesViewer extends AxesViewer {
    // @Ignore
    BoneAxesViewer .fakeConstructor$() : super.fakeConstructor$();
    external Mesh/*Mesh|Null*/ get mesh;

    external set mesh(Mesh/*Mesh|Null*/ v);

    external Bone/*Bone|Null*/ get bone;

    external set bone(Bone/*Bone|Null*/ v);

    external Vector3 get pos;

    external set pos(Vector3 v);

    external Vector3 get xaxis;

    external set xaxis(Vector3 v);

    external Vector3 get yaxis;

    external set yaxis(Vector3 v);

    external Vector3 get zaxis;

    external set zaxis(Vector3 v);

    external factory BoneAxesViewer(Scene scene, Bone bone, Mesh mesh, [num scaleLines]);

    external void update();

    external void dispose();
}


// End module Debug
@anonymous
@JS()
abstract class Scene {
    external DebugLayer get JS$_debugLayer;

    external set JS$_debugLayer(DebugLayer v);

    external DebugLayer get debugLayer;

    external set debugLayer(DebugLayer v);
}

@JS("BABYLON.DebugLayer")
class DebugLayer {
    // @Ignore
    DebugLayer .fakeConstructor$();

    external static String get InspectorURL;

    external static set InspectorURL(String v);

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_inspector;

    external set JS$_inspector(v);

    external get BJSINSPECTOR;

    external set BJSINSPECTOR(v);

    external Observable<dynamic /*{
            object: any;
            property: string;
            value: any;
            initialValue: any;
        }*/> get onPropertyChangedObservable;

    external set onPropertyChangedObservable(Observable<dynamic /*{
            object: any;
            property: string;
            value: any;
            initialValue: any;
        }*/> v);

    external factory DebugLayer(Scene scene);

    external get JS$_createInspector;

    external set JS$_createInspector(v);

    external bool isVisible();

    external void hide();

    external void show([dynamic/*{
            popup?: boolean;
            initialTab?: number | string;
            parentElement?: HTMLElement;
            newColors?: {
                backgroundColor?: string;
                backgroundColorLighter?: string;
                backgroundColorLighter2?: string;
                backgroundColorLighter3?: string;
                color?: string;
                colorTop?: string;
                colorBot?: string;
            };
        }*/
    config]);

    external num getActiveTab();
}


// Module Debug
@JS("BABYLON.Debug.PhysicsViewer")
class PhysicsViewer {
    // @Ignore
    PhysicsViewer .fakeConstructor$();

    external List<PhysicsImpostor /*PhysicsImpostor|Null*/> get JS$_impostors;

    external set JS$_impostors(List<PhysicsImpostor /*PhysicsImpostor|Null*/> v);

    external List<AbstractMesh /*AbstractMesh|Null*/> get JS$_meshes;

    external set JS$_meshes(List<AbstractMesh /*AbstractMesh|Null*/> v);

    external Scene/*Scene|Null*/ get JS$_scene;

    external set JS$_scene(Scene/*Scene|Null*/ v);

    external num get JS$_numMeshes;

    external set JS$_numMeshes(num v);

    external IPhysicsEnginePlugin/*IPhysicsEnginePlugin|Null*/ get JS$_physicsEnginePlugin;

    external set JS$_physicsEnginePlugin(IPhysicsEnginePlugin/*IPhysicsEnginePlugin|Null*/ v);

    external get JS$_renderFunction;

    external set JS$_renderFunction(v);

    external get JS$_debugBoxMesh;

    external set JS$_debugBoxMesh(v);

    external get JS$_debugSphereMesh;

    external set JS$_debugSphereMesh(v);

    external get JS$_debugMaterial;

    external set JS$_debugMaterial(v);

    external factory PhysicsViewer(Scene scene);

    external void JS$_updateDebugMeshes();

    external void showImpostor(PhysicsImpostor impostor);

    external void hideImpostor(PhysicsImpostor/*PhysicsImpostor|Null*/ impostor);

    external get JS$_getDebugMaterial;

    external set JS$_getDebugMaterial(v);

    external get JS$_getDebugBoxMesh;

    external set JS$_getDebugBoxMesh(v);

    external get JS$_getDebugSphereMesh;

    external set JS$_getDebugSphereMesh(v);

    external get JS$_getDebugMesh;

    external set JS$_getDebugMesh(v);

    external void dispose();
}


// End module Debug
@JS("BABYLON.RayHelper")
class RayHelper {
    // @Ignore
    RayHelper .fakeConstructor$();

    external Ray/*Ray|Null*/ get ray;

    external set ray(Ray/*Ray|Null*/ v);

    external get JS$_renderPoints;

    external set JS$_renderPoints(v);

    external get JS$_renderLine;

    external set JS$_renderLine(v);

    external get JS$_renderFunction;

    external set JS$_renderFunction(v);

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_updateToMeshFunction;

    external set JS$_updateToMeshFunction(v);

    external get JS$_attachedToMesh;

    external set JS$_attachedToMesh(v);

    external get JS$_meshSpaceDirection;

    external set JS$_meshSpaceDirection(v);

    external get JS$_meshSpaceOrigin;

    external set JS$_meshSpaceOrigin(v);

    external static RayHelper CreateAndShow(Ray ray, Scene scene, Color3 color);

    external factory RayHelper(Ray ray);

    external void show(Scene scene, [Color3 color]);

    external void hide();

    external get JS$_render;

    external set JS$_render(v);

    external void attachToMesh(AbstractMesh mesh, [Vector3 meshSpaceDirection, Vector3 meshSpaceOrigin, num length]);

    external void detachFromMesh();

    external get JS$_updateToMesh;

    external set JS$_updateToMesh(v);

    external void dispose();
}


// Module Debug
@JS("BABYLON.Debug.SkeletonViewer")
class SkeletonViewer {
    // @Ignore
    SkeletonViewer .fakeConstructor$();

    external Skeleton get skeleton;

    external set skeleton(Skeleton v);

    external AbstractMesh get mesh;

    external set mesh(AbstractMesh v);

    external bool get autoUpdateBonesMatrices;

    external set autoUpdateBonesMatrices(bool v);

    external num get renderingGroupId;

    external set renderingGroupId(num v);

    external Color3 get color;

    external set color(Color3 v);

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_debugLines;

    external set JS$_debugLines(v);

    external get JS$_debugMesh;

    external set JS$_debugMesh(v);

    external get JS$_isEnabled;

    external set JS$_isEnabled(v);

    external get JS$_renderFunction;

    external set JS$_renderFunction(v);

    external factory SkeletonViewer(Skeleton skeleton, AbstractMesh mesh, Scene scene, [bool autoUpdateBonesMatrices, num renderingGroupId]);

    external bool get isEnabled;

    external set isEnabled(bool v);

    external get JS$_getBonePosition;

    external set JS$_getBonePosition(v);

    external get JS$_getLinesForBonesWithLength;

    external set JS$_getLinesForBonesWithLength(v);

    external get JS$_getLinesForBonesNoLength;

    external set JS$_getLinesForBonesNoLength(v);

    external void update();

    external void dispose();
}


// End module Debug
@JS("BABYLON.InstancingAttributeInfo")
class InstancingAttributeInfo {
    // @Ignore
    InstancingAttributeInfo .fakeConstructor$();

    external num get index;

    external set index(num v);

    external num get attributeSize;

    external set attributeSize(num v);

    external num get attribyteType;

    external set attribyteType(num v);

    external bool get normalized;

    external set normalized(bool v);

    external num get offset;

    external set offset(num v);

    external String get attributeName;

    external set attributeName(String v);
}

@JS("BABYLON.RenderTargetCreationOptions")
class RenderTargetCreationOptions {
    // @Ignore
    RenderTargetCreationOptions .fakeConstructor$();

    external bool get generateMipMaps;

    external set generateMipMaps(bool v);

    external bool get generateDepthBuffer;

    external set generateDepthBuffer(bool v);

    external bool get generateStencilBuffer;

    external set generateStencilBuffer(bool v);

    external num get type;

    external set type(num v);

    external num get samplingMode;

    external set samplingMode(num v);

    external num get format;

    external set format(num v);
}

@JS("BABYLON.DepthTextureCreationOptions")
class DepthTextureCreationOptions {
    // @Ignore
    DepthTextureCreationOptions .fakeConstructor$();

    external bool get generateStencil;

    external set generateStencil(bool v);

    external bool get bilinearFiltering;

    external set bilinearFiltering(bool v);

    external num get comparisonFunction;

    external set comparisonFunction(num v);

    external bool get isCube;

    external set isCube(bool v);
}

@JS("BABYLON.EngineCapabilities")
class EngineCapabilities {
    // @Ignore
    EngineCapabilities .fakeConstructor$();

    external num get maxTexturesImageUnits;

    external set maxTexturesImageUnits(num v);

    external num get maxVertexTextureImageUnits;

    external set maxVertexTextureImageUnits(num v);

    external num get maxCombinedTexturesImageUnits;

    external set maxCombinedTexturesImageUnits(num v);

    external num get maxTextureSize;

    external set maxTextureSize(num v);

    external num get maxCubemapTextureSize;

    external set maxCubemapTextureSize(num v);

    external num get maxRenderTextureSize;

    external set maxRenderTextureSize(num v);

    external num get maxVertexAttribs;

    external set maxVertexAttribs(num v);

    external num get maxVaryingVectors;

    external set maxVaryingVectors(num v);

    external num get maxVertexUniformVectors;

    external set maxVertexUniformVectors(num v);

    external num get maxFragmentUniformVectors;

    external set maxFragmentUniformVectors(num v);

    external bool get standardDerivatives;

    external set standardDerivatives(bool v);

    external WEBGL_compressed_texture_s3tc/*WEBGL_compressed_texture_s3tc|Null*/ get s3tc;

    external set s3tc(WEBGL_compressed_texture_s3tc/*WEBGL_compressed_texture_s3tc|Null*/ v);

    external dynamic get pvrtc;

    external set pvrtc(dynamic v);

    external dynamic get etc1;

    external set etc1(dynamic v);

    external dynamic get etc2;

    external set etc2(dynamic v);

    external dynamic get astc;

    external set astc(dynamic v);

    external bool get textureFloat;

    external set textureFloat(bool v);

    external bool get vertexArrayObject;

    external set vertexArrayObject(bool v);

    external EXT_texture_filter_anisotropic/*EXT_texture_filter_anisotropic|Null*/ get textureAnisotropicFilterExtension;

    external set textureAnisotropicFilterExtension(EXT_texture_filter_anisotropic/*EXT_texture_filter_anisotropic|Null*/ v);

    external num get maxAnisotropy;

    external set maxAnisotropy(num v);

    external bool get instancedArrays;

    external set instancedArrays(bool v);

    external bool get uintIndices;

    external set uintIndices(bool v);

    external bool get highPrecisionShaderSupported;

    external set highPrecisionShaderSupported(bool v);

    external bool get fragmentDepthSupported;

    external set fragmentDepthSupported(bool v);

    external bool get textureFloatLinearFiltering;

    external set textureFloatLinearFiltering(bool v);

    external bool get textureFloatRender;

    external set textureFloatRender(bool v);

    external bool get textureHalfFloat;

    external set textureHalfFloat(bool v);

    external bool get textureHalfFloatLinearFiltering;

    external set textureHalfFloatLinearFiltering(bool v);

    external bool get textureHalfFloatRender;

    external set textureHalfFloatRender(bool v);

    external bool get textureLOD;

    external set textureLOD(bool v);

    external bool get drawBuffersExtension;

    external set drawBuffersExtension(bool v);

    external bool get depthTextureExtension;

    external set depthTextureExtension(bool v);

    external bool get colorBufferFloat;

    external set colorBufferFloat(bool v);

    external EXT_disjoint_timer_query get timerQuery;

    external set timerQuery(EXT_disjoint_timer_query v);

    external bool get canUseTimestampForTimerQuery;

    external set canUseTimestampForTimerQuery(bool v);
}

@anonymous
@JS()
abstract class EngineOptions
    implements ContextAttributes {
    external num get limitDeviceRatio;

    external set limitDeviceRatio(num v);

    external bool get autoEnableWebVR;

    external set autoEnableWebVR(bool v);

    external bool get disableWebGL2Support;

    external set disableWebGL2Support(bool v);

    external bool get audioEngine;

    external set audioEngine(bool v);

    external bool get deterministicLockstep;

    external set deterministicLockstep(bool v);

    external num get lockstepMaxSteps;

    external set lockstepMaxSteps(num v);

    external bool get doNotHandleContextLost;

    external set doNotHandleContextLost(bool v);

    external factory EngineOptions({ num limitDeviceRatio, bool autoEnableWebVR, bool disableWebGL2Support, bool audioEngine, bool deterministicLockstep, num lockstepMaxSteps, bool doNotHandleContextLost, bool alpha, bool depth, bool stencil, bool antialias, bool premultipliedAlpha, bool preserveDrawingBuffer});
}

@anonymous
@JS()
abstract class IDisplayChangedEventArgs {
    external dynamic/*dynamic|Null*/ get vrDisplay;

    external set vrDisplay(dynamic/*dynamic|Null*/ v);

    external bool get vrSupported;

    external set vrSupported(bool v);

    external factory IDisplayChangedEventArgs({ dynamic/*dynamic|Null*/ vrDisplay, bool vrSupported});
}

@JS("BABYLON.Engine")
class Engine {
    // @Ignore
    Engine .fakeConstructor$();

    external static List<dynamic /*{
            key: string;
            capture: string;
            captureConstraint: number;
            targets: string[];
        }|{
            key: string;
            capture: null;
            captureConstraint: null;
            targets: string[];
        }*/> get ExceptionList;

    external static set ExceptionList(List<dynamic /*{
            key: string;
            capture: string;
            captureConstraint: number;
            targets: string[];
        }|{
            key: string;
            capture: null;
            captureConstraint: null;
            targets: string[];
        }*/> v);

    external static List<Engine> get Instances;

    external static set Instances(List<Engine> v);

    external static Engine/*Engine|Null*/ get LastCreatedEngine;

    external static set LastCreatedEngine(Engine/*Engine|Null*/ v);

    external static Scene/*Scene|Null*/ get LastCreatedScene;

    external static set LastCreatedScene(Scene/*Scene|Null*/ v);

    external static void MarkAllMaterialsAsDirty(num flag, [bool predicate(Material mat)]);

    external static List<IInternalTextureLoader> get JS$_TextureLoaders;

    external static set JS$_TextureLoaders(List<IInternalTextureLoader> v);

    external static num get ALPHA_DISABLE;

    external static set ALPHA_DISABLE(num v);

    external static num get ALPHA_ADD;

    external static set ALPHA_ADD(num v);

    external static num get ALPHA_COMBINE;

    external static set ALPHA_COMBINE(num v);

    external static num get ALPHA_SUBTRACT;

    external static set ALPHA_SUBTRACT(num v);

    external static num get ALPHA_MULTIPLY;

    external static set ALPHA_MULTIPLY(num v);

    external static num get ALPHA_MAXIMIZED;

    external static set ALPHA_MAXIMIZED(num v);

    external static num get ALPHA_ONEONE;

    external static set ALPHA_ONEONE(num v);

    external static num get ALPHA_PREMULTIPLIED;

    external static set ALPHA_PREMULTIPLIED(num v);

    external static num get ALPHA_PREMULTIPLIED_PORTERDUFF;

    external static set ALPHA_PREMULTIPLIED_PORTERDUFF(num v);

    external static num get ALPHA_INTERPOLATE;

    external static set ALPHA_INTERPOLATE(num v);

    external static num get ALPHA_SCREENMODE;

    external static set ALPHA_SCREENMODE(num v);

    external static num get DELAYLOADSTATE_NONE;

    external static set DELAYLOADSTATE_NONE(num v);

    external static num get DELAYLOADSTATE_LOADED;

    external static set DELAYLOADSTATE_LOADED(num v);

    external static num get DELAYLOADSTATE_LOADING;

    external static set DELAYLOADSTATE_LOADING(num v);

    external static num get DELAYLOADSTATE_NOTLOADED;

    external static set DELAYLOADSTATE_NOTLOADED(num v);

    external static num get NEVER;

    external static set NEVER(num v);

    external static num get ALWAYS;

    external static set ALWAYS(num v);

    external static num get LESS;

    external static set LESS(num v);

    external static num get EQUAL;

    external static set EQUAL(num v);

    external static num get LEQUAL;

    external static set LEQUAL(num v);

    external static num get GREATER;

    external static set GREATER(num v);

    external static num get GEQUAL;

    external static set GEQUAL(num v);

    external static num get NOTEQUAL;

    external static set NOTEQUAL(num v);

    external static num get KEEP;

    external static set KEEP(num v);

    external static num get REPLACE;

    external static set REPLACE(num v);

    external static num get INCR;

    external static set INCR(num v);

    external static num get DECR;

    external static set DECR(num v);

    external static num get INVERT;

    external static set INVERT(num v);

    external static num get INCR_WRAP;

    external static set INCR_WRAP(num v);

    external static num get DECR_WRAP;

    external static set DECR_WRAP(num v);

    external static num get TEXTURE_CLAMP_ADDRESSMODE;

    external static set TEXTURE_CLAMP_ADDRESSMODE(num v);

    external static num get TEXTURE_WRAP_ADDRESSMODE;

    external static set TEXTURE_WRAP_ADDRESSMODE(num v);

    external static num get TEXTURE_MIRROR_ADDRESSMODE;

    external static set TEXTURE_MIRROR_ADDRESSMODE(num v);

    external static num get TEXTUREFORMAT_ALPHA;

    external static set TEXTUREFORMAT_ALPHA(num v);

    external static num get TEXTUREFORMAT_LUMINANCE;

    external static set TEXTUREFORMAT_LUMINANCE(num v);

    external static num get TEXTUREFORMAT_LUMINANCE_ALPHA;

    external static set TEXTUREFORMAT_LUMINANCE_ALPHA(num v);

    external static num get TEXTUREFORMAT_RGB;

    external static set TEXTUREFORMAT_RGB(num v);

    external static num get TEXTUREFORMAT_RGBA;

    external static set TEXTUREFORMAT_RGBA(num v);

    external static num get TEXTUREFORMAT_RED;

    external static set TEXTUREFORMAT_RED(num v);

    external static num get TEXTUREFORMAT_R;

    external static set TEXTUREFORMAT_R(num v);

    external static num get TEXTUREFORMAT_RG;

    external static set TEXTUREFORMAT_RG(num v);

    external static num get TEXTUREFORMAT_RED_INTEGER;

    external static set TEXTUREFORMAT_RED_INTEGER(num v);

    external static num get TEXTUREFORMAT_R_INTEGER;

    external static set TEXTUREFORMAT_R_INTEGER(num v);

    external static num get TEXTUREFORMAT_RG_INTEGER;

    external static set TEXTUREFORMAT_RG_INTEGER(num v);

    external static num get TEXTUREFORMAT_RGB_INTEGER;

    external static set TEXTUREFORMAT_RGB_INTEGER(num v);

    external static num get TEXTUREFORMAT_RGBA_INTEGER;

    external static set TEXTUREFORMAT_RGBA_INTEGER(num v);

    external static num get TEXTURETYPE_UNSIGNED_BYTE;

    external static set TEXTURETYPE_UNSIGNED_BYTE(num v);

    external static num get TEXTURETYPE_UNSIGNED_INT;

    external static set TEXTURETYPE_UNSIGNED_INT(num v);

    external static num get TEXTURETYPE_FLOAT;

    external static set TEXTURETYPE_FLOAT(num v);

    external static num get TEXTURETYPE_HALF_FLOAT;

    external static set TEXTURETYPE_HALF_FLOAT(num v);

    external static num get TEXTURETYPE_BYTE;

    external static set TEXTURETYPE_BYTE(num v);

    external static num get TEXTURETYPE_SHORT;

    external static set TEXTURETYPE_SHORT(num v);

    external static num get TEXTURETYPE_UNSIGNED_SHORT;

    external static set TEXTURETYPE_UNSIGNED_SHORT(num v);

    external static num get TEXTURETYPE_INT;

    external static set TEXTURETYPE_INT(num v);

    external static num get TEXTURETYPE_UNSIGNED_INTEGER;

    external static set TEXTURETYPE_UNSIGNED_INTEGER(num v);

    external static num get TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4;

    external static set TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4(num v);

    external static num get TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1;

    external static set TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1(num v);

    external static num get TEXTURETYPE_UNSIGNED_SHORT_5_6_5;

    external static set TEXTURETYPE_UNSIGNED_SHORT_5_6_5(num v);

    external static num get TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV;

    external static set TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV(num v);

    external static num get TEXTURETYPE_UNSIGNED_INT_24_8;

    external static set TEXTURETYPE_UNSIGNED_INT_24_8(num v);

    external static num get TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV;

    external static set TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV(num v);

    external static num get TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV;

    external static set TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV(num v);

    external static num get TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV;

    external static set TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV(num v);

    external static num get TEXTURE_NEAREST_SAMPLINGMODE;

    external static set TEXTURE_NEAREST_SAMPLINGMODE(num v);

    external static num get TEXTURE_BILINEAR_SAMPLINGMODE;

    external static set TEXTURE_BILINEAR_SAMPLINGMODE(num v);

    external static num get TEXTURE_TRILINEAR_SAMPLINGMODE;

    external static set TEXTURE_TRILINEAR_SAMPLINGMODE(num v);

    external static num get TEXTURE_NEAREST_NEAREST_MIPLINEAR;

    external static set TEXTURE_NEAREST_NEAREST_MIPLINEAR(num v);

    external static num get TEXTURE_LINEAR_LINEAR_MIPNEAREST;

    external static set TEXTURE_LINEAR_LINEAR_MIPNEAREST(num v);

    external static num get TEXTURE_LINEAR_LINEAR_MIPLINEAR;

    external static set TEXTURE_LINEAR_LINEAR_MIPLINEAR(num v);

    external static num get TEXTURE_NEAREST_NEAREST_MIPNEAREST;

    external static set TEXTURE_NEAREST_NEAREST_MIPNEAREST(num v);

    external static num get TEXTURE_NEAREST_LINEAR_MIPNEAREST;

    external static set TEXTURE_NEAREST_LINEAR_MIPNEAREST(num v);

    external static num get TEXTURE_NEAREST_LINEAR_MIPLINEAR;

    external static set TEXTURE_NEAREST_LINEAR_MIPLINEAR(num v);

    external static num get TEXTURE_NEAREST_LINEAR;

    external static set TEXTURE_NEAREST_LINEAR(num v);

    external static num get TEXTURE_NEAREST_NEAREST;

    external static set TEXTURE_NEAREST_NEAREST(num v);

    external static num get TEXTURE_LINEAR_NEAREST_MIPNEAREST;

    external static set TEXTURE_LINEAR_NEAREST_MIPNEAREST(num v);

    external static num get TEXTURE_LINEAR_NEAREST_MIPLINEAR;

    external static set TEXTURE_LINEAR_NEAREST_MIPLINEAR(num v);

    external static num get TEXTURE_LINEAR_LINEAR;

    external static set TEXTURE_LINEAR_LINEAR(num v);

    external static num get TEXTURE_LINEAR_NEAREST;

    external static set TEXTURE_LINEAR_NEAREST(num v);

    external static num get TEXTURE_EXPLICIT_MODE;

    external static set TEXTURE_EXPLICIT_MODE(num v);

    external static num get TEXTURE_SPHERICAL_MODE;

    external static set TEXTURE_SPHERICAL_MODE(num v);

    external static num get TEXTURE_PLANAR_MODE;

    external static set TEXTURE_PLANAR_MODE(num v);

    external static num get TEXTURE_CUBIC_MODE;

    external static set TEXTURE_CUBIC_MODE(num v);

    external static num get TEXTURE_PROJECTION_MODE;

    external static set TEXTURE_PROJECTION_MODE(num v);

    external static num get TEXTURE_SKYBOX_MODE;

    external static set TEXTURE_SKYBOX_MODE(num v);

    external static num get TEXTURE_INVCUBIC_MODE;

    external static set TEXTURE_INVCUBIC_MODE(num v);

    external static num get TEXTURE_EQUIRECTANGULAR_MODE;

    external static set TEXTURE_EQUIRECTANGULAR_MODE(num v);

    external static num get TEXTURE_FIXED_EQUIRECTANGULAR_MODE;

    external static set TEXTURE_FIXED_EQUIRECTANGULAR_MODE(num v);

    external static num get TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE;

    external static set TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE(num v);

    external static num get SCALEMODE_FLOOR;

    external static set SCALEMODE_FLOOR(num v);

    external static num get SCALEMODE_NEAREST;

    external static set SCALEMODE_NEAREST(num v);

    external static num get SCALEMODE_CEILING;

    external static set SCALEMODE_CEILING(num v);

    external static String get Version;

    external static set Version(String v);

    external static num get CollisionsEpsilon;

    external static set CollisionsEpsilon(num v);

    external static String get CodeRepository;

    external static set CodeRepository(String v);

    external static String get ShadersRepository;

    external static set ShadersRepository(String v);

    external bool get forcePOTTextures;

    external set forcePOTTextures(bool v);

    external bool get isFullscreen;

    external set isFullscreen(bool v);

    external bool get isPointerLock;

    external set isPointerLock(bool v);

    external bool get cullBackFaces;

    external set cullBackFaces(bool v);

    external bool get renderEvenInBackground;

    external set renderEvenInBackground(bool v);

    external bool get preventCacheWipeBetweenFrames;

    external set preventCacheWipeBetweenFrames(bool v);

    external bool get enableOfflineSupport;

    external set enableOfflineSupport(bool v);

    external bool get disableManifestCheck;

    external set disableManifestCheck(bool v);

    external List<Scene> get scenes;

    external set scenes(List<Scene> v);

    external List<PostProcess> get postProcesses;

    external set postProcesses(List<PostProcess> v);

    external bool get validateShaderPrograms;

    external set validateShaderPrograms(bool v);

    external Observable<Engine> get onResizeObservable;

    external set onResizeObservable(Observable<Engine> v);

    external Observable<Engine> get onCanvasBlurObservable;

    external set onCanvasBlurObservable(Observable<Engine> v);

    external Observable<Engine> get onCanvasFocusObservable;

    external set onCanvasFocusObservable(Observable<Engine> v);

    external Observable<PointerEvent> get onCanvasPointerOutObservable;

    external set onCanvasPointerOutObservable(Observable<PointerEvent> v);

    external Observable<Texture> get onBeforeTextureInitObservable;

    external set onBeforeTextureInitObservable(Observable<Texture> v);

    external get JS$_vrDisplay;

    external set JS$_vrDisplay(v);

    external get JS$_vrSupported;

    external set JS$_vrSupported(v);

    external get JS$_oldSize;

    external set JS$_oldSize(v);

    external get JS$_oldHardwareScaleFactor;

    external set JS$_oldHardwareScaleFactor(v);

    external get JS$_vrExclusivePointerMode;

    external set JS$_vrExclusivePointerMode(v);

    external get JS$_webVRInitPromise;

    external set JS$_webVRInitPromise(v);

    external bool get isInVRExclusivePointerMode;

    external set isInVRExclusivePointerMode(bool v);

    external bool get disableUniformBuffers;

    external set disableUniformBuffers(bool v);

    external List<UniformBuffer> get JS$_uniformBuffers;

    external set JS$_uniformBuffers(List<UniformBuffer> v);

    external bool get supportsUniformBuffers;

    external set supportsUniformBuffers(bool v);

    external Observable<Engine> get onBeginFrameObservable;

    external set onBeginFrameObservable(Observable<Engine> v);

    external Observable<Engine> get onEndFrameObservable;

    external set onEndFrameObservable(Observable<Engine> v);

    external Observable<Engine> get onBeforeShaderCompilationObservable;

    external set onBeforeShaderCompilationObservable(Observable<Engine> v);

    external Observable<Engine> get onAfterShaderCompilationObservable;

    external set onAfterShaderCompilationObservable(Observable<Engine> v);

    external RenderingContext get JS$_gl;

    external set JS$_gl(RenderingContext v);

    external get JS$_renderingCanvas;

    external set JS$_renderingCanvas(v);

    external get JS$_windowIsBackground;

    external set JS$_windowIsBackground(v);

    external get JS$_webGLVersion;

    external set JS$_webGLVersion(v);

    external bool get needPOTTextures;

    external set needPOTTextures(bool v);

    external bool get JS$_badOS;

    external set JS$_badOS(bool v);

    external bool get JS$_badDesktopOS;

    external set JS$_badDesktopOS(bool v);

    external bool get disableTextureBindingOptimization;

    external set disableTextureBindingOptimization(bool v);

    external static IAudioEngine get audioEngine;

    external static set audioEngine(IAudioEngine v);

    external static Func1<HtmlElement/*HtmlElement|Null*/, IAudioEngine> get AudioEngineFactory;

    external static set AudioEngineFactory(Func1<HtmlElement/*HtmlElement|Null*/, IAudioEngine> v);

    external get JS$_onFocus;

    external set JS$_onFocus(v);

    external get JS$_onBlur;

    external set JS$_onBlur(v);

    external get JS$_onCanvasPointerOut;

    external set JS$_onCanvasPointerOut(v);

    external get JS$_onCanvasBlur;

    external set JS$_onCanvasBlur(v);

    external get JS$_onCanvasFocus;

    external set JS$_onCanvasFocus(v);

    external get JS$_onFullscreenChange;

    external set JS$_onFullscreenChange(v);

    external get JS$_onPointerLockChange;

    external set JS$_onPointerLockChange(v);

    external get JS$_onVRDisplayPointerRestricted;

    external set JS$_onVRDisplayPointerRestricted(v);

    external get JS$_onVRDisplayPointerUnrestricted;

    external set JS$_onVRDisplayPointerUnrestricted(v);

    external get JS$_onVrDisplayConnect;

    external set JS$_onVrDisplayConnect(v);

    external get JS$_onVrDisplayDisconnect;

    external set JS$_onVrDisplayDisconnect(v);

    external get JS$_onVrDisplayPresentChange;

    external set JS$_onVrDisplayPresentChange(v);

    external Observable<IDisplayChangedEventArgs> get onVRDisplayChangedObservable;

    external set onVRDisplayChangedObservable(Observable<IDisplayChangedEventArgs> v);

    external Observable<bool> get onVRRequestPresentComplete;

    external set onVRRequestPresentComplete(Observable<bool> v);

    external Observable<Engine> get onVRRequestPresentStart;

    external set onVRRequestPresentStart(Observable<Engine> v);

    external get JS$_hardwareScalingLevel;

    external set JS$_hardwareScalingLevel(v);

    external EngineCapabilities get JS$_caps;

    external set JS$_caps(EngineCapabilities v);

    external get JS$_pointerLockRequested;

    external set JS$_pointerLockRequested(v);

    external get JS$_isStencilEnable;

    external set JS$_isStencilEnable(v);

    external get JS$_colorWrite;

    external set JS$_colorWrite(v);

    external get JS$_loadingScreen;

    external set JS$_loadingScreen(v);

    external PerfCounter get JS$_drawCalls;

    external set JS$_drawCalls(PerfCounter v);

    external PerfCounter get JS$_textureCollisions;

    external set JS$_textureCollisions(PerfCounter v);

    external get JS$_glVersion;

    external set JS$_glVersion(v);

    external get JS$_glRenderer;

    external set JS$_glRenderer(v);

    external get JS$_glVendor;

    external set JS$_glVendor(v);

    external get JS$_videoTextureSupported;

    external set JS$_videoTextureSupported(v);

    external get JS$_renderingQueueLaunched;

    external set JS$_renderingQueueLaunched(v);

    external get JS$_activeRenderLoops;

    external set JS$_activeRenderLoops(v);

    external get JS$_deterministicLockstep;

    external set JS$_deterministicLockstep(v);

    external get JS$_lockstepMaxSteps;

    external set JS$_lockstepMaxSteps(v);

    external Observable<Engine> get onContextLostObservable;

    external set onContextLostObservable(Observable<Engine> v);

    external Observable<Engine> get onContextRestoredObservable;

    external set onContextRestoredObservable(Observable<Engine> v);

    external get JS$_onContextLost;

    external set JS$_onContextLost(v);

    external get JS$_onContextRestored;

    external set JS$_onContextRestored(v);

    external get JS$_contextWasLost;

    external set JS$_contextWasLost(v);

    external get JS$_doNotHandleContextLost;

    external set JS$_doNotHandleContextLost(v);

    external bool get doNotHandleContextLost;

    external set doNotHandleContextLost(bool v);

    external get JS$_performanceMonitor;

    external set JS$_performanceMonitor(v);

    external get JS$_fps;

    external set JS$_fps(v);

    external get JS$_deltaTime;

    external set JS$_deltaTime(v);

    external bool get disablePerformanceMonitorInBackground;

    external set disablePerformanceMonitorInBackground(bool v);

    external PerformanceMonitor get performanceMonitor;

    external set performanceMonitor(PerformanceMonitor v);

    external JS$_DepthCullingState get JS$_depthCullingState;

    external set JS$_depthCullingState(JS$_DepthCullingState v);

    external JS$_StencilState get JS$_stencilState;

    external set JS$_stencilState(JS$_StencilState v);

    external JS$_AlphaState get JS$_alphaState;

    external set JS$_alphaState(JS$_AlphaState v);

    external num get JS$_alphaMode;

    external set JS$_alphaMode(num v);

    external List<InternalTexture> get JS$_internalTexturesCache;

    external set JS$_internalTexturesCache(List<InternalTexture> v);

    external num get JS$_activeChannel;

    external set JS$_activeChannel(num v);

    external get JS$_currentTextureChannel;

    external set JS$_currentTextureChannel(v);

    external dynamic/*JSMap of <String,InternalTexture|Null>*/ get JS$_boundTexturesCache;

    external set JS$_boundTexturesCache(dynamic/*JSMap of <String,InternalTexture|Null>*/ v);

    external Effect/*Effect|Null*/ get JS$_currentEffect;

    external set JS$_currentEffect(Effect/*Effect|Null*/ v);

    external Program/*Program|Null*/ get JS$_currentProgram;

    external set JS$_currentProgram(Program/*Program|Null*/ v);

    external get JS$_compiledEffects;

    external set JS$_compiledEffects(v);

    external get JS$_vertexAttribArraysEnabled;

    external set JS$_vertexAttribArraysEnabled(v);

    external Viewport/*Viewport|Null*/ get JS$_cachedViewport;

    external set JS$_cachedViewport(Viewport/*Viewport|Null*/ v);

    external get JS$_cachedVertexArrayObject;

    external set JS$_cachedVertexArrayObject(v);

    external dynamic get JS$_cachedVertexBuffers;

    external set JS$_cachedVertexBuffers(dynamic v);

    external Buffer/*Buffer|Null*/ get JS$_cachedIndexBuffer;

    external set JS$_cachedIndexBuffer(Buffer/*Buffer|Null*/ v);

    external Effect/*Effect|Null*/ get JS$_cachedEffectForVertexBuffers;

    external set JS$_cachedEffectForVertexBuffers(Effect/*Effect|Null*/ v);

    external InternalTexture/*InternalTexture|Null*/ get JS$_currentRenderTarget;

    external set JS$_currentRenderTarget(InternalTexture/*InternalTexture|Null*/ v);

    external get JS$_uintIndicesCurrentlySet;

    external set JS$_uintIndicesCurrentlySet(v);

    external get JS$_currentBoundBuffer;

    external set JS$_currentBoundBuffer(v);

    external Framebuffer/*Framebuffer|Null*/ get JS$_currentFramebuffer;

    external set JS$_currentFramebuffer(Framebuffer/*Framebuffer|Null*/ v);

    external get JS$_currentBufferPointers;

    external set JS$_currentBufferPointers(v);

    external get JS$_currentInstanceLocations;

    external set JS$_currentInstanceLocations(v);

    external get JS$_currentInstanceBuffers;

    external set JS$_currentInstanceBuffers(v);

    external get JS$_textureUnits;

    external set JS$_textureUnits(v);

    external get JS$_firstBoundInternalTextureTracker;

    external set JS$_firstBoundInternalTextureTracker(v);

    external get JS$_lastBoundInternalTextureTracker;

    external set JS$_lastBoundInternalTextureTracker(v);

    external get JS$_workingCanvas;

    external set JS$_workingCanvas(v);

    external get JS$_workingContext;

    external set JS$_workingContext(v);

    external get JS$_rescalePostProcess;

    external set JS$_rescalePostProcess(v);

    external get JS$_dummyFramebuffer;

    external set JS$_dummyFramebuffer(v);

    external get JS$_externalData;

    external set JS$_externalData(v);

    external get JS$_bindedRenderFunction;

    external set JS$_bindedRenderFunction(v);

    external get JS$_vaoRecordInProgress;

    external set JS$_vaoRecordInProgress(v);

    external get JS$_mustWipeVertexAttributes;

    external set JS$_mustWipeVertexAttributes(v);

    external get JS$_emptyTexture;

    external set JS$_emptyTexture(v);

    external get JS$_emptyCubeTexture;

    external set JS$_emptyCubeTexture(v);

    external get JS$_emptyTexture3D;

    external set JS$_emptyTexture3D(v);

    external get JS$_frameHandler;

    external set JS$_frameHandler(v);

    external get JS$_nextFreeTextureSlots;

    external set JS$_nextFreeTextureSlots(v);

    external get JS$_maxSimultaneousTextures;

    external set JS$_maxSimultaneousTextures(v);

    external get JS$_activeRequests;

    external set JS$_activeRequests(v);

    external get JS$_texturesSupported;

    external set JS$_texturesSupported(v);

    external get JS$_textureFormatInUse;

    external set JS$_textureFormatInUse(v);

    external List<String> get texturesSupported;

    external set texturesSupported(List<String> v);

    external String/*String|Null*/ get textureFormatInUse;

    external set textureFormatInUse(String/*String|Null*/ v);

    external Viewport/*Viewport|Null*/ get currentViewport;

    external set currentViewport(Viewport/*Viewport|Null*/ v);

    external InternalTexture get emptyTexture;

    external set emptyTexture(InternalTexture v);

    external InternalTexture get emptyTexture3D;

    external set emptyTexture3D(InternalTexture v);

    external InternalTexture get emptyCubeTexture;

    external set emptyCubeTexture(InternalTexture v);

    external bool get premultipliedAlpha;

    external set premultipliedAlpha(bool v);

    external factory Engine(dynamic/*CanvasElement|RenderingContext|Null*/ canvasOrContext, [bool antialias, EngineOptions options, bool adaptToDeviceRatio]);

    external get JS$_rebuildInternalTextures;

    external set JS$_rebuildInternalTextures(v);

    external get JS$_rebuildEffects;

    external set JS$_rebuildEffects(v);

    external get JS$_rebuildBuffers;

    external set JS$_rebuildBuffers(v);

    external get JS$_initGLContext;

    external set JS$_initGLContext(v);

    external num get webGLVersion;

    external set webGLVersion(num v);

    external bool get isStencilEnable;

    external set isStencilEnable(bool v);

    external get JS$_prepareWorkingCanvas;

    external set JS$_prepareWorkingCanvas(v);

    external void resetTextureCache();

    external bool isDeterministicLockStep();

    external num getLockstepMaxSteps();

    external dynamic/*{
            vendor: string;
            renderer: string;
            version: string;
        }*/
    getGlInfo();

    external num getAspectRatio(Camera camera, [bool useScreen]);

    external num getScreenAspectRatio();

    external num getRenderWidth([bool useScreen]);

    external num getRenderHeight([bool useScreen]);

    external CanvasElement/*CanvasElement|Null*/ getRenderingCanvas();

    external Rectangle/*Rectangle|Null*/ getRenderingCanvasClientRect();

    external void setHardwareScalingLevel(num level);

    external num getHardwareScalingLevel();

    external List<InternalTexture> getLoadedTexturesCache();

    external EngineCapabilities getCaps();

    external num get drawCalls;

    external set drawCalls(num v);

    external PerfCounter/*PerfCounter|Null*/ get drawCallsPerfCounter;

    external set drawCallsPerfCounter(PerfCounter/*PerfCounter|Null*/ v);

    external num/*num|Null*/ getDepthFunction();

    external void setDepthFunction(num depthFunc);

    external void setDepthFunctionToGreater();

    external void setDepthFunctionToGreaterOrEqual();

    external void setDepthFunctionToLess();

    external void setDepthFunctionToLessOrEqual();

    external bool getStencilBuffer();

    external void setStencilBuffer(bool enable);

    external num getStencilMask();

    external void setStencilMask(num mask);

    external num getStencilFunction();

    external num getStencilFunctionReference();

    external num getStencilFunctionMask();

    external void setStencilFunction(num stencilFunc);

    external void setStencilFunctionReference(num reference);

    external void setStencilFunctionMask(num mask);

    external num getStencilOperationFail();

    external num getStencilOperationDepthFail();

    external num getStencilOperationPass();

    external void setStencilOperationFail(num operation);

    external void setStencilOperationDepthFail(num operation);

    external void setStencilOperationPass(num operation);

    external void setDitheringState(bool value);

    external void setRasterizerState(bool value);

    external void stopRenderLoop([void renderFunction()]);

    external void JS$_renderLoop();

    external void runRenderLoop(void renderFunction());

    external void switchFullscreen(bool requestPointerLock);

    external void clear(Color4/*Color4|Null*/ color, bool backBuffer, bool depth, [bool stencil]);

    external void scissorClear(num x, num y, num width, num height, Color4 clearColor);

    external get JS$_viewportCached;

    external set JS$_viewportCached(v);

    external void JS$_viewport(num x, num y, num width, num height);

    external void setViewport(Viewport viewport, [num requiredWidth, num requiredHeight]);

    external Viewport/*Viewport|Null*/ setDirectViewport(num x, num y, num width, num height);

    external void beginFrame();

    external void endFrame();

    external void resize();

    external void setSize(num width, num height);

    external bool isVRDevicePresent();

    external dynamic getVRDevice();

    external Observable<IDisplayChangedEventArgs> initWebVR();

    external Promise<IDisplayChangedEventArgs> initWebVRAsync();

    external void enableVR();

    external void disableVR();

    external get JS$_onVRFullScreenTriggered;

    external set JS$_onVRFullScreenTriggered(v);

    external get JS$_getVRDisplaysAsync;

    external set JS$_getVRDisplaysAsync(v);

    external void bindFramebuffer(InternalTexture texture, [num faceIndex, num requiredWidth, num requiredHeight, bool forceFullscreenViewport, InternalTexture depthStencilTexture, num lodLevel]);

    external get bindUnboundFramebuffer;

    external set bindUnboundFramebuffer(v);

    external void unBindFramebuffer(InternalTexture texture, [bool disableGenerateMipMaps, void onBeforeUnbind()]);

    external void unBindMultiColorAttachmentFramebuffer(List<InternalTexture> textures, [bool disableGenerateMipMaps, void onBeforeUnbind()]);

    external void generateMipMapsForCubemap(InternalTexture texture);

    external void flushFramebuffer();

    external void restoreDefaultFramebuffer();

    external Buffer createUniformBuffer(dynamic/*List<num>|Float32List*/ elements);

    external Buffer createDynamicUniformBuffer(dynamic/*List<num>|Float32List*/ elements);

    external void updateUniformBuffer(Buffer uniformBuffer, dynamic/*List<num>|Float32List*/ elements, [num offset, num count]);

    external get JS$_resetVertexBufferBinding;

    external set JS$_resetVertexBufferBinding(v);

    external Buffer createVertexBuffer(dynamic/*List<num>|ByteBuffer|TypedData*/ data);

    external Buffer createDynamicVertexBuffer(dynamic/*List<num>|ByteBuffer|TypedData*/ data);

    external void updateDynamicIndexBuffer(Buffer indexBuffer, dynamic/*List<num>|Int32List|Uint32List|Uint16List*/ indices, [num offset]);

    external void updateDynamicVertexBuffer(Buffer vertexBuffer, dynamic/*List<num>|ByteBuffer|TypedData*/ data, [num byteOffset, num byteLength]);

    external get JS$_resetIndexBufferBinding;

    external set JS$_resetIndexBufferBinding(v);

    external Buffer createIndexBuffer(dynamic/*List<num>|Int32List|Uint32List|Uint16List*/ indices, [bool updatable]);

    external void bindArrayBuffer(Buffer/*Buffer|Null*/ buffer);

    external void bindUniformBuffer(Buffer/*Buffer|Null*/ buffer);

    external void bindUniformBufferBase(Buffer buffer, num location);

    external void bindUniformBlock(Program shaderProgram, String blockName, num index);

    external get bindIndexBuffer;

    external set bindIndexBuffer(v);

    external get bindBuffer;

    external set bindBuffer(v);

    external void updateArrayBuffer(Float32List data);

    external get JS$_vertexAttribPointer;

    external set JS$_vertexAttribPointer(v);

    external get JS$_bindIndexBufferWithCache;

    external set JS$_bindIndexBufferWithCache(v);

    external get JS$_bindVertexBuffersAttributes;

    external set JS$_bindVertexBuffersAttributes(v);

    external WebGLVertexArrayObject recordVertexArrayObject(dynamic/*JSMap of <String,VertexBuffer>*/ vertexBuffers, Buffer/*Buffer|Null*/ indexBuffer, Effect effect);

    external void bindVertexArrayObject(WebGLVertexArrayObject vertexArrayObject, Buffer/*Buffer|Null*/ indexBuffer);

    external void bindBuffersDirectly(Buffer vertexBuffer, Buffer indexBuffer, List<num> vertexDeclaration, num vertexStrideSize, Effect effect);

    external get JS$_unbindVertexArrayObject;

    external set JS$_unbindVertexArrayObject(v);

    external void bindBuffers(dynamic/*JSMap of <String,VertexBuffer|Null>*/ vertexBuffers, Buffer/*Buffer|Null*/ indexBuffer, Effect effect);

    external void unbindInstanceAttributes();

    external void releaseVertexArrayObject(WebGLVertexArrayObject vao);

    external bool JS$_releaseBuffer(Buffer buffer);

    external Buffer createInstancesBuffer(num capacity);

    external void deleteInstancesBuffer(Buffer buffer);

    external void updateAndBindInstancesBuffer(Buffer instancesBuffer, Float32List data, List<dynamic>/*List<num>|List<InstancingAttributeInfo>*/ offsetLocations);

    external void applyStates();

    external void draw(bool useTriangles, num indexStart, num indexCount, [num instancesCount]);

    external void drawPointClouds(num verticesStart, num verticesCount, [num instancesCount]);

    external void drawUnIndexed(bool useTriangles, num verticesStart, num verticesCount, [num instancesCount]);

    external void drawElementsType(num fillMode, num indexStart, num indexCount, [num instancesCount]);

    external void drawArraysType(num fillMode, num verticesStart, num verticesCount, [num instancesCount]);

    external get JS$_drawMode;

    external set JS$_drawMode(v);

    external void JS$_releaseEffect(Effect effect);

    external void JS$_deleteProgram(Program program);

    external Effect createEffect(dynamic baseName, dynamic/*List<String>|EffectCreationOptions*/ attributesNamesOrOptions, dynamic/*List<String>|Engine*/ uniformsNamesOrEngine, [List<String> samplers, String defines, EffectFallbacks fallbacks, void onCompiled(Effect effect), void onError(Effect effect, String errors), dynamic indexParameters]);

    external get JS$_compileShader;

    external set JS$_compileShader(v);

    external get JS$_compileRawShader;

    external set JS$_compileRawShader(v);

    external Program createRawShaderProgram(String vertexCode, String fragmentCode, [RenderingContext context, List<String>/*List<String>|Null*/ transformFeedbackVaryings]);

    external Program createShaderProgram(String vertexCode, String fragmentCode, String/*String|Null*/ defines, [RenderingContext context, List<String>/*List<String>|Null*/ transformFeedbackVaryings]);

    external get JS$_createShaderProgram;

    external set JS$_createShaderProgram(v);

    external List<UniformLocation /*UniformLocation|Null*/> getUniforms(Program shaderProgram, List<String> uniformsNames);

    external List<num> getAttributes(Program shaderProgram, List<String> attributesNames);

    external void enableEffect(Effect/*Effect|Null*/ effect);

    external void setIntArray(UniformLocation/*UniformLocation|Null*/ uniform, Int32List array);

    external void setIntArray2(UniformLocation/*UniformLocation|Null*/ uniform, Int32List array);

    external void setIntArray3(UniformLocation/*UniformLocation|Null*/ uniform, Int32List array);

    external void setIntArray4(UniformLocation/*UniformLocation|Null*/ uniform, Int32List array);

    external void setFloatArray(UniformLocation/*UniformLocation|Null*/ uniform, Float32List array);

    external void setFloatArray2(UniformLocation/*UniformLocation|Null*/ uniform, Float32List array);

    external void setFloatArray3(UniformLocation/*UniformLocation|Null*/ uniform, Float32List array);

    external void setFloatArray4(UniformLocation/*UniformLocation|Null*/ uniform, Float32List array);

    external void setArray(UniformLocation/*UniformLocation|Null*/ uniform, List<num> array);

    external void setArray2(UniformLocation/*UniformLocation|Null*/ uniform, List<num> array);

    external void setArray3(UniformLocation/*UniformLocation|Null*/ uniform, List<num> array);

    external void setArray4(UniformLocation/*UniformLocation|Null*/ uniform, List<num> array);

    external void setMatrices(UniformLocation/*UniformLocation|Null*/ uniform, Float32List matrices);

    external void setMatrix(UniformLocation/*UniformLocation|Null*/ uniform, Matrix matrix);

    external void setMatrix3x3(UniformLocation/*UniformLocation|Null*/ uniform, Float32List matrix);

    external void setMatrix2x2(UniformLocation/*UniformLocation|Null*/ uniform, Float32List matrix);

    external void setInt(UniformLocation/*UniformLocation|Null*/ uniform, num value);

    external void setFloat(UniformLocation/*UniformLocation|Null*/ uniform, num value);

    external void setFloat2(UniformLocation/*UniformLocation|Null*/ uniform, num x, num y);

    external void setFloat3(UniformLocation/*UniformLocation|Null*/ uniform, num x, num y, num z);

    external void setBool(UniformLocation/*UniformLocation|Null*/ uniform, num bool);

    external void setFloat4(UniformLocation/*UniformLocation|Null*/ uniform, num x, num y, num z, num w);

    external void setColor3(UniformLocation/*UniformLocation|Null*/ uniform, Color3 color3);

    external void setColor4(UniformLocation/*UniformLocation|Null*/ uniform, Color3 color3, num alpha);

    external void setDirectColor4(UniformLocation/*UniformLocation|Null*/ uniform, Color4 color4);

    external void setState(bool culling, [num zOffset, bool force, bool reverseSide]);

    external void setZOffset(num value);

    external num getZOffset();

    external void setDepthBuffer(bool enable);

    external bool getDepthWrite();

    external void setDepthWrite(bool enable);

    external void setColorWrite(bool enable);

    external bool getColorWrite();

    external void setAlphaConstants(num r, num g, num b, num a);

    external void setAlphaMode(num mode, [bool noDepthWriteChange]);

    external num getAlphaMode();

    external void clearInternalTexturesCache();

    external void wipeCaches([bool bruteForce]);

    external String/*String|Null*/ setTextureFormatToUse(List<String> formatsAvailable);

    external get JS$_getSamplingParameters;

    external set JS$_getSamplingParameters(v);

    external get JS$_partialLoadImg;

    external set JS$_partialLoadImg(v);

    external get JS$_cascadeLoadImgs;

    external set JS$_cascadeLoadImgs(v);

    external Texture JS$_createTexture();

    external InternalTexture createTexture(String/*String|Null*/ urlArg, bool noMipmap, bool invertY, Scene/*Scene|Null*/ scene, [num samplingMode, VoidFunc0/*VoidFunc0|Null*/ onLoad, VoidFunc2<String, dynamic>/*VoidFunc2<String, dynamic>|Null*/ onError, dynamic/*String|ByteBuffer|ImageElement|Blob|Null*/ buffer, InternalTexture/*InternalTexture|Null*/ fallback, num/*num|Null*/ format, String/*String|Null*/ forcedExtension]);

    external get JS$_rescaleTexture;

    external set JS$_rescaleTexture(v);

    external void updateRawTexture(InternalTexture/*InternalTexture|Null*/ texture, TypedData/*TypedData|Null*/ data, num format, bool invertY, [String/*String|Null*/ compression, num type]);

    external InternalTexture createRawTexture(TypedData/*TypedData|Null*/ data, num width, num height, num format, bool generateMipMaps, bool invertY, num samplingMode, [String/*String|Null*/ compression, num type]);

    external get JS$_unpackFlipYCached;

    external set JS$_unpackFlipYCached(v);

    external bool get enableUnpackFlipYCached;

    external set enableUnpackFlipYCached(bool v);

    external void JS$_unpackFlipY(bool value);

    external num JS$_getUnpackAlignement();

    external InternalTexture createDynamicTexture(num width, num height, bool generateMipMaps, num samplingMode);

    external void updateTextureSamplingMode(num samplingMode, InternalTexture texture);

    external void updateDynamicTexture(InternalTexture/*InternalTexture|Null*/ texture, CanvasElement canvas, bool invertY, [bool premulAlpha, num format]);

    external void updateVideoTexture(InternalTexture/*InternalTexture|Null*/ texture, VideoElement video, bool invertY);

    external void updateTextureComparisonFunction(InternalTexture texture, num comparisonFunction);

    external get JS$_setupDepthStencilTexture;

    external set JS$_setupDepthStencilTexture(v);

    external InternalTexture createDepthStencilTexture(dynamic/*num|{
            width: number;
            height: number;
        }*/
    size, DepthTextureCreationOptions options);

    external get JS$_createDepthStencilTexture;

    external set JS$_createDepthStencilTexture(v);

    external get JS$_createDepthStencilCubeTexture;

    external set JS$_createDepthStencilCubeTexture(v);

    external void setFrameBufferDepthStencilTexture(RenderTargetTexture renderTarget);

    external InternalTexture createRenderTargetTexture(dynamic/*num|{
            width: number;
            height: number;
        }*/
    size, dynamic/*bool|RenderTargetCreationOptions*/ options);

    external List<InternalTexture> createMultipleRenderTarget(dynamic size, IMultiRenderTargetOptions options);

    external get JS$_setupFramebufferDepthAttachments;

    external set JS$_setupFramebufferDepthAttachments(v);

    external num updateRenderTargetTextureSampleCount(InternalTexture/*InternalTexture|Null*/ texture, num samples);

    external num updateMultipleRenderTargetTextureSampleCount(List<InternalTexture>/*List<InternalTexture>|Null*/ textures, num samples);

    external void JS$_uploadCompressedDataToTextureDirectly(InternalTexture texture, num internalFormat, num width, num height, TypedData data, [num faceIndex, num lod]);

    external void JS$_uploadDataToTextureDirectly(InternalTexture texture, TypedData imageData, [num faceIndex, num lod]);

    external void JS$_uploadArrayBufferViewToTexture(InternalTexture texture, TypedData imageData, [num faceIndex, num lod]);

    external void JS$_uploadImageToTexture(InternalTexture texture, ImageElement image, [num faceIndex, num lod]);

    external InternalTexture createRenderTargetCubeTexture(num size, [Partial<RenderTargetCreationOptions> options]);

    external InternalTexture createPrefilteredCubeTexture(String rootUrl, Scene/*Scene|Null*/ scene, num lodScale, num lodOffset, [VoidFunc1<InternalTexture>/*VoidFunc1<InternalTexture|Null>|Null*/ onLoad, Function/*(message?: string, exception?: any) => void|Null*/ onError, num format, dynamic forcedExtension, bool createPolynomials]);

    external InternalTexture createCubeTexture(String rootUrl, Scene/*Scene|Null*/ scene, List<String>/*List<String>|Null*/ files, [bool noMipmap, VoidFunc1Opt1<dynamic>/*VoidFunc1Opt1<dynamic>|Null*/ onLoad, Function/*(message?: string, exception?: any) => void|Null*/ onError, num format, dynamic forcedExtension, bool createPolynomials, num lodScale, num lodOffset, InternalTexture/*InternalTexture|Null*/ fallback]);

    external void JS$_setCubeMapTextureParams(bool loadMipmap);

    external void updateRawCubeTexture(InternalTexture texture, List<TypedData> data, num format, num type, bool invertY, [String/*String|Null*/ compression, num level]);

    external InternalTexture createRawCubeTexture(List<TypedData>/*List<TypedData>|Null*/ data, num size, num format, num type, bool generateMipMaps, bool invertY, num samplingMode, [String/*String|Null*/ compression]);

    external InternalTexture createRawCubeTextureFromUrl(String url, Scene scene, num size, num format, num type, bool noMipmap, List<TypedData>/*List<TypedData>|Null*/ callback(ByteBuffer ArrayBuffer), Func1<List<TypedData>, List<List<TypedData>>>/*Func1<List<TypedData>, List<List<TypedData>>>|Null*/ mipmapGenerator, [VoidFunc0/*VoidFunc0|Null*/ onLoad, Function/*(message?: string, exception?: any) => void|Null*/ onError, num samplingMode, bool invertY]);

    external void updateRawTexture3D(InternalTexture texture, TypedData/*TypedData|Null*/ data, num format, bool invertY, [String/*String|Null*/ compression, num textureType]);

    external InternalTexture createRawTexture3D(TypedData/*TypedData|Null*/ data, num width, num height, num depth, num format, bool generateMipMaps, bool invertY, num samplingMode, [String/*String|Null*/ compression, num textureType]);

    external get JS$_prepareWebGLTextureContinuation;

    external set JS$_prepareWebGLTextureContinuation(v);

    external get JS$_prepareWebGLTexture;

    external set JS$_prepareWebGLTexture(v);

    external get JS$_convertRGBtoRGBATextureData;

    external set JS$_convertRGBtoRGBATextureData(v);

    external void JS$_releaseFramebufferObjects(InternalTexture texture);

    external void JS$_releaseTexture(InternalTexture texture);

    external get setProgram;

    external set setProgram(v);

    external get JS$_boundUniforms;

    external set JS$_boundUniforms(v);

    external void bindSamplers(Effect effect);

    external get JS$_moveBoundTextureOnTop;

    external set JS$_moveBoundTextureOnTop(v);

    external get JS$_getCorrectTextureChannel;

    external set JS$_getCorrectTextureChannel(v);

    external get JS$_linkTrackers;

    external set JS$_linkTrackers(v);

    external get JS$_removeDesignatedSlot;

    external set JS$_removeDesignatedSlot(v);

    external get JS$_activateCurrentTexture;

    external set JS$_activateCurrentTexture(v);

    external bool JS$_bindTextureDirectly(num target, InternalTexture/*InternalTexture|Null*/ texture, [bool forTextureDataUpdate, bool force]);

    external void JS$_bindTexture(num channel, InternalTexture/*InternalTexture|Null*/ texture);

    external void setTextureFromPostProcess(num channel, PostProcess/*PostProcess|Null*/ postProcess);

    external void setTextureFromPostProcessOutput(num channel, PostProcess/*PostProcess|Null*/ postProcess);

    external void unbindAllTextures();

    external void setTexture(num channel, UniformLocation/*UniformLocation|Null*/ uniform, BaseTexture/*BaseTexture|Null*/ texture);

    external void setDepthStencilTexture(num channel, UniformLocation/*UniformLocation|Null*/ uniform, RenderTargetTexture/*RenderTargetTexture|Null*/ texture);

    external get JS$_bindSamplerUniformToChannel;

    external set JS$_bindSamplerUniformToChannel(v);

    external get JS$_getTextureWrapMode;

    external set JS$_getTextureWrapMode(v);

    external get JS$_setTexture;

    external set JS$_setTexture(v);

    external void setTextureArray(num channel, UniformLocation/*UniformLocation|Null*/ uniform, List<BaseTexture> textures);

    external void JS$_setAnisotropicLevel(num target, BaseTexture texture);

    external get JS$_setTextureParameterFloat;

    external set JS$_setTextureParameterFloat(v);

    external get JS$_setTextureParameterInteger;

    external set JS$_setTextureParameterInteger(v);

    external Uint8List readPixels(num x, num y, num width, num height);

    external bool addExternalData /*<T>*/(String key, dynamic/*=T*/ data);

    external dynamic/*=T*/ getExternalData /*<T>*/(String key);

    external dynamic/*=T*/ getOrAddExternalDataWithFactory /*<T>*/(String key, dynamic/*=T*/ JS$factory(String k));

    external bool removeExternalData(String key);

    external void unbindAllAttributes();

    external void releaseEffects();

    external void dispose();

    external void displayLoadingUI();

    external void hideLoadingUI();

    external ILoadingScreen get loadingScreen;

    external set loadingScreen(ILoadingScreen v);

    external String get loadingUIText;

    external set loadingUIText(String v);

    external String get loadingUIBackgroundColor;

    external set loadingUIBackgroundColor(String v);

    external void attachContextLostEvent(VoidFunc1<ContextEvent> callback);

    external void attachContextRestoredEvent(VoidFunc1<ContextEvent> callback);

    external String/*String|Null*/ getVertexShaderSource(Program program);

    external String/*String|Null*/ getFragmentShaderSource(Program program);

    external num getError();

    external num getFps();

    external num getDeltaTime();

    external get JS$_measureFps;

    external set JS$_measureFps(v);

    external TypedData JS$_readTexturePixels(InternalTexture texture, num width, num height, [num faceIndex, num level, TypedData/*TypedData|Null*/ buffer]);

    external get JS$_canRenderToFloatFramebuffer;

    external set JS$_canRenderToFloatFramebuffer(v);

    external get JS$_canRenderToHalfFloatFramebuffer;

    external set JS$_canRenderToHalfFloatFramebuffer(v);

    external get JS$_canRenderToFramebuffer;

    external set JS$_canRenderToFramebuffer(v);

    external num JS$_getWebGLTextureType(num type);

    external get JS$_getInternalFormat;

    external set JS$_getInternalFormat(v);

    external num JS$_getRGBABufferInternalSizedFormat(num type, [num format]);

    external num JS$_getRGBAMultiSampleBufferFormat(num type);

    external IFileRequest JS$_loadFile(String url, void onSuccess(dynamic/*String|ByteBuffer*/ data, [String responseURL]), [void onProgress(dynamic data), Database database, bool useArrayBuffer, void onError([HttpRequest request, dynamic exception])]);

    external Promise<dynamic /*String|ByteBuffer*/> JS$_loadFileAsync(String url, [Database database, bool useArrayBuffer]);

    external get JS$_partialLoadFile;

    external set JS$_partialLoadFile(v);

    external get JS$_cascadeLoadFiles;

    external set JS$_cascadeLoadFiles(v);

    external static bool isSupported();

    external Effect createEffectForParticles(String fragmentName, List<String> uniformsNames, List<String> samplers, String defines, [EffectFallbacks fallbacks, void onCompiled(Effect effect), void onError(Effect effect, String errors)]);

    external WebGLQuery createQuery();

    external Engine deleteQuery(WebGLQuery query);

    external bool isQueryResultAvailable(WebGLQuery query);

    external num getQueryResult(WebGLQuery query);

    external Engine beginOcclusionQuery(num algorithmType, WebGLQuery query);

    external Engine endOcclusionQuery(num algorithmType);

    external JS$_TimeToken/*JS$_TimeToken|Null*/ startTimeQuery();

    external num endTimeQuery(JS$_TimeToken token);

    external JS$_TimeToken/*JS$_TimeToken|Null*/ get JS$_currentNonTimestampToken;

    external set JS$_currentNonTimestampToken(JS$_TimeToken/*JS$_TimeToken|Null*/ v);

    external WebGLQuery JS$_createTimeQuery();

    external void JS$_deleteTimeQuery(WebGLQuery query);

    external num JS$_getGlAlgorithmType(num algorithmType);

    external dynamic JS$_getTimeQueryResult(WebGLQuery query);

    external dynamic JS$_getTimeQueryAvailability(WebGLQuery query);

    external WebGLTransformFeedback createTransformFeedback();

    external void deleteTransformFeedback(WebGLTransformFeedback value);

    external void bindTransformFeedback(WebGLTransformFeedback/*WebGLTransformFeedback|Null*/ value);

    external void beginTransformFeedback(bool usePoints);

    external void endTransformFeedback();

    external void setTranformFeedbackVaryings(Program program, List<String> value);

    external void bindTransformFeedbackBuffer(Buffer/*Buffer|Null*/ value);
}

@JS("BABYLON.NullEngineOptions")
class NullEngineOptions {
    // @Ignore
    NullEngineOptions .fakeConstructor$();

    external num get renderWidth;

    external set renderWidth(num v);

    external num get renderHeight;

    external set renderHeight(num v);

    external num get textureSize;

    external set textureSize(num v);

    external bool get deterministicLockstep;

    external set deterministicLockstep(bool v);

    external num get lockstepMaxSteps;

    external set lockstepMaxSteps(num v);
}

@JS("BABYLON.NullEngine")
class NullEngine extends Engine {
    // @Ignore
    NullEngine .fakeConstructor$() : super.fakeConstructor$();
    external get JS$_options;

    external set JS$_options(v);

    external bool isDeterministicLockStep();

    external num getLockstepMaxSteps();

    external num getHardwareScalingLevel();

    external factory NullEngine([NullEngineOptions options]);

    external Buffer createVertexBuffer(dynamic/*List<num>|Float32List*/ vertices);

    external Buffer createIndexBuffer(dynamic/*List<num>|Int32List|Uint32List|Uint16List*/ indices);

    external void clear(Color4 color, bool backBuffer, bool depth, [bool stencil]);

    external num getRenderWidth([bool useScreen]);

    external num getRenderHeight([bool useScreen]);

    external void setViewport(Viewport viewport, [num requiredWidth, num requiredHeight]);

    external Program createShaderProgram(String vertexCode, String fragmentCode, String defines, [RenderingContext context]);

    external List<UniformLocation> getUniforms(Program shaderProgram, List<String> uniformsNames);

    external List<num> getAttributes(Program shaderProgram, List<String> attributesNames);

    external void bindSamplers(Effect effect);

    external void enableEffect(Effect effect);

    external void setState(bool culling, [num zOffset, bool force, bool reverseSide]);

    external void setIntArray(UniformLocation uniform, Int32List array);

    external void setIntArray2(UniformLocation uniform, Int32List array);

    external void setIntArray3(UniformLocation uniform, Int32List array);

    external void setIntArray4(UniformLocation uniform, Int32List array);

    external void setFloatArray(UniformLocation uniform, Float32List array);

    external void setFloatArray2(UniformLocation uniform, Float32List array);

    external void setFloatArray3(UniformLocation uniform, Float32List array);

    external void setFloatArray4(UniformLocation uniform, Float32List array);

    external void setArray(UniformLocation uniform, List<num> array);

    external void setArray2(UniformLocation uniform, List<num> array);

    external void setArray3(UniformLocation uniform, List<num> array);

    external void setArray4(UniformLocation uniform, List<num> array);

    external void setMatrices(UniformLocation uniform, Float32List matrices);

    external void setMatrix(UniformLocation uniform, Matrix matrix);

    external void setMatrix3x3(UniformLocation uniform, Float32List matrix);

    external void setMatrix2x2(UniformLocation uniform, Float32List matrix);

    external void setFloat(UniformLocation uniform, num value);

    external void setFloat2(UniformLocation uniform, num x, num y);

    external void setFloat3(UniformLocation uniform, num x, num y, num z);

    external void setBool(UniformLocation uniform, num bool);

    external void setFloat4(UniformLocation uniform, num x, num y, num z, num w);

    external void setColor3(UniformLocation uniform, Color3 color3);

    external void setColor4(UniformLocation uniform, Color3 color3, num alpha);

    external void setAlphaMode(num mode, [bool noDepthWriteChange]);

    external void bindBuffers(dynamic/*JSMap of <String,VertexBuffer>*/ vertexBuffers, Buffer indexBuffer, Effect effect);

    external void wipeCaches([bool bruteForce]);

    external void draw(bool useTriangles, num indexStart, num indexCount, [num instancesCount]);

    external void drawElementsType(num fillMode, num indexStart, num indexCount, [num instancesCount]);

    external void drawArraysType(num fillMode, num verticesStart, num verticesCount, [num instancesCount]);

    external Texture JS$_createTexture();

    external void JS$_releaseTexture(InternalTexture texture);

    external InternalTexture createTexture(String urlArg, bool noMipmap, bool invertY, Scene scene, [num samplingMode, VoidFunc0/*VoidFunc0|Null*/ onLoad, VoidFunc2<String, dynamic>/*VoidFunc2<String, dynamic>|Null*/ onError, dynamic/*ByteBuffer|ImageElement|Null*/ buffer, InternalTexture fallBack, num format]);

    external InternalTexture createRenderTargetTexture(dynamic size, dynamic/*bool|RenderTargetCreationOptions*/ options);

    external void updateTextureSamplingMode(num samplingMode, InternalTexture texture);

    external void bindFramebuffer(InternalTexture texture, [num faceIndex, num requiredWidth, num requiredHeight, bool forceFullscreenViewport]);

    external void unBindFramebuffer(InternalTexture texture, [bool disableGenerateMipMaps, void onBeforeUnbind()]);

    external Buffer createDynamicVertexBuffer(dynamic/*List<num>|Float32List*/ vertices);

    external void updateDynamicTexture(InternalTexture/*InternalTexture|Null*/ texture, CanvasElement canvas, bool invertY, [bool premulAlpha, num format]);

    external num getError();

    external num JS$_getUnpackAlignement();

    external void JS$_unpackFlipY(bool value);

    external void updateDynamicIndexBuffer(Buffer indexBuffer, dynamic/*List<num>|Int32List|Uint32List|Uint16List*/ indices, [num offset]);

    external void updateDynamicVertexBuffer(Buffer vertexBuffer, dynamic/*List<num>|Float32List*/ vertices, [num byteOffset, num byteLength]);

    external bool JS$_bindTextureDirectly(num target, InternalTexture texture);

    external void JS$_bindTexture(num channel, InternalTexture texture);

    external bool JS$_releaseBuffer(Buffer buffer);

    external void releaseEffects();

    external void displayLoadingUI();

    external void hideLoadingUI();

    external void JS$_uploadCompressedDataToTextureDirectly(InternalTexture texture, num internalFormat, num width, num height, TypedData data, [num faceIndex, num lod]);

    external void JS$_uploadDataToTextureDirectly(InternalTexture texture, TypedData imageData, [num faceIndex, num lod]);

    external void JS$_uploadArrayBufferViewToTexture(InternalTexture texture, TypedData imageData, [num faceIndex, num lod]);

    external void JS$_uploadImageToTexture(InternalTexture texture, ImageElement image, [num faceIndex, num lod]);
}

@JS("BABYLON.BoundingBox")
class BoundingBox implements ICullable {
    // @Ignore
    BoundingBox .fakeConstructor$();

    external List<Vector3> get vectors;

    external set vectors(List<Vector3> v);

    external Vector3 get center;

    external set center(Vector3 v);

    external Vector3 get centerWorld;

    external set centerWorld(Vector3 v);

    external Vector3 get extendSize;

    external set extendSize(Vector3 v);

    external Vector3 get extendSizeWorld;

    external set extendSizeWorld(Vector3 v);

    external List<Vector3> get directions;

    external set directions(List<Vector3> v);

    external List<Vector3> get vectorsWorld;

    external set vectorsWorld(List<Vector3> v);

    external Vector3 get minimumWorld;

    external set minimumWorld(Vector3 v);

    external Vector3 get maximumWorld;

    external set maximumWorld(Vector3 v);

    external Vector3 get minimum;

    external set minimum(Vector3 v);

    external Vector3 get maximum;

    external set maximum(Vector3 v);

    external get JS$_worldMatrix;

    external set JS$_worldMatrix(v);

    external num get JS$_tag;

    external set JS$_tag(num v);

    external factory BoundingBox(Vector3 min, Vector3 max);

    external void reConstruct(Vector3 min, Vector3 max);

    external BoundingBox scale(num factor);

    external Matrix getWorldMatrix();

    external BoundingBox setWorldMatrix(Matrix matrix);

    external void JS$_update(Matrix world);

    external bool isInFrustum(List<Plane> frustumPlanes);

    external bool isCompletelyInFrustum(List<Plane> frustumPlanes);

    external bool intersectsPoint(Vector3 point);

    external bool intersectsSphere(BoundingSphere sphere);

    external bool intersectsMinMax(Vector3 min, Vector3 max);

    external static bool Intersects(BoundingBox box0, BoundingBox box1);

    external static bool IntersectsSphere(Vector3 minPoint, Vector3 maxPoint, Vector3 sphereCenter, num sphereRadius);

    external static bool IsCompletelyInFrustum(List<Vector3> boundingVectors, List<Plane> frustumPlanes);

    external static bool IsInFrustum(List<Vector3> boundingVectors, List<Plane> frustumPlanes);
}

@anonymous
@JS()
abstract class ICullable {
    external bool isInFrustum(List<Plane> frustumPlanes);

    external bool isCompletelyInFrustum(List<Plane> frustumPlanes);
}

@JS("BABYLON.BoundingInfo")
class BoundingInfo implements ICullable {
    // @Ignore
    BoundingInfo .fakeConstructor$();

    external BoundingBox get boundingBox;

    external set boundingBox(BoundingBox v);

    external BoundingSphere get boundingSphere;

    external set boundingSphere(BoundingSphere v);

    external get JS$_isLocked;

    external set JS$_isLocked(v);

    external factory BoundingInfo(Vector3 minimum, Vector3 maximum);

    external Vector3 get minimum;

    external set minimum(Vector3 v);

    external Vector3 get maximum;

    external set maximum(Vector3 v);

    external bool get isLocked;

    external set isLocked(bool v);

    external void update(Matrix world);

    external BoundingInfo centerOn(Vector3 center, Vector3 extend);

    external BoundingInfo scale(num factor);

    external bool isInFrustum(List<Plane> frustumPlanes, [num strategy]);

    external num get diagonalLength;

    external set diagonalLength(num v);

    external bool isCompletelyInFrustum(List<Plane> frustumPlanes);

    external bool JS$_checkCollision(Collider collider);

    external bool intersectsPoint(Vector3 point);

    external bool intersects(BoundingInfo boundingInfo, bool precise);
}

@JS("BABYLON.BoundingSphere")
class BoundingSphere {
    // @Ignore
    BoundingSphere .fakeConstructor$();

    external Vector3 get center;

    external set center(Vector3 v);

    external num get radius;

    external set radius(num v);

    external Vector3 get centerWorld;

    external set centerWorld(Vector3 v);

    external num get radiusWorld;

    external set radiusWorld(num v);

    external Vector3 get minimum;

    external set minimum(Vector3 v);

    external Vector3 get maximum;

    external set maximum(Vector3 v);

    external factory BoundingSphere(Vector3 min, Vector3 max);

    external void reConstruct(Vector3 min, Vector3 max);

    external BoundingSphere scale(num factor);

    external void JS$_update(Matrix world);

    external bool isInFrustum(List<Plane> frustumPlanes);

    external bool intersectsPoint(Vector3 point);

    external static bool Intersects(BoundingSphere sphere0, BoundingSphere sphere1);
}

@JS("BABYLON.Ray")
class Ray {
    // @Ignore
    Ray .fakeConstructor$();

    external Vector3 get origin;

    external set origin(Vector3 v);

    external Vector3 get direction;

    external set direction(Vector3 v);

    external num get length;

    external set length(num v);

    external get JS$_edge1;

    external set JS$_edge1(v);

    external get JS$_edge2;

    external set JS$_edge2(v);

    external get JS$_pvec;

    external set JS$_pvec(v);

    external get JS$_tvec;

    external set JS$_tvec(v);

    external get JS$_qvec;

    external set JS$_qvec(v);

    external get JS$_tmpRay;

    external set JS$_tmpRay(v);

    external factory Ray(Vector3 origin, Vector3 direction, [num length]);

    external bool intersectsBoxMinMax(Vector3 minimum, Vector3 maximum);

    external bool intersectsBox(BoundingBox box);

    external bool intersectsSphere(BoundingSphere sphere);

    external IntersectionInfo/*IntersectionInfo|Null*/ intersectsTriangle(Vector3 vertex0, Vector3 vertex1, Vector3 vertex2);

    external num/*num|Null*/ intersectsPlane(Plane plane);

    external PickingInfo intersectsMesh(AbstractMesh mesh, [bool fastCheck]);

    external List<PickingInfo> intersectsMeshes(List<AbstractMesh> meshes, [bool fastCheck, List<PickingInfo> results]);

    external get JS$_comparePickingInfo;

    external set JS$_comparePickingInfo(v);

    external static get smallnum;

    external static set smallnum(v);

    external static get rayl;

    external static set rayl(v);

    external num intersectionSegment(Vector3 sega, Vector3 segb, num threshold);

    external Ray update(num x, num y, num viewportWidth, num viewportHeight, Matrix world, Matrix view, Matrix projection);

    external static Ray Zero();

    external static Ray CreateNew(num x, num y, num viewportWidth, num viewportHeight, Matrix world, Matrix view, Matrix projection);

    external static Ray CreateNewFromTo(Vector3 origin, Vector3 end, [Matrix world]);

    external static Ray Transform(Ray ray, Matrix matrix);

    external static void TransformToRef(Ray ray, Matrix matrix, Ray result);
}

@JS("BABYLON.KeyboardEventTypes")
class KeyboardEventTypes {
    // @Ignore
    KeyboardEventTypes .fakeConstructor$();

    external static num get KEYDOWN;

    external static set KEYDOWN(num v);

    external static num get KEYUP;

    external static set KEYUP(num v);
}

@JS("BABYLON.KeyboardInfo")
class KeyboardInfo {
    // @Ignore
    KeyboardInfo .fakeConstructor$();

    external num get type;

    external set type(num v);

    external KeyboardEvent get event;

    external set event(KeyboardEvent v);

    external factory KeyboardInfo(num type, KeyboardEvent event);
}

@JS("BABYLON.KeyboardInfoPre")
class KeyboardInfoPre extends KeyboardInfo {
    // @Ignore
    KeyboardInfoPre .fakeConstructor$() : super.fakeConstructor$();
    external num get type;

    external set type(num v);

    external KeyboardEvent get event;

    external set event(KeyboardEvent v);

    external bool get skipOnPointerObservable;

    external set skipOnPointerObservable(bool v);

    external factory KeyboardInfoPre(num type, KeyboardEvent event);
}

@JS("BABYLON.PointerEventTypes")
class PointerEventTypes {
    // @Ignore
    PointerEventTypes .fakeConstructor$();

    external static num get POINTERDOWN;

    external static set POINTERDOWN(num v);

    external static num get POINTERUP;

    external static set POINTERUP(num v);

    external static num get POINTERMOVE;

    external static set POINTERMOVE(num v);

    external static num get POINTERWHEEL;

    external static set POINTERWHEEL(num v);

    external static num get POINTERPICK;

    external static set POINTERPICK(num v);

    external static num get POINTERTAP;

    external static set POINTERTAP(num v);

    external static num get POINTERDOUBLETAP;

    external static set POINTERDOUBLETAP(num v);
}

@JS("BABYLON.PointerInfoBase")
class PointerInfoBase {
    // @Ignore
    PointerInfoBase .fakeConstructor$();

    external num get type;

    external set type(num v);

    external dynamic/*PointerEvent|MouseWheelEvent*/ get event;

    external set event(dynamic/*PointerEvent|MouseWheelEvent*/ v);

    external factory PointerInfoBase(num type, dynamic/*PointerEvent|MouseWheelEvent*/ event);
}

@JS("BABYLON.PointerInfoPre")
class PointerInfoPre extends PointerInfoBase {
    // @Ignore
    PointerInfoPre .fakeConstructor$() : super.fakeConstructor$();
    external Ray/*Ray|Null*/ get ray;

    external set ray(Ray/*Ray|Null*/ v);

    external Vector2 get localPosition;

    external set localPosition(Vector2 v);

    external bool get skipOnPointerObservable;

    external set skipOnPointerObservable(bool v);

    external factory PointerInfoPre(num type, dynamic/*PointerEvent|MouseWheelEvent*/ event, num localX, num localY);
}

@JS("BABYLON.PointerInfo")
class PointerInfo extends PointerInfoBase {
    // @Ignore
    PointerInfo .fakeConstructor$() : super.fakeConstructor$();
    external PickingInfo/*PickingInfo|Null*/ get pickInfo;

    external set pickInfo(PickingInfo/*PickingInfo|Null*/ v);

    external factory PointerInfo(num type, dynamic/*PointerEvent|MouseWheelEvent*/ event, PickingInfo/*PickingInfo|Null*/ pickInfo);
}

@JS("BABYLON.StickValues")
class StickValues {
    // @Ignore
    StickValues .fakeConstructor$();

    external num get x;

    external set x(num v);

    external num get y;

    external set y(num v);

    external factory StickValues(num x, num y);
}

@anonymous
@JS()
abstract class GamepadButtonChanges {
    external bool get changed;

    external set changed(bool v);

    external bool get pressChanged;

    external set pressChanged(bool v);

    external bool get touchChanged;

    external set touchChanged(bool v);

    external bool get valueChanged;

    external set valueChanged(bool v);

    external factory GamepadButtonChanges({ bool changed, bool pressChanged, bool touchChanged, bool valueChanged});
}

@JS("BABYLON.Gamepad")
class Gamepad {
    // @Ignore
    Gamepad .fakeConstructor$();

    external String get id;

    external set id(String v);

    external num get index;

    external set index(num v);

    external dynamic get browserGamepad;

    external set browserGamepad(dynamic v);

    external num get type;

    external set type(num v);

    external get JS$_leftStick;

    external set JS$_leftStick(v);

    external get JS$_rightStick;

    external set JS$_rightStick(v);

    external bool get JS$_isConnected;

    external set JS$_isConnected(bool v);

    external get JS$_leftStickAxisX;

    external set JS$_leftStickAxisX(v);

    external get JS$_leftStickAxisY;

    external set JS$_leftStickAxisY(v);

    external get JS$_rightStickAxisX;

    external set JS$_rightStickAxisX(v);

    external get JS$_rightStickAxisY;

    external set JS$_rightStickAxisY(v);

    external get JS$_onleftstickchanged;

    external set JS$_onleftstickchanged(v);

    external get JS$_onrightstickchanged;

    external set JS$_onrightstickchanged(v);

    external static num get GAMEPAD;

    external static set GAMEPAD(num v);

    external static num get GENERIC;

    external static set GENERIC(num v);

    external static num get XBOX;

    external static set XBOX(num v);

    external static num get POSE_ENABLED;

    external static set POSE_ENABLED(num v);

    external bool get JS$_invertLeftStickY;

    external set JS$_invertLeftStickY(bool v);

    external bool get isConnected;

    external set isConnected(bool v);

    external factory Gamepad(String id, num index, dynamic browserGamepad, [num leftStickX, num leftStickY, num rightStickX, num rightStickY]);

    external void onleftstickchanged(void callback(StickValues values));

    external void onrightstickchanged(void callback(StickValues values));

    external StickValues get leftStick;

    external set leftStick(StickValues v);

    external StickValues get rightStick;

    external set rightStick(StickValues v);

    external void update();

    external void dispose();
}

@JS("BABYLON.GenericPad")
class GenericPad extends Gamepad {
    // @Ignore
    GenericPad .fakeConstructor$() : super.fakeConstructor$();
    external get JS$_buttons;

    external set JS$_buttons(v);

    external get JS$_onbuttondown;

    external set JS$_onbuttondown(v);

    external get JS$_onbuttonup;

    external set JS$_onbuttonup(v);

    external Observable<num> get onButtonDownObservable;

    external set onButtonDownObservable(Observable<num> v);

    external Observable<num> get onButtonUpObservable;

    external set onButtonUpObservable(Observable<num> v);

    external void onbuttondown(void callback(num buttonPressed));

    external void onbuttonup(void callback(num buttonReleased));

    external factory GenericPad(String id, num index, dynamic browserGamepad);

    external get JS$_setButtonValue;

    external set JS$_setButtonValue(v);

    external void update();

    external void dispose();
}

@JS("BABYLON.GamepadManager")
class GamepadManager {
    // @Ignore
    GamepadManager .fakeConstructor$();

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_babylonGamepads;

    external set JS$_babylonGamepads(v);

    external get JS$_oneGamepadConnected;

    external set JS$_oneGamepadConnected(v);

    external bool get JS$_isMonitoring;

    external set JS$_isMonitoring(bool v);

    external get JS$_gamepadEventSupported;

    external set JS$_gamepadEventSupported(v);

    external get JS$_gamepadSupport;

    external set JS$_gamepadSupport(v);

    external Observable<Gamepad> get onGamepadConnectedObservable;

    external set onGamepadConnectedObservable(Observable<Gamepad> v);

    external Observable<Gamepad> get onGamepadDisconnectedObservable;

    external set onGamepadDisconnectedObservable(Observable<Gamepad> v);

    external get JS$_onGamepadConnectedEvent;

    external set JS$_onGamepadConnectedEvent(v);

    external get JS$_onGamepadDisconnectedEvent;

    external set JS$_onGamepadDisconnectedEvent(v);

    external factory GamepadManager([dynamic/*Scene|dynamic*/ JS$_scene]);

    external List<Gamepad> get gamepads;

    external set gamepads(List<Gamepad> v);

    external Gamepad/*Gamepad|Null*/ getGamepadByType([num type]);

    external void dispose();

    external get JS$_addNewGamepad;

    external set JS$_addNewGamepad(v);

    external get JS$_startMonitoringGamepads;

    external set JS$_startMonitoringGamepads(v);

    external get JS$_stopMonitoringGamepads;

    external set JS$_stopMonitoringGamepads(v);

    external void JS$_checkGamepadsStatus();

    external get JS$_updateGamepadObjects;

    external set JS$_updateGamepadObjects(v);
}

@anonymous
@JS()
abstract class Scene {
    external GamepadManager/*GamepadManager|Null*/ get JS$_gamepadManager;

    external set JS$_gamepadManager(GamepadManager/*GamepadManager|Null*/ v);

    external GamepadManager get gamepadManager;

    external set gamepadManager(GamepadManager v);
}

@anonymous
@JS()
abstract class FreeCameraInputsManager {
    external FreeCameraInputsManager addGamepad();
}

@anonymous
@JS()
abstract class ArcRotateCameraInputsManager {
    external ArcRotateCameraInputsManager addGamepad();
}

@JS("BABYLON.GamepadSystemSceneComponent")
class GamepadSystemSceneComponent implements ISceneComponent {
    // @Ignore
    GamepadSystemSceneComponent .fakeConstructor$();

    external String get name;

    external set name(String v);

    external Scene get scene;

    external set scene(Scene v);

    external factory GamepadSystemSceneComponent(Scene scene);

    external void register();

    external void rebuild();

    external void dispose();

    external get JS$_beforeCameraUpdate;

    external set JS$_beforeCameraUpdate(v);
}

@JS("BABYLON.Xbox360Button")
class Xbox360Button {
    external static num get A;

    external static num get B;

    external static num get X;

    external static num get Y;

    external static num get Start;

    external static num get Back;

    external static num get LB;

    external static num get RB;

    external static num get LeftStick;

    external static num get RightStick;
}

@JS("BABYLON.Xbox360Dpad")
class Xbox360Dpad {
    external static num get Up;

    external static num get Down;

    external static num get Left;

    external static num get Right;
}

@JS("BABYLON.Xbox360Pad")
class Xbox360Pad extends Gamepad {
    // @Ignore
    Xbox360Pad .fakeConstructor$() : super.fakeConstructor$();
    external get JS$_leftTrigger;

    external set JS$_leftTrigger(v);

    external get JS$_rightTrigger;

    external set JS$_rightTrigger(v);

    external get JS$_onlefttriggerchanged;

    external set JS$_onlefttriggerchanged(v);

    external get JS$_onrighttriggerchanged;

    external set JS$_onrighttriggerchanged(v);

    external get JS$_onbuttondown;

    external set JS$_onbuttondown(v);

    external get JS$_onbuttonup;

    external set JS$_onbuttonup(v);

    external get JS$_ondpaddown;

    external set JS$_ondpaddown(v);

    external get JS$_ondpadup;

    external set JS$_ondpadup(v);

    external Observable<num /*enum Xbox360Button*/> get onButtonDownObservable;

    external set onButtonDownObservable(Observable<num /*enum Xbox360Button*/> v);

    external Observable<num /*enum Xbox360Button*/> get onButtonUpObservable;

    external set onButtonUpObservable(Observable<num /*enum Xbox360Button*/> v);

    external Observable<num /*enum Xbox360Dpad*/> get onPadDownObservable;

    external set onPadDownObservable(Observable<num /*enum Xbox360Dpad*/> v);

    external Observable<num /*enum Xbox360Dpad*/> get onPadUpObservable;

    external set onPadUpObservable(Observable<num /*enum Xbox360Dpad*/> v);

    external get JS$_buttonA;

    external set JS$_buttonA(v);

    external get JS$_buttonB;

    external set JS$_buttonB(v);

    external get JS$_buttonX;

    external set JS$_buttonX(v);

    external get JS$_buttonY;

    external set JS$_buttonY(v);

    external get JS$_buttonBack;

    external set JS$_buttonBack(v);

    external get JS$_buttonStart;

    external set JS$_buttonStart(v);

    external get JS$_buttonLB;

    external set JS$_buttonLB(v);

    external get JS$_buttonRB;

    external set JS$_buttonRB(v);

    external get JS$_buttonLeftStick;

    external set JS$_buttonLeftStick(v);

    external get JS$_buttonRightStick;

    external set JS$_buttonRightStick(v);

    external get JS$_dPadUp;

    external set JS$_dPadUp(v);

    external get JS$_dPadDown;

    external set JS$_dPadDown(v);

    external get JS$_dPadLeft;

    external set JS$_dPadLeft(v);

    external get JS$_dPadRight;

    external set JS$_dPadRight(v);

    external get JS$_isXboxOnePad;

    external set JS$_isXboxOnePad(v);

    external factory Xbox360Pad(String id, num index, dynamic gamepad, [bool xboxOne]);

    external void onlefttriggerchanged(void callback(num value));

    external void onrighttriggerchanged(void callback(num value));

    external num get leftTrigger;

    external set leftTrigger(num v);

    external num get rightTrigger;

    external set rightTrigger(num v);

    external void onbuttondown(void callback(num/*enum Xbox360Button*/ buttonPressed));

    external void onbuttonup(void callback(num/*enum Xbox360Button*/ buttonReleased));

    external void ondpaddown(void callback(num/*enum Xbox360Dpad*/ dPadPressed));

    external void ondpadup(void callback(num/*enum Xbox360Dpad*/ dPadReleased));

    external get JS$_setButtonValue;

    external set JS$_setButtonValue(v);

    external get JS$_setDPadValue;

    external set JS$_setDPadValue(v);

    external num get buttonA;

    external set buttonA(num v);

    external num get buttonB;

    external set buttonB(num v);

    external num get buttonX;

    external set buttonX(num v);

    external num get buttonY;

    external set buttonY(num v);

    external num get buttonStart;

    external set buttonStart(num v);

    external num get buttonBack;

    external set buttonBack(num v);

    external num get buttonLB;

    external set buttonLB(num v);

    external num get buttonRB;

    external set buttonRB(num v);

    external num get buttonLeftStick;

    external set buttonLeftStick(num v);

    external num get buttonRightStick;

    external set buttonRightStick(num v);

    external num get dPadUp;

    external set dPadUp(num v);

    external num get dPadDown;

    external set dPadDown(num v);

    external num get dPadLeft;

    external set dPadLeft(num v);

    external num get dPadRight;

    external set dPadRight(num v);

    external void update();

    external void dispose();
}

@JS("BABYLON.AxisDragGizmo")
class AxisDragGizmo extends Gizmo {
    // @Ignore
    AxisDragGizmo .fakeConstructor$() : super.fakeConstructor$();
    external PointerDragBehavior get dragBehavior;

    external set dragBehavior(PointerDragBehavior v);

    external get JS$_pointerObserver;

    external set JS$_pointerObserver(v);

    external num get snapDistance;

    external set snapDistance(num v);

    external Observable<dynamic /*{
            snapDistance: number;
        }*/> get onSnapObservable;

    external set onSnapObservable(Observable<dynamic /*{
            snapDistance: number;
        }*/> v);

    external factory AxisDragGizmo(Vector3 dragAxis, [Color3 color, UtilityLayerRenderer gizmoLayer]);

    external void JS$_attachedMeshChanged(AbstractMesh/*AbstractMesh|Null*/ value);

    external void dispose();
}

@JS("BABYLON.AxisScaleGizmo")
class AxisScaleGizmo extends Gizmo {
    // @Ignore
    AxisScaleGizmo .fakeConstructor$() : super.fakeConstructor$();
    external get JS$_coloredMaterial;

    external set JS$_coloredMaterial(v);

    external PointerDragBehavior get dragBehavior;

    external set dragBehavior(PointerDragBehavior v);

    external get JS$_pointerObserver;

    external set JS$_pointerObserver(v);

    external num get snapDistance;

    external set snapDistance(num v);

    external Observable<dynamic /*{
            snapDistance: number;
        }*/> get onSnapObservable;

    external set onSnapObservable(Observable<dynamic /*{
            snapDistance: number;
        }*/> v);

    external bool get uniformScaling;

    external set uniformScaling(bool v);

    external factory AxisScaleGizmo(Vector3 dragAxis, [Color3 color, UtilityLayerRenderer gizmoLayer]);

    external void JS$_attachedMeshChanged(AbstractMesh/*AbstractMesh|Null*/ value);

    external void dispose();

    external void setCustomMesh(Mesh mesh, [bool useGizmoMaterial]);
}

@JS("BABYLON.BoundingBoxGizmo")
class BoundingBoxGizmo extends Gizmo {
    // @Ignore
    BoundingBoxGizmo .fakeConstructor$() : super.fakeConstructor$();
    external get JS$_lineBoundingBox;

    external set JS$_lineBoundingBox(v);

    external get JS$_rotateSpheresParent;

    external set JS$_rotateSpheresParent(v);

    external get JS$_scaleBoxesParent;

    external set JS$_scaleBoxesParent(v);

    external get JS$_boundingDimensions;

    external set JS$_boundingDimensions(v);

    external get JS$_renderObserver;

    external set JS$_renderObserver(v);

    external get JS$_pointerObserver;

    external set JS$_pointerObserver(v);

    external get JS$_scaleDragSpeed;

    external set JS$_scaleDragSpeed(v);

    external get JS$_tmpQuaternion;

    external set JS$_tmpQuaternion(v);

    external get JS$_tmpVector;

    external set JS$_tmpVector(v);

    external get JS$_tmpRotationMatrix;

    external set JS$_tmpRotationMatrix(v);

    external bool get ignoreChildren;

    external set ignoreChildren(bool v);

    external Func1<AbstractMesh, bool>/*Func1<AbstractMesh, bool>|Null*/ get includeChildPredicate;

    external set includeChildPredicate(Func1<AbstractMesh, bool>/*Func1<AbstractMesh, bool>|Null*/ v);

    external num get rotationSphereSize;

    external set rotationSphereSize(num v);

    external num get scaleBoxSize;

    external set scaleBoxSize(num v);

    external bool get fixedDragMeshScreenSize;

    external set fixedDragMeshScreenSize(bool v);

    external num get fixedDragMeshScreenSizeDistanceFactor;

    external set fixedDragMeshScreenSizeDistanceFactor(num v);

    external Observable<dynamic /*{}*/> get onDragStartObservable;

    external set onDragStartObservable(Observable<dynamic /*{}*/> v);

    external Observable<dynamic /*{}*/> get onScaleBoxDragObservable;

    external set onScaleBoxDragObservable(Observable<dynamic /*{}*/> v);

    external Observable<dynamic /*{}*/> get onScaleBoxDragEndObservable;

    external set onScaleBoxDragEndObservable(Observable<dynamic /*{}*/> v);

    external Observable<dynamic /*{}*/> get onRotationSphereDragObservable;

    external set onRotationSphereDragObservable(Observable<dynamic /*{}*/> v);

    external Observable<dynamic /*{}*/> get onRotationSphereDragEndObservable;

    external set onRotationSphereDragEndObservable(Observable<dynamic /*{}*/> v);

    external Vector3/*Vector3|Null*/ get scalePivot;

    external set scalePivot(Vector3/*Vector3|Null*/ v);

    external get JS$_anchorMesh;

    external set JS$_anchorMesh(v);

    external get JS$_existingMeshScale;

    external set JS$_existingMeshScale(v);

    external static get JS$_PivotCached;

    external static set JS$_PivotCached(v);

    external static get JS$_OldPivotPoint;

    external static set JS$_OldPivotPoint(v);

    external static get JS$_PivotTranslation;

    external static set JS$_PivotTranslation(v);

    external static get JS$_PivotTmpVector;

    external static set JS$_PivotTmpVector(v);

    external static void JS$_RemoveAndStorePivotPoint(AbstractMesh mesh);

    external static void JS$_RestorePivotPoint(AbstractMesh mesh);

    external factory BoundingBoxGizmo([Color3 color, UtilityLayerRenderer gizmoLayer]);

    external void JS$_attachedMeshChanged(AbstractMesh/*AbstractMesh|Null*/ value);

    external get JS$_selectNode;

    external set JS$_selectNode(v);

    external void updateBoundingBox();

    external void setEnabledRotationAxis(String axis);

    external void dispose();

    external static Mesh MakeNotPickableAndWrapInBoundingBox(Mesh mesh);

    external void setCustomMesh(Mesh mesh);
}

@JS("BABYLON.Gizmo")
class Gizmo implements IDisposable {
    // @Ignore
    Gizmo .fakeConstructor$();

    external UtilityLayerRenderer get gizmoLayer;

    external set gizmoLayer(UtilityLayerRenderer v);

    external Mesh get JS$_rootMesh;

    external set JS$_rootMesh(Mesh v);

    external get JS$_attachedMesh;

    external set JS$_attachedMesh(v);

    external num get scaleRatio;

    external set scaleRatio(num v);

    external get JS$_tmpMatrix;

    external set JS$_tmpMatrix(v);

    external bool get JS$_customMeshSet;

    external set JS$_customMeshSet(bool v);

    external AbstractMesh/*AbstractMesh|Null*/ get attachedMesh;

    external set attachedMesh(AbstractMesh/*AbstractMesh|Null*/ v);

    external void setCustomMesh(Mesh mesh);

    external bool get updateGizmoRotationToMatchAttachedMesh;

    external set updateGizmoRotationToMatchAttachedMesh(bool v);

    external bool get updateGizmoPositionToMatchAttachedMesh;

    external set updateGizmoPositionToMatchAttachedMesh(bool v);

    external bool get JS$_updateScale;

    external set JS$_updateScale(bool v);

    external bool get JS$_interactionsEnabled;

    external set JS$_interactionsEnabled(bool v);

    external void JS$_attachedMeshChanged(AbstractMesh/*AbstractMesh|Null*/ value);

    external get JS$_beforeRenderObserver;

    external set JS$_beforeRenderObserver(v);

    external factory Gizmo([UtilityLayerRenderer gizmoLayer]);

    external get JS$_tempVector;

    external set JS$_tempVector(v);

    external void JS$_update();

    external void dispose();
}

@JS("BABYLON.GizmoManager")
class GizmoManager implements IDisposable {
    // @Ignore
    GizmoManager .fakeConstructor$();

    external get scene;

    external set scene(v);

    external dynamic/*{
            positionGizmo: Nullable<PositionGizmo>;
            rotationGizmo: Nullable<RotationGizmo>;
            scaleGizmo: Nullable<ScaleGizmo>;
            boundingBoxGizmo: Nullable<BoundingBoxGizmo>;
        }*/ get gizmos;

    external set gizmos(dynamic/*{
            positionGizmo: Nullable<PositionGizmo>;
            rotationGizmo: Nullable<RotationGizmo>;
            scaleGizmo: Nullable<ScaleGizmo>;
            boundingBoxGizmo: Nullable<BoundingBoxGizmo>;
        }*/
    v);

    external get JS$_gizmosEnabled;

    external set JS$_gizmosEnabled(v);

    external get JS$_pointerObserver;

    external set JS$_pointerObserver(v);

    external get JS$_attachedMesh;

    external set JS$_attachedMesh(v);

    external get JS$_boundingBoxColor;

    external set JS$_boundingBoxColor(v);

    external get JS$_defaultUtilityLayer;

    external set JS$_defaultUtilityLayer(v);

    external get JS$_defaultKeepDepthUtilityLayer;

    external set JS$_defaultKeepDepthUtilityLayer(v);

    external SixDofDragBehavior get boundingBoxDragBehavior;

    external set boundingBoxDragBehavior(SixDofDragBehavior v);

    external List<AbstractMesh>/*List<AbstractMesh>|Null*/ get attachableMeshes;

    external set attachableMeshes(List<AbstractMesh>/*List<AbstractMesh>|Null*/ v);

    external bool get usePointerToAttachGizmos;

    external set usePointerToAttachGizmos(bool v);

    external factory GizmoManager(Scene scene);

    external void attachToMesh(AbstractMesh/*AbstractMesh|Null*/ mesh);

    external bool get positionGizmoEnabled;

    external set positionGizmoEnabled(bool v);

    external bool get rotationGizmoEnabled;

    external set rotationGizmoEnabled(bool v);

    external bool get scaleGizmoEnabled;

    external set scaleGizmoEnabled(bool v);

    external bool get boundingBoxGizmoEnabled;

    external set boundingBoxGizmoEnabled(bool v);

    external void dispose();
}

@JS("BABYLON.PlaneRotationGizmo")
class PlaneRotationGizmo extends Gizmo {
    // @Ignore
    PlaneRotationGizmo .fakeConstructor$() : super.fakeConstructor$();
    external PointerDragBehavior get dragBehavior;

    external set dragBehavior(PointerDragBehavior v);

    external get JS$_pointerObserver;

    external set JS$_pointerObserver(v);

    external num get snapDistance;

    external set snapDistance(num v);

    external Observable<dynamic /*{
            snapDistance: number;
        }*/> get onSnapObservable;

    external set onSnapObservable(Observable<dynamic /*{
            snapDistance: number;
        }*/> v);

    external factory PlaneRotationGizmo(Vector3 planeNormal, [Color3 color, UtilityLayerRenderer gizmoLayer, num tessellation]);

    external void JS$_attachedMeshChanged(AbstractMesh/*AbstractMesh|Null*/ value);

    external void dispose();
}

@JS("BABYLON.PositionGizmo")
class PositionGizmo extends Gizmo {
    // @Ignore
    PositionGizmo .fakeConstructor$() : super.fakeConstructor$();
    external AxisDragGizmo get xGizmo;

    external set xGizmo(AxisDragGizmo v);

    external AxisDragGizmo get yGizmo;

    external set yGizmo(AxisDragGizmo v);

    external AxisDragGizmo get zGizmo;

    external set zGizmo(AxisDragGizmo v);

    external Observable<dynamic /*{}*/> get onDragStartObservable;

    external set onDragStartObservable(Observable<dynamic /*{}*/> v);

    external Observable<dynamic /*{}*/> get onDragEndObservable;

    external set onDragEndObservable(Observable<dynamic /*{}*/> v);

    external AbstractMesh/*AbstractMesh|Null*/ get attachedMesh;

    external set attachedMesh(AbstractMesh/*AbstractMesh|Null*/ v);

    external factory PositionGizmo([UtilityLayerRenderer gizmoLayer]);

    external bool get updateGizmoRotationToMatchAttachedMesh;

    external set updateGizmoRotationToMatchAttachedMesh(bool v);

    external num get snapDistance;

    external set snapDistance(num v);

    external num get scaleRatio;

    external set scaleRatio(num v);

    external void dispose();

    external void setCustomMesh(Mesh mesh);
}

@JS("BABYLON.RotationGizmo")
class RotationGizmo extends Gizmo {
    // @Ignore
    RotationGizmo .fakeConstructor$() : super.fakeConstructor$();
    external PlaneRotationGizmo get xGizmo;

    external set xGizmo(PlaneRotationGizmo v);

    external PlaneRotationGizmo get yGizmo;

    external set yGizmo(PlaneRotationGizmo v);

    external PlaneRotationGizmo get zGizmo;

    external set zGizmo(PlaneRotationGizmo v);

    external Observable<dynamic /*{}*/> get onDragStartObservable;

    external set onDragStartObservable(Observable<dynamic /*{}*/> v);

    external Observable<dynamic /*{}*/> get onDragEndObservable;

    external set onDragEndObservable(Observable<dynamic /*{}*/> v);

    external AbstractMesh/*AbstractMesh|Null*/ get attachedMesh;

    external set attachedMesh(AbstractMesh/*AbstractMesh|Null*/ v);

    external factory RotationGizmo([UtilityLayerRenderer gizmoLayer, num tessellation]);

    external bool get updateGizmoRotationToMatchAttachedMesh;

    external set updateGizmoRotationToMatchAttachedMesh(bool v);

    external num get snapDistance;

    external set snapDistance(num v);

    external num get scaleRatio;

    external set scaleRatio(num v);

    external void dispose();

    external void setCustomMesh(Mesh mesh);
}

@JS("BABYLON.ScaleGizmo")
class ScaleGizmo extends Gizmo {
    // @Ignore
    ScaleGizmo .fakeConstructor$() : super.fakeConstructor$();
    external AxisScaleGizmo get xGizmo;

    external set xGizmo(AxisScaleGizmo v);

    external AxisScaleGizmo get yGizmo;

    external set yGizmo(AxisScaleGizmo v);

    external AxisScaleGizmo get zGizmo;

    external set zGizmo(AxisScaleGizmo v);

    external AxisScaleGizmo get uniformScaleGizmo;

    external set uniformScaleGizmo(AxisScaleGizmo v);

    external Observable<dynamic /*{}*/> get onDragStartObservable;

    external set onDragStartObservable(Observable<dynamic /*{}*/> v);

    external Observable<dynamic /*{}*/> get onDragEndObservable;

    external set onDragEndObservable(Observable<dynamic /*{}*/> v);

    external AbstractMesh/*AbstractMesh|Null*/ get attachedMesh;

    external set attachedMesh(AbstractMesh/*AbstractMesh|Null*/ v);

    external factory ScaleGizmo([UtilityLayerRenderer gizmoLayer]);

    external bool get updateGizmoRotationToMatchAttachedMesh;

    external set updateGizmoRotationToMatchAttachedMesh(bool v);

    external num get snapDistance;

    external set snapDistance(num v);

    external num get scaleRatio;

    external set scaleRatio(num v);

    external void dispose();
}

@JS("BABYLON.EngineInstrumentation")
class EngineInstrumentation implements IDisposable {
    // @Ignore
    EngineInstrumentation .fakeConstructor$();

    external Engine get engine;

    external set engine(Engine v);

    external get JS$_captureGPUFrameTime;

    external set JS$_captureGPUFrameTime(v);

    external get JS$_gpuFrameTimeToken;

    external set JS$_gpuFrameTimeToken(v);

    external get JS$_gpuFrameTime;

    external set JS$_gpuFrameTime(v);

    external get JS$_captureShaderCompilationTime;

    external set JS$_captureShaderCompilationTime(v);

    external get JS$_shaderCompilationTime;

    external set JS$_shaderCompilationTime(v);

    external get JS$_onBeginFrameObserver;

    external set JS$_onBeginFrameObserver(v);

    external get JS$_onEndFrameObserver;

    external set JS$_onEndFrameObserver(v);

    external get JS$_onBeforeShaderCompilationObserver;

    external set JS$_onBeforeShaderCompilationObserver(v);

    external get JS$_onAfterShaderCompilationObserver;

    external set JS$_onAfterShaderCompilationObserver(v);

    external PerfCounter get gpuFrameTimeCounter;

    external set gpuFrameTimeCounter(PerfCounter v);

    external bool get captureGPUFrameTime;

    external set captureGPUFrameTime(bool v);

    external PerfCounter get shaderCompilationTimeCounter;

    external set shaderCompilationTimeCounter(PerfCounter v);

    external bool get captureShaderCompilationTime;

    external set captureShaderCompilationTime(bool v);

    external factory EngineInstrumentation(Engine engine);

    external void dispose();
}

@JS("BABYLON.SceneInstrumentation")
class SceneInstrumentation implements IDisposable {
    // @Ignore
    SceneInstrumentation .fakeConstructor$();

    external Scene get scene;

    external set scene(Scene v);

    external get JS$_captureActiveMeshesEvaluationTime;

    external set JS$_captureActiveMeshesEvaluationTime(v);

    external get JS$_activeMeshesEvaluationTime;

    external set JS$_activeMeshesEvaluationTime(v);

    external get JS$_captureRenderTargetsRenderTime;

    external set JS$_captureRenderTargetsRenderTime(v);

    external get JS$_renderTargetsRenderTime;

    external set JS$_renderTargetsRenderTime(v);

    external get JS$_captureFrameTime;

    external set JS$_captureFrameTime(v);

    external get JS$_frameTime;

    external set JS$_frameTime(v);

    external get JS$_captureRenderTime;

    external set JS$_captureRenderTime(v);

    external get JS$_renderTime;

    external set JS$_renderTime(v);

    external get JS$_captureInterFrameTime;

    external set JS$_captureInterFrameTime(v);

    external get JS$_interFrameTime;

    external set JS$_interFrameTime(v);

    external get JS$_captureParticlesRenderTime;

    external set JS$_captureParticlesRenderTime(v);

    external get JS$_particlesRenderTime;

    external set JS$_particlesRenderTime(v);

    external get JS$_captureSpritesRenderTime;

    external set JS$_captureSpritesRenderTime(v);

    external get JS$_spritesRenderTime;

    external set JS$_spritesRenderTime(v);

    external get JS$_capturePhysicsTime;

    external set JS$_capturePhysicsTime(v);

    external get JS$_physicsTime;

    external set JS$_physicsTime(v);

    external get JS$_captureAnimationsTime;

    external set JS$_captureAnimationsTime(v);

    external get JS$_animationsTime;

    external set JS$_animationsTime(v);

    external get JS$_captureCameraRenderTime;

    external set JS$_captureCameraRenderTime(v);

    external get JS$_cameraRenderTime;

    external set JS$_cameraRenderTime(v);

    external get JS$_onBeforeActiveMeshesEvaluationObserver;

    external set JS$_onBeforeActiveMeshesEvaluationObserver(v);

    external get JS$_onAfterActiveMeshesEvaluationObserver;

    external set JS$_onAfterActiveMeshesEvaluationObserver(v);

    external get JS$_onBeforeRenderTargetsRenderObserver;

    external set JS$_onBeforeRenderTargetsRenderObserver(v);

    external get JS$_onAfterRenderTargetsRenderObserver;

    external set JS$_onAfterRenderTargetsRenderObserver(v);

    external get JS$_onAfterRenderObserver;

    external set JS$_onAfterRenderObserver(v);

    external get JS$_onBeforeDrawPhaseObserver;

    external set JS$_onBeforeDrawPhaseObserver(v);

    external get JS$_onAfterDrawPhaseObserver;

    external set JS$_onAfterDrawPhaseObserver(v);

    external get JS$_onBeforeAnimationsObserver;

    external set JS$_onBeforeAnimationsObserver(v);

    external get JS$_onBeforeParticlesRenderingObserver;

    external set JS$_onBeforeParticlesRenderingObserver(v);

    external get JS$_onAfterParticlesRenderingObserver;

    external set JS$_onAfterParticlesRenderingObserver(v);

    external get JS$_onBeforeSpritesRenderingObserver;

    external set JS$_onBeforeSpritesRenderingObserver(v);

    external get JS$_onAfterSpritesRenderingObserver;

    external set JS$_onAfterSpritesRenderingObserver(v);

    external get JS$_onBeforePhysicsObserver;

    external set JS$_onBeforePhysicsObserver(v);

    external get JS$_onAfterPhysicsObserver;

    external set JS$_onAfterPhysicsObserver(v);

    external get JS$_onAfterAnimationsObserver;

    external set JS$_onAfterAnimationsObserver(v);

    external get JS$_onBeforeCameraRenderObserver;

    external set JS$_onBeforeCameraRenderObserver(v);

    external get JS$_onAfterCameraRenderObserver;

    external set JS$_onAfterCameraRenderObserver(v);

    external PerfCounter get activeMeshesEvaluationTimeCounter;

    external set activeMeshesEvaluationTimeCounter(PerfCounter v);

    external bool get captureActiveMeshesEvaluationTime;

    external set captureActiveMeshesEvaluationTime(bool v);

    external PerfCounter get renderTargetsRenderTimeCounter;

    external set renderTargetsRenderTimeCounter(PerfCounter v);

    external bool get captureRenderTargetsRenderTime;

    external set captureRenderTargetsRenderTime(bool v);

    external PerfCounter get particlesRenderTimeCounter;

    external set particlesRenderTimeCounter(PerfCounter v);

    external bool get captureParticlesRenderTime;

    external set captureParticlesRenderTime(bool v);

    external PerfCounter get spritesRenderTimeCounter;

    external set spritesRenderTimeCounter(PerfCounter v);

    external bool get captureSpritesRenderTime;

    external set captureSpritesRenderTime(bool v);

    external PerfCounter get physicsTimeCounter;

    external set physicsTimeCounter(PerfCounter v);

    external bool get capturePhysicsTime;

    external set capturePhysicsTime(bool v);

    external PerfCounter get animationsTimeCounter;

    external set animationsTimeCounter(PerfCounter v);

    external bool get captureAnimationsTime;

    external set captureAnimationsTime(bool v);

    external PerfCounter get frameTimeCounter;

    external set frameTimeCounter(PerfCounter v);

    external bool get captureFrameTime;

    external set captureFrameTime(bool v);

    external PerfCounter get interFrameTimeCounter;

    external set interFrameTimeCounter(PerfCounter v);

    external bool get captureInterFrameTime;

    external set captureInterFrameTime(bool v);

    external PerfCounter get renderTimeCounter;

    external set renderTimeCounter(PerfCounter v);

    external bool get captureRenderTime;

    external set captureRenderTime(bool v);

    external PerfCounter get cameraRenderTimeCounter;

    external set cameraRenderTimeCounter(PerfCounter v);

    external bool get captureCameraRenderTime;

    external set captureCameraRenderTime(bool v);

    external PerfCounter get drawCallsCounter;

    external set drawCallsCounter(PerfCounter v);

    external PerfCounter get textureCollisionsCounter;

    external set textureCollisionsCounter(PerfCounter v);

    external factory SceneInstrumentation(Scene scene);

    external void dispose();
}

@JS("BABYLON._TimeToken")
class JS$_TimeToken {
    // @Ignore
    JS$_TimeToken .fakeConstructor$();

    external WebGLQuery/*WebGLQuery|Null*/ get JS$_startTimeQuery;

    external set JS$_startTimeQuery(WebGLQuery/*WebGLQuery|Null*/ v);

    external WebGLQuery/*WebGLQuery|Null*/ get JS$_endTimeQuery;

    external set JS$_endTimeQuery(WebGLQuery/*WebGLQuery|Null*/ v);

    external WebGLQuery/*WebGLQuery|Null*/ get JS$_timeElapsedQuery;

    external set JS$_timeElapsedQuery(WebGLQuery/*WebGLQuery|Null*/ v);

    external bool get JS$_timeElapsedQueryEnded;

    external set JS$_timeElapsedQueryEnded(bool v);
}

@anonymous
@JS()
abstract class IEnvironmentHelperOptions {
    external bool get createGround;

    external set createGround(bool v);

    external num get groundSize;

    external set groundSize(num v);

    external dynamic/*String|BaseTexture*/ get groundTexture;

    external set groundTexture(dynamic/*String|BaseTexture*/ v);

    external Color3 get groundColor;

    external set groundColor(Color3 v);

    external num get groundOpacity;

    external set groundOpacity(num v);

    external bool get enableGroundShadow;

    external set enableGroundShadow(bool v);

    external num get groundShadowLevel;

    external set groundShadowLevel(num v);

    external bool get enableGroundMirror;

    external set enableGroundMirror(bool v);

    external num get groundMirrorSizeRatio;

    external set groundMirrorSizeRatio(num v);

    external num get groundMirrorBlurKernel;

    external set groundMirrorBlurKernel(num v);

    external num get groundMirrorAmount;

    external set groundMirrorAmount(num v);

    external num get groundMirrorFresnelWeight;

    external set groundMirrorFresnelWeight(num v);

    external num get groundMirrorFallOffDistance;

    external set groundMirrorFallOffDistance(num v);

    external num get groundMirrorTextureType;

    external set groundMirrorTextureType(num v);

    external num get groundYBias;

    external set groundYBias(num v);

    external bool get createSkybox;

    external set createSkybox(bool v);

    external num get skyboxSize;

    external set skyboxSize(num v);

    external dynamic/*String|BaseTexture*/ get skyboxTexture;

    external set skyboxTexture(dynamic/*String|BaseTexture*/ v);

    external Color3 get skyboxColor;

    external set skyboxColor(Color3 v);

    external num get backgroundYRotation;

    external set backgroundYRotation(num v);

    external bool get sizeAuto;

    external set sizeAuto(bool v);

    external Vector3 get rootPosition;

    external set rootPosition(Vector3 v);

    external bool get setupImageProcessing;

    external set setupImageProcessing(bool v);

    external dynamic/*String|BaseTexture*/ get environmentTexture;

    external set environmentTexture(dynamic/*String|BaseTexture*/ v);

    external num get cameraExposure;

    external set cameraExposure(num v);

    external num get cameraContrast;

    external set cameraContrast(num v);

    external bool get toneMappingEnabled;

    external set toneMappingEnabled(bool v);

    external factory IEnvironmentHelperOptions({ bool createGround, num groundSize, dynamic/*String|BaseTexture*/ groundTexture, Color3 groundColor, num groundOpacity, bool enableGroundShadow, num groundShadowLevel, bool enableGroundMirror, num groundMirrorSizeRatio, num groundMirrorBlurKernel, num groundMirrorAmount, num groundMirrorFresnelWeight, num groundMirrorFallOffDistance, num groundMirrorTextureType, num groundYBias, bool createSkybox, num skyboxSize, dynamic/*String|BaseTexture*/ skyboxTexture, Color3 skyboxColor, num backgroundYRotation, bool sizeAuto, Vector3 rootPosition, bool setupImageProcessing, dynamic/*String|BaseTexture*/ environmentTexture, num cameraExposure, num cameraContrast, bool toneMappingEnabled});
}

@JS("BABYLON.EnvironmentHelper")
class EnvironmentHelper {
    // @Ignore
    EnvironmentHelper .fakeConstructor$();

    external static get JS$_groundTextureCDNUrl;

    external static set JS$_groundTextureCDNUrl(v);

    external static get JS$_skyboxTextureCDNUrl;

    external static set JS$_skyboxTextureCDNUrl(v);

    external static get JS$_environmentTextureCDNUrl;

    external static set JS$_environmentTextureCDNUrl(v);

    external static get JS$_getDefaultOptions;

    external static set JS$_getDefaultOptions(v);

    external get JS$_rootMesh;

    external set JS$_rootMesh(v);

    external Mesh get rootMesh;

    external set rootMesh(Mesh v);

    external get JS$_skybox;

    external set JS$_skybox(v);

    external Mesh/*Mesh|Null*/ get skybox;

    external set skybox(Mesh/*Mesh|Null*/ v);

    external get JS$_skyboxTexture;

    external set JS$_skyboxTexture(v);

    external BaseTexture/*BaseTexture|Null*/ get skyboxTexture;

    external set skyboxTexture(BaseTexture/*BaseTexture|Null*/ v);

    external get JS$_skyboxMaterial;

    external set JS$_skyboxMaterial(v);

    external BackgroundMaterial/*BackgroundMaterial|Null*/ get skyboxMaterial;

    external set skyboxMaterial(BackgroundMaterial/*BackgroundMaterial|Null*/ v);

    external get JS$_ground;

    external set JS$_ground(v);

    external Mesh/*Mesh|Null*/ get ground;

    external set ground(Mesh/*Mesh|Null*/ v);

    external get JS$_groundTexture;

    external set JS$_groundTexture(v);

    external BaseTexture/*BaseTexture|Null*/ get groundTexture;

    external set groundTexture(BaseTexture/*BaseTexture|Null*/ v);

    external get JS$_groundMirror;

    external set JS$_groundMirror(v);

    external MirrorTexture/*MirrorTexture|Null*/ get groundMirror;

    external set groundMirror(MirrorTexture/*MirrorTexture|Null*/ v);

    external List<AbstractMesh>/*List<AbstractMesh>|Null*/ get groundMirrorRenderList;

    external set groundMirrorRenderList(List<AbstractMesh>/*List<AbstractMesh>|Null*/ v);

    external get JS$_groundMaterial;

    external set JS$_groundMaterial(v);

    external BackgroundMaterial/*BackgroundMaterial|Null*/ get groundMaterial;

    external set groundMaterial(BackgroundMaterial/*BackgroundMaterial|Null*/ v);

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_options;

    external set JS$_options(v);

    external Observable<dynamic /*{
            message?: string;
            exception?: any;
        }*/> get onErrorObservable;

    external set onErrorObservable(Observable<dynamic /*{
            message?: string;
            exception?: any;
        }*/> v);

    external factory EnvironmentHelper(Partial<IEnvironmentHelperOptions> options, Scene scene);

    external void updateOptions(Partial<IEnvironmentHelperOptions> options);

    external void setMainColor(Color3 color);

    external get JS$_setupImageProcessing;

    external set JS$_setupImageProcessing(v);

    external get JS$_setupEnvironmentTexture;

    external set JS$_setupEnvironmentTexture(v);

    external get JS$_setupBackground;

    external set JS$_setupBackground(v);

    external get JS$_getSceneSize;

    external set JS$_getSceneSize(v);

    external get JS$_setupGround;

    external set JS$_setupGround(v);

    external get JS$_setupGroundMaterial;

    external set JS$_setupGroundMaterial(v);

    external get JS$_setupGroundDiffuseTexture;

    external set JS$_setupGroundDiffuseTexture(v);

    external get JS$_setupGroundMirrorTexture;

    external set JS$_setupGroundMirrorTexture(v);

    external get JS$_setupMirrorInGroundMaterial;

    external set JS$_setupMirrorInGroundMaterial(v);

    external get JS$_setupSkybox;

    external set JS$_setupSkybox(v);

    external get JS$_setupSkyboxMaterial;

    external set JS$_setupSkyboxMaterial(v);

    external get JS$_setupSkyboxReflectionTexture;

    external set JS$_setupSkyboxReflectionTexture(v);

    external get JS$_errorHandler;

    external set JS$_errorHandler(v);

    external void dispose();
}

@JS("BABYLON.PhotoDome")
class PhotoDome extends TransformNode {
    // @Ignore
    PhotoDome .fakeConstructor$() : super.fakeConstructor$();
    external get JS$_useDirectMapping;

    external set JS$_useDirectMapping(v);

    external Texture get JS$_photoTexture;

    external set JS$_photoTexture(Texture v);

    external Texture get photoTexture;

    external set photoTexture(Texture v);

    external Observable<String> get onLoadErrorObservable;

    external set onLoadErrorObservable(Observable<String> v);

    external BackgroundMaterial get JS$_material;

    external set JS$_material(BackgroundMaterial v);

    external Mesh get JS$_mesh;

    external set JS$_mesh(Mesh v);

    external num get fovMultiplier;

    external set fovMultiplier(num v);

    external factory PhotoDome(String name, String urlOfPhoto, dynamic/*{
            resolution?: number;
            size?: number;
            useDirectMapping?: boolean;
        }*/
    options, Scene scene, [Function/*(message?: string, exception?: any) => void|Null*/ onError]);

    external void dispose([bool doNotRecurse, bool disposeMaterialAndTextures]);
}

@anonymous
@JS()
abstract class Scene {
    external void createDefaultLight([bool replace]);

    external void createDefaultCamera([bool createArcRotateCamera, bool replace, bool attachCameraControls]);

    external void createDefaultCameraOrLight([bool createArcRotateCamera, bool replace, bool attachCameraControls]);

    external Mesh/*Mesh|Null*/ createDefaultSkybox([BaseTexture environmentTexture, bool pbr, num scale, num blur, bool setGlobalEnvTexture]);

    external EnvironmentHelper/*EnvironmentHelper|Null*/ createDefaultEnvironment([Partial<IEnvironmentHelperOptions> options]);

    external VRExperienceHelper createDefaultVRExperience([VRExperienceHelperOptions webVROptions]);
}

@JS("BABYLON.VideoDome")
class VideoDome extends TransformNode {
    // @Ignore
    VideoDome .fakeConstructor$() : super.fakeConstructor$();
    external get JS$_useDirectMapping;

    external set JS$_useDirectMapping(v);

    external VideoTexture get JS$_videoTexture;

    external set JS$_videoTexture(VideoTexture v);

    external VideoTexture get videoTexture;

    external set videoTexture(VideoTexture v);

    external BackgroundMaterial get JS$_material;

    external set JS$_material(BackgroundMaterial v);

    external Mesh get JS$_mesh;

    external set JS$_mesh(Mesh v);

    external num get fovMultiplier;

    external set fovMultiplier(num v);

    external factory VideoDome(String name, dynamic/*String|List<String>|VideoElement*/ urlsOrVideo, dynamic/*{
            resolution?: number;
            clickToPlay?: boolean;
            autoPlay?: boolean;
            loop?: boolean;
            size?: number;
            poster?: string;
            useDirectMapping?: boolean;
        }*/
    options, Scene scene);

    external void dispose([bool doNotRecurse, bool disposeMaterialAndTextures]);
}

@anonymous
@JS()
abstract class IEffectLayerOptions {
    external num get mainTextureRatio;

    external set mainTextureRatio(num v);

    external num get mainTextureFixedSize;

    external set mainTextureFixedSize(num v);

    external num get alphaBlendingMode;

    external set alphaBlendingMode(num v);

    external Camera/*Camera|Null*/ get camera;

    external set camera(Camera/*Camera|Null*/ v);

    external num get renderingGroupId;

    external set renderingGroupId(num v);

    external factory IEffectLayerOptions({ num mainTextureRatio, num mainTextureFixedSize, num alphaBlendingMode, Camera/*Camera|Null*/ camera, num renderingGroupId});
}

@JS("BABYLON.EffectLayer")
abstract class EffectLayer {
    // @Ignore
    EffectLayer .fakeConstructor$();

    external get JS$_vertexBuffers;

    external set JS$_vertexBuffers(v);

    external get JS$_indexBuffer;

    external set JS$_indexBuffer(v);

    external get JS$_cachedDefines;

    external set JS$_cachedDefines(v);

    external get JS$_effectLayerMapGenerationEffect;

    external set JS$_effectLayerMapGenerationEffect(v);

    external get JS$_effectLayerOptions;

    external set JS$_effectLayerOptions(v);

    external get JS$_mergeEffect;

    external set JS$_mergeEffect(v);

    external Scene get JS$_scene;

    external set JS$_scene(Scene v);

    external Engine get JS$_engine;

    external set JS$_engine(Engine v);

    external num get JS$_maxSize;

    external set JS$_maxSize(num v);

    external ISize get JS$_mainTextureDesiredSize;

    external set JS$_mainTextureDesiredSize(ISize v);

    external RenderTargetTexture get JS$_mainTexture;

    external set JS$_mainTexture(RenderTargetTexture v);

    external bool get JS$_shouldRender;

    external set JS$_shouldRender(bool v);

    external List<PostProcess> get JS$_postProcesses;

    external set JS$_postProcesses(List<PostProcess> v);

    external List<BaseTexture> get JS$_textures;

    external set JS$_textures(List<BaseTexture> v);

    external dynamic/*{
            texture: Nullable<BaseTexture>;
            color: Color4;
        }*/ get JS$_emissiveTextureAndColor;

    external set JS$_emissiveTextureAndColor(dynamic/*{
            texture: Nullable<BaseTexture>;
            color: Color4;
        }*/
    v);

    external String get name;

    external set name(String v);

    external Color4 get neutralColor;

    external set neutralColor(Color4 v);

    external bool get isEnabled;

    external set isEnabled(bool v);

    external Camera/*Camera|Null*/ get camera;

    external set camera(Camera/*Camera|Null*/ v);

    external num get renderingGroupId;

    external set renderingGroupId(num v);

    external Observable<EffectLayer> get onDisposeObservable;

    external set onDisposeObservable(Observable<EffectLayer> v);

    external Observable<EffectLayer> get onBeforeRenderMainTextureObservable;

    external set onBeforeRenderMainTextureObservable(Observable<EffectLayer> v);

    external Observable<EffectLayer> get onBeforeComposeObservable;

    external set onBeforeComposeObservable(Observable<EffectLayer> v);

    external Observable<EffectLayer> get onAfterComposeObservable;

    external set onAfterComposeObservable(Observable<EffectLayer> v);

    external Observable<EffectLayer> get onSizeChangedObservable;

    external set onSizeChangedObservable(Observable<EffectLayer> v);

    external factory EffectLayer(String name, Scene scene);

    external String getEffectName();

    external bool isReady(SubMesh subMesh, bool useInstances);

    external bool needStencil();

    external Effect JS$_createMergeEffect();

    external void JS$_createTextureAndPostProcesses();

    external void JS$_internalRender(Effect effect);

    external void JS$_setEmissiveTextureAndColor(Mesh mesh, SubMesh subMesh, Material material);

    external void JS$_disposeMesh(Mesh mesh);

    external dynamic serialize();

    external void JS$_init(Partial<IEffectLayerOptions> options);

    external get JS$_generateIndexBuffer;

    external set JS$_generateIndexBuffer(v);

    external get JS$_genrateVertexBuffer;

    external set JS$_genrateVertexBuffer(v);

    external get JS$_setMainTextureSize;

    external set JS$_setMainTextureSize(v);

    external void JS$_createMainTexture();

    external bool JS$_isReady(SubMesh subMesh, bool useInstances, BaseTexture/*BaseTexture|Null*/ emissiveTexture);

    external void render();

    external bool hasMesh(AbstractMesh mesh);

    external bool shouldRender();

    external bool JS$_shouldRenderMesh(Mesh mesh);

    external bool JS$_shouldRenderEmissiveTextureForMesh(Mesh mesh);

    external void JS$_renderSubMesh(SubMesh subMesh);

    external void JS$_rebuild();

    external get JS$_disposeTextureAndPostProcesses;

    external set JS$_disposeTextureAndPostProcesses(v);

    external void dispose();

    external String getClassName();

    external static EffectLayer Parse(dynamic parsedEffectLayer, Scene scene, String rootUrl);
}

@anonymous
@JS()
abstract class AbstractScene {
    external List<EffectLayer> get effectLayers;

    external set effectLayers(List<EffectLayer> v);

    external num removeEffectLayer(EffectLayer toRemove);

    external void addEffectLayer(EffectLayer newEffectLayer);
}

@JS("BABYLON.EffectLayerSceneComponent")
class EffectLayerSceneComponent implements ISceneSerializableComponent {
    // @Ignore
    EffectLayerSceneComponent .fakeConstructor$();

    external String get name;

    external set name(String v);

    external Scene get scene;

    external set scene(Scene v);

    external get JS$_engine;

    external set JS$_engine(v);

    external get JS$_renderEffects;

    external set JS$_renderEffects(v);

    external get JS$_needStencil;

    external set JS$_needStencil(v);

    external get JS$_previousStencilState;

    external set JS$_previousStencilState(v);

    external factory EffectLayerSceneComponent(Scene scene);

    external void register();

    external void rebuild();

    external void serialize(dynamic serializationObject);

    external void addFromContainer(AbstractScene container);

    external void removeFromContainer(AbstractScene container);

    external void dispose();

    external get JS$_isReadyForMesh;

    external set JS$_isReadyForMesh(v);

    external get JS$_renderMainTexture;

    external set JS$_renderMainTexture(v);

    external get JS$_setStencil;

    external set JS$_setStencil(v);

    external get JS$_setStencilBack;

    external set JS$_setStencilBack(v);

    external get JS$_draw;

    external set JS$_draw(v);

    external get JS$_drawCamera;

    external set JS$_drawCamera(v);

    external get JS$_drawRenderingGroup;

    external set JS$_drawRenderingGroup(v);
}

@anonymous
@JS()
abstract class AbstractScene {
    external GlowLayer/*GlowLayer|Null*/ getGlowLayerByName(String name);
}

@anonymous
@JS()
abstract class IGlowLayerOptions {
    external num get mainTextureRatio;

    external set mainTextureRatio(num v);

    external num get mainTextureFixedSize;

    external set mainTextureFixedSize(num v);

    external num get blurKernelSize;

    external set blurKernelSize(num v);

    external Camera/*Camera|Null*/ get camera;

    external set camera(Camera/*Camera|Null*/ v);

    external num get mainTextureSamples;

    external set mainTextureSamples(num v);

    external num get renderingGroupId;

    external set renderingGroupId(num v);

    external factory IGlowLayerOptions({ num mainTextureRatio, num mainTextureFixedSize, num blurKernelSize, Camera/*Camera|Null*/ camera, num mainTextureSamples, num renderingGroupId});
}

@JS("BABYLON.GlowLayer")
class GlowLayer extends EffectLayer {
    // @Ignore
    GlowLayer .fakeConstructor$() : super.fakeConstructor$();
    external static String get EffectName;

    external static set EffectName(String v);

    external static num get DefaultBlurKernelSize;

    external static set DefaultBlurKernelSize(num v);

    external static num get DefaultTextureRatio;

    external static set DefaultTextureRatio(num v);

    external num get blurKernelSize;

    external set blurKernelSize(num v);

    external num get intensity;

    external set intensity(num v);

    external get JS$_options;

    external set JS$_options(v);

    external get JS$_intensity;

    external set JS$_intensity(v);

    external get JS$_horizontalBlurPostprocess1;

    external set JS$_horizontalBlurPostprocess1(v);

    external get JS$_verticalBlurPostprocess1;

    external set JS$_verticalBlurPostprocess1(v);

    external get JS$_horizontalBlurPostprocess2;

    external set JS$_horizontalBlurPostprocess2(v);

    external get JS$_verticalBlurPostprocess2;

    external set JS$_verticalBlurPostprocess2(v);

    external get JS$_blurTexture1;

    external set JS$_blurTexture1(v);

    external get JS$_blurTexture2;

    external set JS$_blurTexture2(v);

    external get JS$_postProcesses1;

    external set JS$_postProcesses1(v);

    external get JS$_postProcesses2;

    external set JS$_postProcesses2(v);

    external get JS$_includedOnlyMeshes;

    external set JS$_includedOnlyMeshes(v);

    external get JS$_excludedMeshes;

    external set JS$_excludedMeshes(v);

    external VoidFunc4<Mesh, SubMesh, Material, Color4> get customEmissiveColorSelector;

    external set customEmissiveColorSelector(VoidFunc4<Mesh, SubMesh, Material, Color4> v);

    external Func3<Mesh, SubMesh, Material, Texture> get customEmissiveTextureSelector;

    external set customEmissiveTextureSelector(Func3<Mesh, SubMesh, Material, Texture> v);

    external factory GlowLayer(String name, Scene scene, [Partial<IGlowLayerOptions> options]);

    external String getEffectName();

    external Effect JS$_createMergeEffect();

    external void JS$_createTextureAndPostProcesses();

    external bool isReady(SubMesh subMesh, bool useInstances);

    external bool needStencil();

    external void JS$_internalRender(Effect effect);

    external void JS$_setEmissiveTextureAndColor(Mesh mesh, SubMesh subMesh, Material material);

    external bool JS$_shouldRenderMesh(Mesh mesh);

    external void addExcludedMesh(Mesh mesh);

    external void removeExcludedMesh(Mesh mesh);

    external void addIncludedOnlyMesh(Mesh mesh);

    external void removeIncludedOnlyMesh(Mesh mesh);

    external bool hasMesh(AbstractMesh mesh);

    external void JS$_disposeMesh(Mesh mesh);

    external String getClassName();

    external dynamic serialize();

    external static GlowLayer Parse(dynamic parsedGlowLayer, Scene scene, String rootUrl);
}

@anonymous
@JS()
abstract class AbstractScene {
    external HighlightLayer/*HighlightLayer|Null*/ getHighlightLayerByName(String name);
}

@anonymous
@JS()
abstract class IHighlightLayerOptions {
    external num get mainTextureRatio;

    external set mainTextureRatio(num v);

    external num get mainTextureFixedSize;

    external set mainTextureFixedSize(num v);

    external num get blurTextureSizeRatio;

    external set blurTextureSizeRatio(num v);

    external num get blurVerticalSize;

    external set blurVerticalSize(num v);

    external num get blurHorizontalSize;

    external set blurHorizontalSize(num v);

    external num get alphaBlendingMode;

    external set alphaBlendingMode(num v);

    external Camera/*Camera|Null*/ get camera;

    external set camera(Camera/*Camera|Null*/ v);

    external bool get isStroke;

    external set isStroke(bool v);

    external num get renderingGroupId;

    external set renderingGroupId(num v);

    external factory IHighlightLayerOptions({ num mainTextureRatio, num mainTextureFixedSize, num blurTextureSizeRatio, num blurVerticalSize, num blurHorizontalSize, num alphaBlendingMode, Camera/*Camera|Null*/ camera, bool isStroke, num renderingGroupId});
}

@JS("BABYLON.HighlightLayer")
class HighlightLayer extends EffectLayer {
    // @Ignore
    HighlightLayer .fakeConstructor$() : super.fakeConstructor$();
    external String get name;

    external set name(String v);

    external static String get EffectName;

    external static set EffectName(String v);

    external static Color4 get NeutralColor;

    external static set NeutralColor(Color4 v);

    external static num get GlowingMeshStencilReference;

    external static set GlowingMeshStencilReference(num v);

    external static num get NormalMeshStencilReference;

    external static set NormalMeshStencilReference(num v);

    external bool get innerGlow;

    external set innerGlow(bool v);

    external bool get outerGlow;

    external set outerGlow(bool v);

    external num get blurHorizontalSize;

    external set blurHorizontalSize(num v);

    external num get blurVerticalSize;

    external set blurVerticalSize(num v);

    external Observable<HighlightLayer> get onBeforeBlurObservable;

    external set onBeforeBlurObservable(Observable<HighlightLayer> v);

    external Observable<HighlightLayer> get onAfterBlurObservable;

    external set onAfterBlurObservable(Observable<HighlightLayer> v);

    external get JS$_instanceGlowingMeshStencilReference;

    external set JS$_instanceGlowingMeshStencilReference(v);

    external get JS$_options;

    external set JS$_options(v);

    external get JS$_downSamplePostprocess;

    external set JS$_downSamplePostprocess(v);

    external get JS$_horizontalBlurPostprocess;

    external set JS$_horizontalBlurPostprocess(v);

    external get JS$_verticalBlurPostprocess;

    external set JS$_verticalBlurPostprocess(v);

    external get JS$_blurTexture;

    external set JS$_blurTexture(v);

    external get JS$_meshes;

    external set JS$_meshes(v);

    external get JS$_excludedMeshes;

    external set JS$_excludedMeshes(v);

    external factory HighlightLayer(String name, Scene scene, [Partial<IHighlightLayerOptions> options]);

    external String getEffectName();

    external Effect JS$_createMergeEffect();

    external void JS$_createTextureAndPostProcesses();

    external bool needStencil();

    external bool isReady(SubMesh subMesh, bool useInstances);

    external void JS$_internalRender(Effect effect);

    external bool shouldRender();

    external bool JS$_shouldRenderMesh(Mesh mesh);

    external void JS$_setEmissiveTextureAndColor(Mesh mesh, SubMesh subMesh, Material material);

    external void addExcludedMesh(Mesh mesh);

    external void removeExcludedMesh(Mesh mesh);

    external bool hasMesh(AbstractMesh mesh);

    external void addMesh(Mesh mesh, Color3 color, [bool glowEmissiveOnly]);

    external void removeMesh(Mesh mesh);

    external get JS$_defaultStencilReference;

    external set JS$_defaultStencilReference(v);

    external void JS$_disposeMesh(Mesh mesh);

    external void dispose();

    external String getClassName();

    external dynamic serialize();

    external static HighlightLayer Parse(dynamic parsedHightlightLayer, Scene scene, String rootUrl);
}

@JS("BABYLON.Layer")
class Layer {
    // @Ignore
    Layer .fakeConstructor$();

    external String get name;

    external set name(String v);

    external Texture/*Texture|Null*/ get texture;

    external set texture(Texture/*Texture|Null*/ v);

    external bool get isBackground;

    external set isBackground(bool v);

    external Color4 get color;

    external set color(Color4 v);

    external Vector2 get scale;

    external set scale(Vector2 v);

    external Vector2 get offset;

    external set offset(Vector2 v);

    external num get alphaBlendingMode;

    external set alphaBlendingMode(num v);

    external bool get alphaTest;

    external set alphaTest(bool v);

    external num get layerMask;

    external set layerMask(num v);

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_vertexBuffers;

    external set JS$_vertexBuffers(v);

    external get JS$_indexBuffer;

    external set JS$_indexBuffer(v);

    external get JS$_effect;

    external set JS$_effect(v);

    external get JS$_alphaTestEffect;

    external set JS$_alphaTestEffect(v);

    external Observable<Layer> get onDisposeObservable;

    external set onDisposeObservable(Observable<Layer> v);

    external get JS$_onDisposeObserver;

    external set JS$_onDisposeObserver(v);

    external VoidFunc0 get onDispose;

    external set onDispose(VoidFunc0 v);

    external Observable<Layer> get onBeforeRenderObservable;

    external set onBeforeRenderObservable(Observable<Layer> v);

    external get JS$_onBeforeRenderObserver;

    external set JS$_onBeforeRenderObserver(v);

    external VoidFunc0 get onBeforeRender;

    external set onBeforeRender(VoidFunc0 v);

    external Observable<Layer> get onAfterRenderObservable;

    external set onAfterRenderObservable(Observable<Layer> v);

    external get JS$_onAfterRenderObserver;

    external set JS$_onAfterRenderObserver(v);

    external VoidFunc0 get onAfterRender;

    external set onAfterRender(VoidFunc0 v);

    external factory Layer(String name, String/*String|Null*/ imgUrl, Scene/*Scene|Null*/ scene, [bool isBackground, Color4 color]);

    external get JS$_createIndexBuffer;

    external set JS$_createIndexBuffer(v);

    external void JS$_rebuild();

    external void render();

    external void dispose();
}

@JS("BABYLON.LayerSceneComponent")
class LayerSceneComponent implements ISceneComponent {
    // @Ignore
    LayerSceneComponent .fakeConstructor$();

    external String get name;

    external set name(String v);

    external Scene get scene;

    external set scene(Scene v);

    external get JS$_engine;

    external set JS$_engine(v);

    external factory LayerSceneComponent(Scene scene);

    external void register();

    external void rebuild();

    external void dispose();

    external get JS$_draw;

    external set JS$_draw(v);

    external get JS$_drawBackground;

    external set JS$_drawBackground(v);

    external get JS$_drawForeground;

    external set JS$_drawForeground(v);
}

@JS("BABYLON.LensFlare")
class LensFlare {
    // @Ignore
    LensFlare .fakeConstructor$();

    external num get size;

    external set size(num v);

    external num get position;

    external set position(num v);

    external Color3 get color;

    external set color(Color3 v);

    external Texture/*Texture|Null*/ get texture;

    external set texture(Texture/*Texture|Null*/ v);

    external num get alphaMode;

    external set alphaMode(num v);

    external get JS$_system;

    external set JS$_system(v);

    external static LensFlare AddFlare(num size, num position, Color3 color, String imgUrl, LensFlareSystem system);

    external factory LensFlare(num size, num position, Color3 color, String imgUrl, LensFlareSystem system);

    external void dispose();
}

@JS("BABYLON.LensFlareSystem")
class LensFlareSystem {
    // @Ignore
    LensFlareSystem .fakeConstructor$();

    external String get name;

    external set name(String v);

    external List<LensFlare> get lensFlares;

    external set lensFlares(List<LensFlare> v);

    external num get borderLimit;

    external set borderLimit(num v);

    external num get viewportBorder;

    external set viewportBorder(num v);

    external Func1<AbstractMesh, bool> get meshesSelectionPredicate;

    external set meshesSelectionPredicate(Func1<AbstractMesh, bool> v);

    external num get layerMask;

    external set layerMask(num v);

    external String get id;

    external set id(String v);

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_emitter;

    external set JS$_emitter(v);

    external get JS$_vertexBuffers;

    external set JS$_vertexBuffers(v);

    external get JS$_indexBuffer;

    external set JS$_indexBuffer(v);

    external get JS$_effect;

    external set JS$_effect(v);

    external get JS$_positionX;

    external set JS$_positionX(v);

    external get JS$_positionY;

    external set JS$_positionY(v);

    external get JS$_isEnabled;

    external set JS$_isEnabled(v);

    external factory LensFlareSystem(String name, dynamic emitter, Scene scene);

    external bool get isEnabled;

    external set isEnabled(bool v);

    external Scene getScene();

    external dynamic getEmitter();

    external void setEmitter(dynamic newEmitter);

    external Vector3 getEmitterPosition();

    external bool computeEffectivePosition(Viewport globalViewport);

    external bool JS$_isVisible();

    external bool render();

    external void dispose();

    external static LensFlareSystem Parse(dynamic parsedLensFlareSystem, Scene scene, String rootUrl);

    external dynamic serialize();
}

@JS("BABYLON.LensFlareSystemSceneComponent")
class LensFlareSystemSceneComponent implements ISceneSerializableComponent {
    // @Ignore
    LensFlareSystemSceneComponent .fakeConstructor$();

    external String get name;

    external set name(String v);

    external Scene get scene;

    external set scene(Scene v);

    external factory LensFlareSystemSceneComponent(Scene scene);

    external void register();

    external void rebuild();

    external void addFromContainer(AbstractScene container);

    external void removeFromContainer(AbstractScene container);

    external void serialize(dynamic serializationObject);

    external void dispose();

    external get JS$_draw;

    external set JS$_draw(v);
}

@JS("BABYLON.DirectionalLight")
class DirectionalLight extends ShadowLight {
    // @Ignore
    DirectionalLight .fakeConstructor$() : super.fakeConstructor$();
    external get JS$_shadowFrustumSize;

    external set JS$_shadowFrustumSize(v);

    external num get shadowFrustumSize;

    external set shadowFrustumSize(num v);

    external get JS$_shadowOrthoScale;

    external set JS$_shadowOrthoScale(v);

    external num get shadowOrthoScale;

    external set shadowOrthoScale(num v);

    external bool get autoUpdateExtends;

    external set autoUpdateExtends(bool v);

    external get JS$_orthoLeft;

    external set JS$_orthoLeft(v);

    external get JS$_orthoRight;

    external set JS$_orthoRight(v);

    external get JS$_orthoTop;

    external set JS$_orthoTop(v);

    external get JS$_orthoBottom;

    external set JS$_orthoBottom(v);

    external factory DirectionalLight(String name, Vector3 direction, Scene scene);

    external String getClassName();

    external num getTypeID();

    external void JS$_setDefaultShadowProjectionMatrix(Matrix matrix, Matrix viewMatrix, List<AbstractMesh> renderList);

    external void JS$_setDefaultFixedFrustumShadowProjectionMatrix(Matrix matrix, Matrix viewMatrix);

    external void JS$_setDefaultAutoExtendShadowProjectionMatrix(Matrix matrix, Matrix viewMatrix, List<AbstractMesh> renderList);

    external void JS$_buildUniformLayout();

    external DirectionalLight transferToEffect(Effect effect, String lightIndex);

    external num getDepthMinZ(Camera activeCamera);

    external num getDepthMaxZ(Camera activeCamera);

    external void prepareLightSpecificDefines(dynamic defines, num lightIndex);
}

@JS("BABYLON.HemisphericLight")
class HemisphericLight extends Light {
    // @Ignore
    HemisphericLight .fakeConstructor$() : super.fakeConstructor$();
    external Color3 get groundColor;

    external set groundColor(Color3 v);

    external Vector3 get direction;

    external set direction(Vector3 v);

    external factory HemisphericLight(String name, Vector3 direction, Scene scene);

    external void JS$_buildUniformLayout();

    external String getClassName();

    external Vector3 setDirectionToTarget(Vector3 target);

    external IShadowGenerator/*IShadowGenerator|Null*/ getShadowGenerator();

    external HemisphericLight transferToEffect(Effect effect, String lightIndex);

    external Matrix computeWorldMatrix([bool force, bool useWasUpdatedFlag]);

    external num getTypeID();

    external void prepareLightSpecificDefines(dynamic defines, num lightIndex);
}

@JS("BABYLON.Light")
abstract class Light extends Node {
    // @Ignore
    Light .fakeConstructor$() : super.fakeConstructor$();
    external static num get FALLOFF_DEFAULT;

    external static set FALLOFF_DEFAULT(num v);

    external static num get FALLOFF_PHYSICAL;

    external static set FALLOFF_PHYSICAL(num v);

    external static num get FALLOFF_GLTF;

    external static set FALLOFF_GLTF(num v);

    external static num get FALLOFF_STANDARD;

    external static set FALLOFF_STANDARD(num v);

    external static num get LIGHTMAP_DEFAULT;

    external static set LIGHTMAP_DEFAULT(num v);

    external static num get LIGHTMAP_SPECULAR;

    external static set LIGHTMAP_SPECULAR(num v);

    external static num get LIGHTMAP_SHADOWSONLY;

    external static set LIGHTMAP_SHADOWSONLY(num v);

    external static num get INTENSITYMODE_AUTOMATIC;

    external static set INTENSITYMODE_AUTOMATIC(num v);

    external static num get INTENSITYMODE_LUMINOUSPOWER;

    external static set INTENSITYMODE_LUMINOUSPOWER(num v);

    external static num get INTENSITYMODE_LUMINOUSINTENSITY;

    external static set INTENSITYMODE_LUMINOUSINTENSITY(num v);

    external static num get INTENSITYMODE_ILLUMINANCE;

    external static set INTENSITYMODE_ILLUMINANCE(num v);

    external static num get INTENSITYMODE_LUMINANCE;

    external static set INTENSITYMODE_LUMINANCE(num v);

    external static num get LIGHTTYPEID_POINTLIGHT;

    external static set LIGHTTYPEID_POINTLIGHT(num v);

    external static num get LIGHTTYPEID_DIRECTIONALLIGHT;

    external static set LIGHTTYPEID_DIRECTIONALLIGHT(num v);

    external static num get LIGHTTYPEID_SPOTLIGHT;

    external static set LIGHTTYPEID_SPOTLIGHT(num v);

    external static num get LIGHTTYPEID_HEMISPHERICLIGHT;

    external static set LIGHTTYPEID_HEMISPHERICLIGHT(num v);

    external Color3 get diffuse;

    external set diffuse(Color3 v);

    external Color3 get specular;

    external set specular(Color3 v);

    external num get falloffType;

    external set falloffType(num v);

    external num get intensity;

    external set intensity(num v);

    external get JS$_range;

    external set JS$_range(v);

    external num get JS$_inverseSquaredRange;

    external set JS$_inverseSquaredRange(num v);

    external num get range;

    external set range(num v);

    external get JS$_photometricScale;

    external set JS$_photometricScale(v);

    external get JS$_intensityMode;

    external set JS$_intensityMode(v);

    external num get intensityMode;

    external set intensityMode(num v);

    external get JS$_radius;

    external set JS$_radius(v);

    external num get radius;

    external set radius(num v);

    external get JS$_renderPriority;

    external set JS$_renderPriority(v);

    external num get renderPriority;

    external set renderPriority(num v);

    external get JS$_shadowEnabled;

    external set JS$_shadowEnabled(v);

    external bool get shadowEnabled;

    external set shadowEnabled(bool v);

    external get JS$_includedOnlyMeshes;

    external set JS$_includedOnlyMeshes(v);

    external List<AbstractMesh> get includedOnlyMeshes;

    external set includedOnlyMeshes(List<AbstractMesh> v);

    external get JS$_excludedMeshes;

    external set JS$_excludedMeshes(v);

    external List<AbstractMesh> get excludedMeshes;

    external set excludedMeshes(List<AbstractMesh> v);

    external get JS$_excludeWithLayerMask;

    external set JS$_excludeWithLayerMask(v);

    external num get excludeWithLayerMask;

    external set excludeWithLayerMask(num v);

    external get JS$_includeOnlyWithLayerMask;

    external set JS$_includeOnlyWithLayerMask(v);

    external num get includeOnlyWithLayerMask;

    external set includeOnlyWithLayerMask(num v);

    external get JS$_lightmapMode;

    external set JS$_lightmapMode(v);

    external num get lightmapMode;

    external set lightmapMode(num v);

    external IShadowGenerator/*IShadowGenerator|Null*/ get JS$_shadowGenerator;

    external set JS$_shadowGenerator(IShadowGenerator/*IShadowGenerator|Null*/ v);

    external List<String> get JS$_excludedMeshesIds;

    external set JS$_excludedMeshesIds(List<String> v);

    external List<String> get JS$_includedOnlyMeshesIds;

    external set JS$_includedOnlyMeshesIds(List<String> v);

    external UniformBuffer get JS$_uniformBuffer;

    external set JS$_uniformBuffer(UniformBuffer v);

    external factory Light(String name, Scene scene);

    external void JS$_buildUniformLayout();

    external Light transferToEffect(Effect effect, String lightIndex);

    external String getClassName();

    external String toString([bool fullDetails]);

    external void JS$_syncParentEnabledState();

    external void setEnabled(bool value);

    external IShadowGenerator/*IShadowGenerator|Null*/ getShadowGenerator();

    external Vector3 getAbsolutePosition();

    external bool canAffectMesh(AbstractMesh mesh);

    external static num CompareLightsPriority(Light a, Light b);

    external void dispose([bool doNotRecurse, bool disposeMaterialAndTextures]);

    external num getTypeID();

    external num getScaledIntensity();

    external Light/*Light|Null*/ clone(String name);

    external dynamic serialize();

    external static Func0<Light>/*Func0<Light>|Null*/ GetConstructorFromName(num type, String name, Scene scene);

    external static Light/*Light|Null*/ Parse(dynamic parsedLight, Scene scene);

    external get JS$_hookArrayForExcluded;

    external set JS$_hookArrayForExcluded(v);

    external get JS$_hookArrayForIncludedOnly;

    external set JS$_hookArrayForIncludedOnly(v);

    external get JS$_resyncMeshes;

    external set JS$_resyncMeshes(v);

    external void JS$_markMeshesAsLightDirty();

    external get JS$_computePhotometricScale;

    external set JS$_computePhotometricScale(v);

    external get JS$_getPhotometricScale;

    external set JS$_getPhotometricScale(v);

    external void JS$_reorderLightsInScene();

    external void prepareLightSpecificDefines(dynamic defines, num lightIndex);
}

@JS("BABYLON.PointLight")
class PointLight extends ShadowLight {
    // @Ignore
    PointLight .fakeConstructor$() : super.fakeConstructor$();
    external get JS$_shadowAngle;

    external set JS$_shadowAngle(v);

    external num get shadowAngle;

    external set shadowAngle(num v);

    external Vector3 get direction;

    external set direction(Vector3 v);

    external factory PointLight(String name, Vector3 position, Scene scene);

    external String getClassName();

    external num getTypeID();

    external bool needCube();

    external Vector3 getShadowDirection([num faceIndex]);

    external void JS$_setDefaultShadowProjectionMatrix(Matrix matrix, Matrix viewMatrix, List<AbstractMesh> renderList);

    external void JS$_buildUniformLayout();

    external PointLight transferToEffect(Effect effect, String lightIndex);

    external void prepareLightSpecificDefines(dynamic defines, num lightIndex);
}

@anonymous
@JS()
abstract class IShadowLight
    implements Light {
    external String get id;

    external set id(String v);

    external Vector3 get position;

    external set position(Vector3 v);

    external Vector3 get direction;

    external set direction(Vector3 v);

    external Vector3 get transformedPosition;

    external set transformedPosition(Vector3 v);

    external Vector3 get transformedDirection;

    external set transformedDirection(Vector3 v);

    external String get name;

    external set name(String v);

    external num get shadowMinZ;

    external set shadowMinZ(num v);

    external num get shadowMaxZ;

    external set shadowMaxZ(num v);

    external bool computeTransformedInformation();

    external Scene getScene();

    external VoidFunc3<Matrix, List<AbstractMesh>, Matrix> get customProjectionMatrixBuilder;

    external set customProjectionMatrixBuilder(VoidFunc3<Matrix, List<AbstractMesh>, Matrix> v);

    external IShadowLight setShadowProjectionMatrix(Matrix matrix, Matrix viewMatrix, List<AbstractMesh> renderList);

    external num getDepthScale();

    external bool needCube();

    external bool needProjectionMatrixCompute();

    external void forceProjectionMatrixCompute();

    external Vector3 getShadowDirection([num faceIndex]);

    external num getDepthMinZ(Camera activeCamera);

    external num getDepthMaxZ(Camera activeCamera);
}

@JS("BABYLON.ShadowLight")
abstract class ShadowLight extends Light implements IShadowLight {
    // @Ignore
    ShadowLight .fakeConstructor$() : super.fakeConstructor$();
    external void JS$_setDefaultShadowProjectionMatrix(Matrix matrix, Matrix viewMatrix, List<AbstractMesh> renderList);

    external Vector3 get JS$_position;

    external set JS$_position(Vector3 v);

    external void JS$_setPosition(Vector3 value);

    external Vector3 get position;

    external set position(Vector3 v);

    external Vector3 get JS$_direction;

    external set JS$_direction(Vector3 v);

    external void JS$_setDirection(Vector3 value);

    external Vector3 get direction;

    external set direction(Vector3 v);

    external get JS$_shadowMinZ;

    external set JS$_shadowMinZ(v);

    external num get shadowMinZ;

    external set shadowMinZ(num v);

    external get JS$_shadowMaxZ;

    external set JS$_shadowMaxZ(v);

    external num get shadowMaxZ;

    external set shadowMaxZ(num v);

    external VoidFunc3<Matrix, List<AbstractMesh>, Matrix> get customProjectionMatrixBuilder;

    external set customProjectionMatrixBuilder(VoidFunc3<Matrix, List<AbstractMesh>, Matrix> v);

    external Vector3 get transformedPosition;

    external set transformedPosition(Vector3 v);

    external Vector3 get transformedDirection;

    external set transformedDirection(Vector3 v);

    external get JS$_needProjectionMatrixCompute;

    external set JS$_needProjectionMatrixCompute(v);

    external bool computeTransformedInformation();

    external num getDepthScale();

    external Vector3 getShadowDirection([num faceIndex]);

    external Vector3 getAbsolutePosition();

    external Vector3 setDirectionToTarget(Vector3 target);

    external Vector3 getRotation();

    external bool needCube();

    external bool needProjectionMatrixCompute();

    external void forceProjectionMatrixCompute();

    external void JS$_initCache();

    external bool JS$_isSynchronized();

    external Matrix computeWorldMatrix([bool force]);

    external num getDepthMinZ(Camera activeCamera);

    external num getDepthMaxZ(Camera activeCamera);

    external IShadowLight setShadowProjectionMatrix(Matrix matrix, Matrix viewMatrix, List<AbstractMesh> renderList);
}

@JS("BABYLON.SpotLight")
class SpotLight extends ShadowLight {
    // @Ignore
    SpotLight .fakeConstructor$() : super.fakeConstructor$();
    external get JS$_angle;

    external set JS$_angle(v);

    external get JS$_innerAngle;

    external set JS$_innerAngle(v);

    external get JS$_cosHalfAngle;

    external set JS$_cosHalfAngle(v);

    external get JS$_lightAngleScale;

    external set JS$_lightAngleScale(v);

    external get JS$_lightAngleOffset;

    external set JS$_lightAngleOffset(v);

    external num get angle;

    external set angle(num v);

    external num get innerAngle;

    external set innerAngle(num v);

    external get JS$_shadowAngleScale;

    external set JS$_shadowAngleScale(v);

    external num get shadowAngleScale;

    external set shadowAngleScale(num v);

    external num get exponent;

    external set exponent(num v);

    external get JS$_projectionTextureMatrix;

    external set JS$_projectionTextureMatrix(v);

    external Matrix get projectionTextureMatrix;

    external set projectionTextureMatrix(Matrix v);

    external num get JS$_projectionTextureLightNear;

    external set JS$_projectionTextureLightNear(num v);

    external num get projectionTextureLightNear;

    external set projectionTextureLightNear(num v);

    external num get JS$_projectionTextureLightFar;

    external set JS$_projectionTextureLightFar(num v);

    external num get projectionTextureLightFar;

    external set projectionTextureLightFar(num v);

    external Vector3 get JS$_projectionTextureUpDirection;

    external set JS$_projectionTextureUpDirection(Vector3 v);

    external Vector3 get projectionTextureUpDirection;

    external set projectionTextureUpDirection(Vector3 v);

    external get JS$_projectionTexture;

    external set JS$_projectionTexture(v);

    external BaseTexture/*BaseTexture|Null*/ get projectionTexture;

    external set projectionTexture(BaseTexture/*BaseTexture|Null*/ v);

    external get JS$_projectionTextureViewLightDirty;

    external set JS$_projectionTextureViewLightDirty(v);

    external get JS$_projectionTextureProjectionLightDirty;

    external set JS$_projectionTextureProjectionLightDirty(v);

    external get JS$_projectionTextureDirty;

    external set JS$_projectionTextureDirty(v);

    external get JS$_projectionTextureViewTargetVector;

    external set JS$_projectionTextureViewTargetVector(v);

    external get JS$_projectionTextureViewLightMatrix;

    external set JS$_projectionTextureViewLightMatrix(v);

    external get JS$_projectionTextureProjectionLightMatrix;

    external set JS$_projectionTextureProjectionLightMatrix(v);

    external get JS$_projectionTextureScalingMatrix;

    external set JS$_projectionTextureScalingMatrix(v);

    external factory SpotLight(String name, Vector3 position, Vector3 direction, num angle, num exponent, Scene scene);

    external String getClassName();

    external num getTypeID();

    external void JS$_setDirection(Vector3 value);

    external void JS$_setPosition(Vector3 value);

    external void JS$_setDefaultShadowProjectionMatrix(Matrix matrix, Matrix viewMatrix, List<AbstractMesh> renderList);

    external void JS$_computeProjectionTextureViewLightMatrix();

    external void JS$_computeProjectionTextureProjectionLightMatrix();

    external void JS$_computeProjectionTextureMatrix();

    external void JS$_buildUniformLayout();

    external get JS$_computeAngleValues;

    external set JS$_computeAngleValues(v);

    external SpotLight transferToEffect(Effect effect, String lightIndex);

    external void dispose();

    external void prepareLightSpecificDefines(dynamic defines, num lightIndex);
}

@anonymous
@JS()
abstract class ILoadingScreen {
    external VoidFunc0 get displayLoadingUI;

    external set displayLoadingUI(VoidFunc0 v);

    external VoidFunc0 get hideLoadingUI;

    external set hideLoadingUI(VoidFunc0 v);

    external String get loadingUIBackgroundColor;

    external set loadingUIBackgroundColor(String v);

    external String get loadingUIText;

    external set loadingUIText(String v);

    external factory ILoadingScreen({ VoidFunc0 displayLoadingUI, VoidFunc0 hideLoadingUI, String loadingUIBackgroundColor, String loadingUIText});
}

@JS("BABYLON.DefaultLoadingScreen")
class DefaultLoadingScreen implements ILoadingScreen {
    // @Ignore
    DefaultLoadingScreen .fakeConstructor$();

    external get JS$_renderingCanvas;

    external set JS$_renderingCanvas(v);

    external get JS$_loadingText;

    external set JS$_loadingText(v);

    external get JS$_loadingDivBackgroundColor;

    external set JS$_loadingDivBackgroundColor(v);

    external get JS$_loadingDiv;

    external set JS$_loadingDiv(v);

    external get JS$_loadingTextDiv;

    external set JS$_loadingTextDiv(v);

    external factory DefaultLoadingScreen(CanvasElement JS$_renderingCanvas, [String JS$_loadingText, String JS$_loadingDivBackgroundColor]);

    external void displayLoadingUI();

    external void hideLoadingUI();

    external String get loadingUIText;

    external set loadingUIText(String v);

    external String get loadingUIBackgroundColor;

    external set loadingUIBackgroundColor(String v);

    external get JS$_resizeLoadingUI;

    external set JS$_resizeLoadingUI(v);
}

@JS("BABYLON.SceneLoaderProgressEvent")
class SceneLoaderProgressEvent {
    // @Ignore
    SceneLoaderProgressEvent .fakeConstructor$();

    external bool get lengthComputable;

    external set lengthComputable(bool v);

    external num get loaded;

    external set loaded(num v);

    external num get total;

    external set total(num v);

    external factory SceneLoaderProgressEvent(bool lengthComputable, num loaded, num total);

    external static SceneLoaderProgressEvent FromProgressEvent(ProgressEvent event);
}

@anonymous
@JS()
abstract class ISceneLoaderPluginExtensions {
    /* Index signature is not yet supported by JavaScript interop. */
}

@anonymous
@JS()
abstract class ISceneLoaderPluginFactory {
    external String get name;

    external set name(String v);

    external dynamic/*ISceneLoaderPlugin|ISceneLoaderPluginAsync*/ createPlugin();

    external Func1<String, bool> get canDirectLoad;

    external set canDirectLoad(Func1<String, bool> v);
}

@anonymous
@JS()
abstract class ISceneLoaderPlugin {
    external String get name;

    external set name(String v);

    external dynamic/*String|ISceneLoaderPluginExtensions*/ get extensions;

    external set extensions(dynamic/*String|ISceneLoaderPluginExtensions*/ v);

    external bool importMesh(dynamic meshesNames, Scene scene, dynamic data, String rootUrl, List<AbstractMesh> meshes, List<IParticleSystem> particleSystems, List<Skeleton> skeletons, [void onError(String message, [dynamic exception])]);

    external bool load(Scene scene, String data, String rootUrl, [void onError(String message, [dynamic exception])]);

    external Func1<String, bool> get canDirectLoad;

    external set canDirectLoad(Func1<String, bool> v);

    external Func2Opt1<String, String, String> get rewriteRootURL;

    external set rewriteRootURL(Func2Opt1<String, String, String> v);

    external AssetContainer loadAssetContainer(Scene scene, String data, String rootUrl, [void onError(String message, [dynamic exception])]);
}

@anonymous
@JS()
abstract class ISceneLoaderPluginAsync {
    external String get name;

    external set name(String v);

    external dynamic/*String|ISceneLoaderPluginExtensions*/ get extensions;

    external set extensions(dynamic/*String|ISceneLoaderPluginExtensions*/ v);

    external Promise<dynamic /*{
            meshes: AbstractMesh[];
            particleSystems: IParticleSystem[];
            skeletons: Skeleton[];
            animationGroups: AnimationGroup[];
        }*/> importMeshAsync(dynamic meshesNames, Scene scene, dynamic data, String rootUrl, [void onProgress(SceneLoaderProgressEvent event), String fileName]);

    external Promise<Null> loadAsync(Scene scene, String data, String rootUrl, [void onProgress(SceneLoaderProgressEvent event), String fileName]);

    external Func1<String, bool> get canDirectLoad;

    external set canDirectLoad(Func1<String, bool> v);

    external Func2Opt1<String, String, String> get rewriteRootURL;

    external set rewriteRootURL(Func2Opt1<String, String, String> v);

    external Promise<AssetContainer> loadAssetContainerAsync(Scene scene, String data, String rootUrl, [void onProgress(SceneLoaderProgressEvent event), String fileName]);
}

@JS("BABYLON.SceneLoader")
class SceneLoader {
    // @Ignore
    SceneLoader .fakeConstructor$();

    external static get JS$_ForceFullSceneLoadingForIncremental;

    external static set JS$_ForceFullSceneLoadingForIncremental(v);

    external static get JS$_ShowLoadingScreen;

    external static set JS$_ShowLoadingScreen(v);

    external static get JS$_CleanBoneMatrixWeights;

    external static set JS$_CleanBoneMatrixWeights(v);

    external static num get NO_LOGGING;

    external static set NO_LOGGING(num v);

    external static num get MINIMAL_LOGGING;

    external static set MINIMAL_LOGGING(num v);

    external static num get SUMMARY_LOGGING;

    external static set SUMMARY_LOGGING(num v);

    external static num get DETAILED_LOGGING;

    external static set DETAILED_LOGGING(num v);

    external static get JS$_loggingLevel;

    external static set JS$_loggingLevel(v);

    external static bool get ForceFullSceneLoadingForIncremental;

    external static set ForceFullSceneLoadingForIncremental(bool v);

    external static bool get ShowLoadingScreen;

    external static set ShowLoadingScreen(bool v);

    external static num get loggingLevel;

    external static set loggingLevel(num v);

    external static bool get CleanBoneMatrixWeights;

    external static set CleanBoneMatrixWeights(bool v);

    external static Observable<dynamic /*ISceneLoaderPlugin|ISceneLoaderPluginAsync*/> get OnPluginActivatedObservable;

    external static set OnPluginActivatedObservable(Observable<dynamic /*ISceneLoaderPlugin|ISceneLoaderPluginAsync*/> v);

    external static get JS$_registeredPlugins;

    external static set JS$_registeredPlugins(v);

    external static get JS$_getDefaultPlugin;

    external static set JS$_getDefaultPlugin(v);

    external static get JS$_getPluginForExtension;

    external static set JS$_getPluginForExtension(v);

    external static get JS$_getPluginForDirectLoad;

    external static set JS$_getPluginForDirectLoad(v);

    external static get JS$_getPluginForFilename;

    external static set JS$_getPluginForFilename(v);

    external static get JS$_getDirectLoad;

    external static set JS$_getDirectLoad(v);

    external static get JS$_loadData;

    external static set JS$_loadData(v);

    external static get JS$_getFileInfo;

    external static set JS$_getFileInfo(v);

    external static dynamic/*ISceneLoaderPlugin|ISceneLoaderPluginAsync|ISceneLoaderPluginFactory*/ GetPluginForExtension(String extension);

    external static bool IsPluginForExtensionAvailable(String extension);

    external static void RegisterPlugin(dynamic/*ISceneLoaderPlugin|ISceneLoaderPluginAsync*/ plugin);

    external static dynamic/*ISceneLoaderPlugin|ISceneLoaderPluginAsync|Null*/ ImportMesh(dynamic meshNames, String rootUrl, [String sceneFilename, Scene/*Scene|Null*/ scene, VoidFunc4<List<AbstractMesh>, List<IParticleSystem>, List<Skeleton>, List<AnimationGroup>>/*VoidFunc4<List<AbstractMesh>, List<IParticleSystem>, List<Skeleton>, List<AnimationGroup>>|Null*/ onSuccess, VoidFunc1<SceneLoaderProgressEvent>/*VoidFunc1<SceneLoaderProgressEvent>|Null*/ onProgress, VoidFunc3Opt1<Scene, String, dynamic>/*VoidFunc3Opt1<Scene, String, dynamic>|Null*/ onError, String/*String|Null*/ pluginExtension]);

    external static Promise<dynamic /*{
            meshes: AbstractMesh[];
            particleSystems: IParticleSystem[];
            skeletons: Skeleton[];
            animationGroups: AnimationGroup[];
        }*/> ImportMeshAsync(dynamic meshNames, String rootUrl, [String sceneFilename, Scene/*Scene|Null*/ scene, VoidFunc1<SceneLoaderProgressEvent>/*VoidFunc1<SceneLoaderProgressEvent>|Null*/ onProgress, String/*String|Null*/ pluginExtension]);

    external static dynamic/*ISceneLoaderPlugin|ISceneLoaderPluginAsync|Null*/ Load(String rootUrl, String sceneFilename, Engine engine, [VoidFunc1<Scene>/*VoidFunc1<Scene>|Null*/ onSuccess, VoidFunc1<SceneLoaderProgressEvent>/*VoidFunc1<SceneLoaderProgressEvent>|Null*/ onProgress, VoidFunc3Opt1<Scene, String, dynamic>/*VoidFunc3Opt1<Scene, String, dynamic>|Null*/ onError, String/*String|Null*/ pluginExtension]);

    external static Promise<Scene> LoadAsync(String rootUrl, String sceneFilename, Engine engine, [VoidFunc1<SceneLoaderProgressEvent>/*VoidFunc1<SceneLoaderProgressEvent>|Null*/ onProgress, String/*String|Null*/ pluginExtension]);

    external static dynamic/*ISceneLoaderPlugin|ISceneLoaderPluginAsync|Null*/ Append(String rootUrl, [String sceneFilename, Scene/*Scene|Null*/ scene, VoidFunc1<Scene>/*VoidFunc1<Scene>|Null*/ onSuccess, VoidFunc1<SceneLoaderProgressEvent>/*VoidFunc1<SceneLoaderProgressEvent>|Null*/ onProgress, VoidFunc3Opt1<Scene, String, dynamic>/*VoidFunc3Opt1<Scene, String, dynamic>|Null*/ onError, String/*String|Null*/ pluginExtension]);

    external static Promise<Scene> AppendAsync(String rootUrl, [String sceneFilename, Scene/*Scene|Null*/ scene, VoidFunc1<SceneLoaderProgressEvent>/*VoidFunc1<SceneLoaderProgressEvent>|Null*/ onProgress, String/*String|Null*/ pluginExtension]);

    external static dynamic/*ISceneLoaderPlugin|ISceneLoaderPluginAsync|Null*/ LoadAssetContainer(String rootUrl, [String sceneFilename, Scene/*Scene|Null*/ scene, VoidFunc1<AssetContainer>/*VoidFunc1<AssetContainer>|Null*/ onSuccess, VoidFunc1<SceneLoaderProgressEvent>/*VoidFunc1<SceneLoaderProgressEvent>|Null*/ onProgress, VoidFunc3Opt1<Scene, String, dynamic>/*VoidFunc3Opt1<Scene, String, dynamic>|Null*/ onError, String/*String|Null*/ pluginExtension]);

    external static Promise<AssetContainer> LoadAssetContainerAsync(String rootUrl, [String sceneFilename, Scene/*Scene|Null*/ scene, VoidFunc1<SceneLoaderProgressEvent>/*VoidFunc1<SceneLoaderProgressEvent>|Null*/ onProgress, String/*String|Null*/ pluginExtension]);
}

@JS("BABYLON.ColorCurves")
class ColorCurves {
    // @Ignore
    ColorCurves .fakeConstructor$();

    external get JS$_dirty;

    external set JS$_dirty(v);

    external get JS$_tempColor;

    external set JS$_tempColor(v);

    external get JS$_globalCurve;

    external set JS$_globalCurve(v);

    external get JS$_highlightsCurve;

    external set JS$_highlightsCurve(v);

    external get JS$_midtonesCurve;

    external set JS$_midtonesCurve(v);

    external get JS$_shadowsCurve;

    external set JS$_shadowsCurve(v);

    external get JS$_positiveCurve;

    external set JS$_positiveCurve(v);

    external get JS$_negativeCurve;

    external set JS$_negativeCurve(v);

    external get JS$_globalHue;

    external set JS$_globalHue(v);

    external get JS$_globalDensity;

    external set JS$_globalDensity(v);

    external get JS$_globalSaturation;

    external set JS$_globalSaturation(v);

    external get JS$_globalExposure;

    external set JS$_globalExposure(v);

    external num get globalHue;

    external set globalHue(num v);

    external num get globalDensity;

    external set globalDensity(num v);

    external num get globalSaturation;

    external set globalSaturation(num v);

    external num get globalExposure;

    external set globalExposure(num v);

    external get JS$_highlightsHue;

    external set JS$_highlightsHue(v);

    external get JS$_highlightsDensity;

    external set JS$_highlightsDensity(v);

    external get JS$_highlightsSaturation;

    external set JS$_highlightsSaturation(v);

    external get JS$_highlightsExposure;

    external set JS$_highlightsExposure(v);

    external num get highlightsHue;

    external set highlightsHue(num v);

    external num get highlightsDensity;

    external set highlightsDensity(num v);

    external num get highlightsSaturation;

    external set highlightsSaturation(num v);

    external num get highlightsExposure;

    external set highlightsExposure(num v);

    external get JS$_midtonesHue;

    external set JS$_midtonesHue(v);

    external get JS$_midtonesDensity;

    external set JS$_midtonesDensity(v);

    external get JS$_midtonesSaturation;

    external set JS$_midtonesSaturation(v);

    external get JS$_midtonesExposure;

    external set JS$_midtonesExposure(v);

    external num get midtonesHue;

    external set midtonesHue(num v);

    external num get midtonesDensity;

    external set midtonesDensity(num v);

    external num get midtonesSaturation;

    external set midtonesSaturation(num v);

    external num get midtonesExposure;

    external set midtonesExposure(num v);

    external get JS$_shadowsHue;

    external set JS$_shadowsHue(v);

    external get JS$_shadowsDensity;

    external set JS$_shadowsDensity(v);

    external get JS$_shadowsSaturation;

    external set JS$_shadowsSaturation(v);

    external get JS$_shadowsExposure;

    external set JS$_shadowsExposure(v);

    external num get shadowsHue;

    external set shadowsHue(num v);

    external num get shadowsDensity;

    external set shadowsDensity(num v);

    external num get shadowsSaturation;

    external set shadowsSaturation(num v);

    external num get shadowsExposure;

    external set shadowsExposure(num v);

    external String getClassName();

    external static void Bind(ColorCurves colorCurves, Effect effect, [String positiveUniform, String neutralUniform, String negativeUniform]);

    external static void PrepareUniforms(List<String> uniformsList);

    external get getColorGradingDataToRef;

    external set getColorGradingDataToRef(v);

    external static get applyColorGradingSliderNonlinear;

    external static set applyColorGradingSliderNonlinear(v);

    external static get fromHSBToRef;

    external static set fromHSBToRef(v);

    external static get clamp;

    external static set clamp(v);

    external ColorCurves clone();

    external dynamic serialize();

    external static ColorCurves Parse(dynamic source);
}

@JS("BABYLON.EffectFallbacks")
class EffectFallbacks {
    // @Ignore
    EffectFallbacks .fakeConstructor$();

    external get JS$_defines;

    external set JS$_defines(v);

    external get JS$_currentRank;

    external set JS$_currentRank(v);

    external get JS$_maxRank;

    external set JS$_maxRank(v);

    external get JS$_mesh;

    external set JS$_mesh(v);

    external void unBindMesh();

    external void addFallback(num rank, String define);

    external void addCPUSkinningFallback(num rank, AbstractMesh mesh);

    external bool get isMoreFallbacks;

    external set isMoreFallbacks(bool v);

    external String reduce(String currentDefines, Effect effect);
}

@JS("BABYLON.EffectCreationOptions")
class EffectCreationOptions {
    // @Ignore
    EffectCreationOptions .fakeConstructor$();

    external List<String> get attributes;

    external set attributes(List<String> v);

    external List<String> get uniformsNames;

    external set uniformsNames(List<String> v);

    external List<String> get uniformBuffersNames;

    external set uniformBuffersNames(List<String> v);

    external List<String> get samplers;

    external set samplers(List<String> v);

    external dynamic get defines;

    external set defines(dynamic v);

    external EffectFallbacks/*EffectFallbacks|Null*/ get fallbacks;

    external set fallbacks(EffectFallbacks/*EffectFallbacks|Null*/ v);

    external VoidFunc1<Effect>/*VoidFunc1<Effect>|Null*/ get onCompiled;

    external set onCompiled(VoidFunc1<Effect>/*VoidFunc1<Effect>|Null*/ v);

    external VoidFunc2<Effect, String>/*VoidFunc2<Effect, String>|Null*/ get onError;

    external set onError(VoidFunc2<Effect, String>/*VoidFunc2<Effect, String>|Null*/ v);

    external dynamic get indexParameters;

    external set indexParameters(dynamic v);

    external num get maxSimultaneousLights;

    external set maxSimultaneousLights(num v);

    external List<String>/*List<String>|Null*/ get transformFeedbackVaryings;

    external set transformFeedbackVaryings(List<String>/*List<String>|Null*/ v);
}

@JS("BABYLON.Effect")
class Effect {
    // @Ignore
    Effect .fakeConstructor$();

    external dynamic get name;

    external set name(dynamic v);

    external String get defines;

    external set defines(String v);

    external VoidFunc1<Effect>/*VoidFunc1<Effect>|Null*/ get onCompiled;

    external set onCompiled(VoidFunc1<Effect>/*VoidFunc1<Effect>|Null*/ v);

    external VoidFunc2<Effect, String>/*VoidFunc2<Effect, String>|Null*/ get onError;

    external set onError(VoidFunc2<Effect, String>/*VoidFunc2<Effect, String>|Null*/ v);

    external VoidFunc1<Effect>/*VoidFunc1<Effect>|Null*/ get onBind;

    external set onBind(VoidFunc1<Effect>/*VoidFunc1<Effect>|Null*/ v);

    external num get uniqueId;

    external set uniqueId(num v);

    external Observable<Effect> get onCompileObservable;

    external set onCompileObservable(Observable<Effect> v);

    external Observable<Effect> get onErrorObservable;

    external set onErrorObservable(Observable<Effect> v);

    external Observable<Effect>/*Observable<Effect>|Null*/ get JS$_onBindObservable;

    external set JS$_onBindObservable(Observable<Effect>/*Observable<Effect>|Null*/ v);

    external Observable<Effect> get onBindObservable;

    external set onBindObservable(Observable<Effect> v);

    external bool get JS$_bonesComputationForcedToCPU;

    external set JS$_bonesComputationForcedToCPU(bool v);

    external static get JS$_uniqueIdSeed;

    external static set JS$_uniqueIdSeed(v);

    external get JS$_engine;

    external set JS$_engine(v);

    external get JS$_uniformBuffersNames;

    external set JS$_uniformBuffersNames(v);

    external get JS$_uniformsNames;

    external set JS$_uniformsNames(v);

    external get JS$_samplers;

    external set JS$_samplers(v);

    external get JS$_isReady;

    external set JS$_isReady(v);

    external get JS$_compilationError;

    external set JS$_compilationError(v);

    external get JS$_attributesNames;

    external set JS$_attributesNames(v);

    external get JS$_attributes;

    external set JS$_attributes(v);

    external get JS$_uniforms;

    external set JS$_uniforms(v);

    external String get JS$_key;

    external set JS$_key(String v);

    external get JS$_indexParameters;

    external set JS$_indexParameters(v);

    external get JS$_fallbacks;

    external set JS$_fallbacks(v);

    external get JS$_vertexSourceCode;

    external set JS$_vertexSourceCode(v);

    external get JS$_fragmentSourceCode;

    external set JS$_fragmentSourceCode(v);

    external get JS$_vertexSourceCodeOverride;

    external set JS$_vertexSourceCodeOverride(v);

    external get JS$_fragmentSourceCodeOverride;

    external set JS$_fragmentSourceCodeOverride(v);

    external get JS$_transformFeedbackVaryings;

    external set JS$_transformFeedbackVaryings(v);

    external Program get JS$_program;

    external set JS$_program(Program v);

    external get JS$_valueCache;

    external set JS$_valueCache(v);

    external static get JS$_baseCache;

    external static set JS$_baseCache(v);

    external factory Effect(dynamic baseName, dynamic/*List<String>|EffectCreationOptions*/ attributesNamesOrOptions, dynamic/*List<String>|Engine*/ uniformsNamesOrEngine, [List<String>/*List<String>|Null*/ samplers, Engine engine, String/*String|Null*/ defines, EffectFallbacks/*EffectFallbacks|Null*/ fallbacks, VoidFunc1<Effect>/*VoidFunc1<Effect>|Null*/ onCompiled, VoidFunc2<Effect, String>/*VoidFunc2<Effect, String>|Null*/ onError, dynamic indexParameters]);

    external String get key;

    external set key(String v);

    external bool isReady();

    external Engine getEngine();

    external Program getProgram();

    external List<String> getAttributesNames();

    external num getAttributeLocation(num index);

    external num getAttributeLocationByName(String name);

    external num getAttributesCount();

    external num getUniformIndex(String uniformName);

    external UniformLocation/*UniformLocation|Null*/ getUniform(String uniformName);

    external List<String> getSamplers();

    external String getCompilationError();

    external void executeWhenCompiled(void func(Effect effect));

    external void JS$_loadVertexShader(dynamic vertex, void callback(dynamic data));

    external void JS$_loadFragmentShader(dynamic fragment, void callback(dynamic data));

    external void JS$_dumpShadersSource(String vertexCode, String fragmentCode, String defines);

    external get JS$_processShaderConversion;

    external set JS$_processShaderConversion(v);

    external get JS$_processIncludes;

    external set JS$_processIncludes(v);

    external get JS$_processPrecision;

    external set JS$_processPrecision(v);

    external void JS$_rebuildProgram(String vertexSourceCode, String fragmentSourceCode, void onCompiled(Program program), void onError(String message));

    external List<UniformLocation /*UniformLocation|Null*/> getSpecificUniformLocations(List<String> names);

    external void JS$_prepareEffect();

    external bool get isSupported;

    external set isSupported(bool v);

    external void JS$_bindTexture(String channel, InternalTexture texture);

    external void setTexture(String channel, BaseTexture/*BaseTexture|Null*/ texture);

    external void setDepthStencilTexture(String channel, RenderTargetTexture/*RenderTargetTexture|Null*/ texture);

    external void setTextureArray(String channel, List<BaseTexture> textures);

    external void setTextureFromPostProcess(String channel, PostProcess/*PostProcess|Null*/ postProcess);

    external void setTextureFromPostProcessOutput(String channel, PostProcess/*PostProcess|Null*/ postProcess);

    external bool JS$_cacheMatrix(String uniformName, Matrix matrix);

    external bool JS$_cacheFloat2(String uniformName, num x, num y);

    external bool JS$_cacheFloat3(String uniformName, num x, num y, num z);

    external bool JS$_cacheFloat4(String uniformName, num x, num y, num z, num w);

    external void bindUniformBuffer(Buffer buffer, String name);

    external void bindUniformBlock(String blockName, num index);

    external Effect setInt(String uniformName, num value);

    external Effect setIntArray(String uniformName, Int32List array);

    external Effect setIntArray2(String uniformName, Int32List array);

    external Effect setIntArray3(String uniformName, Int32List array);

    external Effect setIntArray4(String uniformName, Int32List array);

    external Effect setFloatArray(String uniformName, Float32List array);

    external Effect setFloatArray2(String uniformName, Float32List array);

    external Effect setFloatArray3(String uniformName, Float32List array);

    external Effect setFloatArray4(String uniformName, Float32List array);

    external Effect setArray(String uniformName, List<num> array);

    external Effect setArray2(String uniformName, List<num> array);

    external Effect setArray3(String uniformName, List<num> array);

    external Effect setArray4(String uniformName, List<num> array);

    external Effect setMatrices(String uniformName, Float32List matrices);

    external Effect setMatrix(String uniformName, Matrix matrix);

    external Effect setMatrix3x3(String uniformName, Float32List matrix);

    external Effect setMatrix2x2(String uniformName, Float32List matrix);

    external Effect setFloat(String uniformName, num value);

    external Effect setBool(String uniformName, bool bool);

    external Effect setVector2(String uniformName, Vector2 vector2);

    external Effect setFloat2(String uniformName, num x, num y);

    external Effect setVector3(String uniformName, Vector3 vector3);

    external Effect setFloat3(String uniformName, num x, num y, num z);

    external Effect setVector4(String uniformName, Vector4 vector4);

    external Effect setFloat4(String uniformName, num x, num y, num z, num w);

    external Effect setColor3(String uniformName, Color3 color3);

    external Effect setColor4(String uniformName, Color3 color3, num alpha);

    external Effect setDirectColor4(String uniformName, Color4 color4);

    external static void RegisterShader(String name, [String pixelShader, String vertexShader]);

    external static dynamic/*JSMap of <String,String>*/ get ShadersStore;

    external static set ShadersStore(dynamic/*JSMap of <String,String>*/ v);

    external static dynamic/*JSMap of <String,String>*/ get IncludesShadersStore;

    external static set IncludesShadersStore(dynamic/*JSMap of <String,String>*/ v);

    external static void ResetCache();
}

@JS("BABYLON.FresnelParameters")
class FresnelParameters {
    // @Ignore
    FresnelParameters .fakeConstructor$();

    external get JS$_isEnabled;

    external set JS$_isEnabled(v);

    external bool get isEnabled;

    external set isEnabled(bool v);

    external Color3 get leftColor;

    external set leftColor(Color3 v);

    external Color3 get rightColor;

    external set rightColor(Color3 v);

    external num get bias;

    external set bias(num v);

    external num get power;

    external set power(num v);

    external FresnelParameters clone();

    external dynamic serialize();

    external static FresnelParameters Parse(dynamic parsedFresnelParameters);
}

@anonymous
@JS()
abstract class IImageProcessingConfigurationDefines {
    external bool get IMAGEPROCESSING;

    external set IMAGEPROCESSING(bool v);

    external bool get VIGNETTE;

    external set VIGNETTE(bool v);

    external bool get VIGNETTEBLENDMODEMULTIPLY;

    external set VIGNETTEBLENDMODEMULTIPLY(bool v);

    external bool get VIGNETTEBLENDMODEOPAQUE;

    external set VIGNETTEBLENDMODEOPAQUE(bool v);

    external bool get TONEMAPPING;

    external set TONEMAPPING(bool v);

    external bool get TONEMAPPING_ACES;

    external set TONEMAPPING_ACES(bool v);

    external bool get CONTRAST;

    external set CONTRAST(bool v);

    external bool get EXPOSURE;

    external set EXPOSURE(bool v);

    external bool get COLORCURVES;

    external set COLORCURVES(bool v);

    external bool get COLORGRADING;

    external set COLORGRADING(bool v);

    external bool get COLORGRADING3D;

    external set COLORGRADING3D(bool v);

    external bool get SAMPLER3DGREENDEPTH;

    external set SAMPLER3DGREENDEPTH(bool v);

    external bool get SAMPLER3DBGRMAP;

    external set SAMPLER3DBGRMAP(bool v);

    external bool get IMAGEPROCESSINGPOSTPROCESS;

    external set IMAGEPROCESSINGPOSTPROCESS(bool v);

    external factory IImageProcessingConfigurationDefines({ bool IMAGEPROCESSING, bool VIGNETTE, bool VIGNETTEBLENDMODEMULTIPLY, bool VIGNETTEBLENDMODEOPAQUE, bool TONEMAPPING, bool TONEMAPPING_ACES, bool CONTRAST, bool EXPOSURE, bool COLORCURVES, bool COLORGRADING, bool COLORGRADING3D, bool SAMPLER3DGREENDEPTH, bool SAMPLER3DBGRMAP, bool IMAGEPROCESSINGPOSTPROCESS});
}

@JS("BABYLON.ImageProcessingConfigurationDefines")
class ImageProcessingConfigurationDefines extends MaterialDefines implements IImageProcessingConfigurationDefines {
    // @Ignore
    ImageProcessingConfigurationDefines .fakeConstructor$() : super.fakeConstructor$();
    external bool get IMAGEPROCESSING;

    external set IMAGEPROCESSING(bool v);

    external bool get VIGNETTE;

    external set VIGNETTE(bool v);

    external bool get VIGNETTEBLENDMODEMULTIPLY;

    external set VIGNETTEBLENDMODEMULTIPLY(bool v);

    external bool get VIGNETTEBLENDMODEOPAQUE;

    external set VIGNETTEBLENDMODEOPAQUE(bool v);

    external bool get TONEMAPPING;

    external set TONEMAPPING(bool v);

    external bool get TONEMAPPING_ACES;

    external set TONEMAPPING_ACES(bool v);

    external bool get CONTRAST;

    external set CONTRAST(bool v);

    external bool get COLORCURVES;

    external set COLORCURVES(bool v);

    external bool get COLORGRADING;

    external set COLORGRADING(bool v);

    external bool get COLORGRADING3D;

    external set COLORGRADING3D(bool v);

    external bool get SAMPLER3DGREENDEPTH;

    external set SAMPLER3DGREENDEPTH(bool v);

    external bool get SAMPLER3DBGRMAP;

    external set SAMPLER3DBGRMAP(bool v);

    external bool get IMAGEPROCESSINGPOSTPROCESS;

    external set IMAGEPROCESSINGPOSTPROCESS(bool v);

    external bool get EXPOSURE;

    external set EXPOSURE(bool v);

    external factory ImageProcessingConfigurationDefines();
}

@JS("BABYLON.ImageProcessingConfiguration")
class ImageProcessingConfiguration {
    // @Ignore
    ImageProcessingConfiguration .fakeConstructor$();

    external static num get TONEMAPPING_STANDARD;

    external static set TONEMAPPING_STANDARD(num v);

    external static num get TONEMAPPING_ACES;

    external static set TONEMAPPING_ACES(num v);

    external ColorCurves/*ColorCurves|Null*/ get colorCurves;

    external set colorCurves(ColorCurves/*ColorCurves|Null*/ v);

    external get JS$_colorCurvesEnabled;

    external set JS$_colorCurvesEnabled(v);

    external bool get colorCurvesEnabled;

    external set colorCurvesEnabled(bool v);

    external get JS$_colorGradingTexture;

    external set JS$_colorGradingTexture(v);

    external BaseTexture/*BaseTexture|Null*/ get colorGradingTexture;

    external set colorGradingTexture(BaseTexture/*BaseTexture|Null*/ v);

    external get JS$_colorGradingEnabled;

    external set JS$_colorGradingEnabled(v);

    external bool get colorGradingEnabled;

    external set colorGradingEnabled(bool v);

    external get JS$_colorGradingWithGreenDepth;

    external set JS$_colorGradingWithGreenDepth(v);

    external bool get colorGradingWithGreenDepth;

    external set colorGradingWithGreenDepth(bool v);

    external get JS$_colorGradingBGR;

    external set JS$_colorGradingBGR(v);

    external bool get colorGradingBGR;

    external set colorGradingBGR(bool v);

    external num get JS$_exposure;

    external set JS$_exposure(num v);

    external num get exposure;

    external set exposure(num v);

    external get JS$_toneMappingEnabled;

    external set JS$_toneMappingEnabled(v);

    external bool get toneMappingEnabled;

    external set toneMappingEnabled(bool v);

    external get JS$_toneMappingType;

    external set JS$_toneMappingType(v);

    external num get toneMappingType;

    external set toneMappingType(num v);

    external num get JS$_contrast;

    external set JS$_contrast(num v);

    external num get contrast;

    external set contrast(num v);

    external num get vignetteStretch;

    external set vignetteStretch(num v);

    external num get vignetteCentreX;

    external set vignetteCentreX(num v);

    external num get vignetteCentreY;

    external set vignetteCentreY(num v);

    external num get vignetteWeight;

    external set vignetteWeight(num v);

    external Color4 get vignetteColor;

    external set vignetteColor(Color4 v);

    external num get vignetteCameraFov;

    external set vignetteCameraFov(num v);

    external get JS$_vignetteBlendMode;

    external set JS$_vignetteBlendMode(v);

    external num get vignetteBlendMode;

    external set vignetteBlendMode(num v);

    external get JS$_vignetteEnabled;

    external set JS$_vignetteEnabled(v);

    external bool get vignetteEnabled;

    external set vignetteEnabled(bool v);

    external get JS$_applyByPostProcess;

    external set JS$_applyByPostProcess(v);

    external bool get applyByPostProcess;

    external set applyByPostProcess(bool v);

    external get JS$_isEnabled;

    external set JS$_isEnabled(v);

    external bool get isEnabled;

    external set isEnabled(bool v);

    external Observable<ImageProcessingConfiguration> get onUpdateParameters;

    external set onUpdateParameters(Observable<ImageProcessingConfiguration> v);

    external void JS$_updateParameters();

    external String getClassName();

    external static void PrepareUniforms(List<String> uniforms, IImageProcessingConfigurationDefines defines);

    external static void PrepareSamplers(List<String> samplersList, IImageProcessingConfigurationDefines defines);

    external void prepareDefines(IImageProcessingConfigurationDefines defines, [bool forPostProcess]);

    external bool isReady();

    external void bind(Effect effect, [num aspectRatio]);

    external ImageProcessingConfiguration clone();

    external dynamic serialize();

    external static ImageProcessingConfiguration Parse(dynamic source);

    external static get JS$_VIGNETTEMODE_MULTIPLY;

    external static set JS$_VIGNETTEMODE_MULTIPLY(v);

    external static get JS$_VIGNETTEMODE_OPAQUE;

    external static set JS$_VIGNETTEMODE_OPAQUE(v);

    external static num get VIGNETTEMODE_MULTIPLY;

    external static set VIGNETTEMODE_MULTIPLY(num v);

    external static num get VIGNETTEMODE_OPAQUE;

    external static set VIGNETTEMODE_OPAQUE(num v);
}

@JS("BABYLON.MaterialDefines")
class MaterialDefines {
    // @Ignore
    MaterialDefines .fakeConstructor$();

    external get JS$_keys;

    external set JS$_keys(v);

    external get JS$_isDirty;

    external set JS$_isDirty(v);

    external num get JS$_renderId;

    external set JS$_renderId(num v);

    external bool get JS$_areLightsDirty;

    external set JS$_areLightsDirty(bool v);

    external bool get JS$_areAttributesDirty;

    external set JS$_areAttributesDirty(bool v);

    external bool get JS$_areTexturesDirty;

    external set JS$_areTexturesDirty(bool v);

    external bool get JS$_areFresnelDirty;

    external set JS$_areFresnelDirty(bool v);

    external bool get JS$_areMiscDirty;

    external set JS$_areMiscDirty(bool v);

    external bool get JS$_areImageProcessingDirty;

    external set JS$_areImageProcessingDirty(bool v);

    external bool get JS$_normals;

    external set JS$_normals(bool v);

    external bool get JS$_uvs;

    external set JS$_uvs(bool v);

    external bool get JS$_needNormals;

    external set JS$_needNormals(bool v);

    external bool get JS$_needUVs;

    external set JS$_needUVs(bool v);

    external bool get isDirty;

    external set isDirty(bool v);

    external void markAsProcessed();

    external void markAsUnprocessed();

    external void markAllAsDirty();

    external void markAsImageProcessingDirty();

    external void markAsLightDirty();

    external void markAsAttributesDirty();

    external void markAsTexturesDirty();

    external void markAsFresnelDirty();

    external void markAsMiscDirty();

    external void rebuild();

    external bool isEqual(MaterialDefines other);

    external void cloneTo(MaterialDefines other);

    external void reset();

    external String toString();
}

@JS("BABYLON.Material")
class Material implements IAnimatable {
    // @Ignore
    Material .fakeConstructor$();

    external static get JS$_TriangleFillMode;

    external static set JS$_TriangleFillMode(v);

    external static get JS$_WireFrameFillMode;

    external static set JS$_WireFrameFillMode(v);

    external static get JS$_PointFillMode;

    external static set JS$_PointFillMode(v);

    external static get JS$_PointListDrawMode;

    external static set JS$_PointListDrawMode(v);

    external static get JS$_LineListDrawMode;

    external static set JS$_LineListDrawMode(v);

    external static get JS$_LineLoopDrawMode;

    external static set JS$_LineLoopDrawMode(v);

    external static get JS$_LineStripDrawMode;

    external static set JS$_LineStripDrawMode(v);

    external static get JS$_TriangleStripDrawMode;

    external static set JS$_TriangleStripDrawMode(v);

    external static get JS$_TriangleFanDrawMode;

    external static set JS$_TriangleFanDrawMode(v);

    external static num get TriangleFillMode;

    external static set TriangleFillMode(num v);

    external static num get WireFrameFillMode;

    external static set WireFrameFillMode(num v);

    external static num get PointFillMode;

    external static set PointFillMode(num v);

    external static num get PointListDrawMode;

    external static set PointListDrawMode(num v);

    external static num get LineListDrawMode;

    external static set LineListDrawMode(num v);

    external static num get LineLoopDrawMode;

    external static set LineLoopDrawMode(num v);

    external static num get LineStripDrawMode;

    external static set LineStripDrawMode(num v);

    external static num get TriangleStripDrawMode;

    external static set TriangleStripDrawMode(num v);

    external static num get TriangleFanDrawMode;

    external static set TriangleFanDrawMode(num v);

    external static get JS$_ClockWiseSideOrientation;

    external static set JS$_ClockWiseSideOrientation(v);

    external static get JS$_CounterClockWiseSideOrientation;

    external static set JS$_CounterClockWiseSideOrientation(v);

    external static num get ClockWiseSideOrientation;

    external static set ClockWiseSideOrientation(num v);

    external static num get CounterClockWiseSideOrientation;

    external static set CounterClockWiseSideOrientation(num v);

    external static num get TextureDirtyFlag;

    external static set TextureDirtyFlag(num v);

    external static num get LightDirtyFlag;

    external static set LightDirtyFlag(num v);

    external static num get FresnelDirtyFlag;

    external static set FresnelDirtyFlag(num v);

    external static num get AttributesDirtyFlag;

    external static set AttributesDirtyFlag(num v);

    external static num get MiscDirtyFlag;

    external static set MiscDirtyFlag(num v);

    external static num get AllDirtyFlag;

    external static set AllDirtyFlag(num v);

    external String get id;

    external set id(String v);

    external num get uniqueId;

    external set uniqueId(num v);

    external String get name;

    external set name(String v);

    external bool get checkReadyOnEveryCall;

    external set checkReadyOnEveryCall(bool v);

    external bool get checkReadyOnlyOnce;

    external set checkReadyOnlyOnce(bool v);

    external String get state;

    external set state(String v);

    external num get JS$_alpha;

    external set JS$_alpha(num v);

    external num get alpha;

    external set alpha(num v);

    external bool get JS$_backFaceCulling;

    external set JS$_backFaceCulling(bool v);

    external bool get backFaceCulling;

    external set backFaceCulling(bool v);

    external num get sideOrientation;

    external set sideOrientation(num v);

    external VoidFunc1<Effect> get onCompiled;

    external set onCompiled(VoidFunc1<Effect> v);

    external VoidFunc2<Effect, String> get onError;

    external set onError(VoidFunc2<Effect, String> v);

    external Func0<SmartArray<RenderTargetTexture>> get getRenderTargetTextures;

    external set getRenderTargetTextures(Func0<SmartArray<RenderTargetTexture>> v);

    external bool get hasRenderTargetTextures;

    external set hasRenderTargetTextures(bool v);

    external bool get doNotSerialize;

    external set doNotSerialize(bool v);

    external bool get storeEffectOnSubMeshes;

    external set storeEffectOnSubMeshes(bool v);

    external List<Animation> get animations;

    external set animations(List<Animation> v);

    external Observable<Material> get onDisposeObservable;

    external set onDisposeObservable(Observable<Material> v);

    external get JS$_onDisposeObserver;

    external set JS$_onDisposeObserver(v);

    external get JS$_onUnBindObservable;

    external set JS$_onUnBindObservable(v);

    external VoidFunc0 get onDispose;

    external set onDispose(VoidFunc0 v);

    external get JS$_onBindObservable;

    external set JS$_onBindObservable(v);

    external Observable<AbstractMesh> get onBindObservable;

    external set onBindObservable(Observable<AbstractMesh> v);

    external get JS$_onBindObserver;

    external set JS$_onBindObserver(v);

    external VoidFunc1<AbstractMesh> get onBind;

    external set onBind(VoidFunc1<AbstractMesh> v);

    external Observable<Material> get onUnBindObservable;

    external set onUnBindObservable(Observable<Material> v);

    external get JS$_alphaMode;

    external set JS$_alphaMode(v);

    external num get alphaMode;

    external set alphaMode(num v);

    external get JS$_needDepthPrePass;

    external set JS$_needDepthPrePass(v);

    external bool get needDepthPrePass;

    external set needDepthPrePass(bool v);

    external bool get disableDepthWrite;

    external set disableDepthWrite(bool v);

    external bool get forceDepthWrite;

    external set forceDepthWrite(bool v);

    external bool get separateCullingPass;

    external set separateCullingPass(bool v);

    external get JS$_fogEnabled;

    external set JS$_fogEnabled(v);

    external bool get fogEnabled;

    external set fogEnabled(bool v);

    external num get pointSize;

    external set pointSize(num v);

    external num get zOffset;

    external set zOffset(num v);

    external bool get wireframe;

    external set wireframe(bool v);

    external bool get pointsCloud;

    external set pointsCloud(bool v);

    external num get fillMode;

    external set fillMode(num v);

    external Effect/*Effect|Null*/ get JS$_effect;

    external set JS$_effect(Effect/*Effect|Null*/ v);

    external bool get JS$_wasPreviouslyReady;

    external set JS$_wasPreviouslyReady(bool v);

    external get JS$_useUBO;

    external set JS$_useUBO(v);

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_fillMode;

    external set JS$_fillMode(v);

    external get JS$_cachedDepthWriteState;

    external set JS$_cachedDepthWriteState(v);

    external UniformBuffer get JS$_uniformBuffer;

    external set JS$_uniformBuffer(UniformBuffer v);

    external factory Material(String name, Scene scene, [bool doNotAdd]);

    external String toString([bool fullDetails]);

    external String getClassName();

    external bool get isFrozen;

    external set isFrozen(bool v);

    external void freeze();

    external void unfreeze();

    external bool isReady([AbstractMesh mesh, bool useInstances]);

    external bool isReadyForSubMesh(AbstractMesh mesh, BaseSubMesh subMesh, [bool useInstances]);

    external Effect/*Effect|Null*/ getEffect();

    external Scene getScene();

    external bool needAlphaBlending();

    external bool needAlphaBlendingForMesh(AbstractMesh mesh);

    external bool needAlphaTesting();

    external BaseTexture/*BaseTexture|Null*/ getAlphaTestTexture();

    external void markDirty();

    external bool JS$_preBind([Effect effect, num/*num|Null*/ overrideOrientation]);

    external void bind(Matrix world, [Mesh mesh]);

    external void bindForSubMesh(Matrix world, Mesh mesh, SubMesh subMesh);

    external void bindOnlyWorldMatrix(Matrix world);

    external void bindSceneUniformBuffer(Effect effect, UniformBuffer sceneUbo);

    external void bindView(Effect effect);

    external void bindViewProjection(Effect effect);

    external bool JS$_shouldTurnAlphaTestOn(AbstractMesh mesh);

    external void JS$_afterBind([Mesh mesh]);

    external void unbind();

    external List<BaseTexture> getActiveTextures();

    external bool hasTexture(BaseTexture texture);

    external Material/*Material|Null*/ clone(String name);

    external List<AbstractMesh> getBindedMeshes();

    external void forceCompilation(AbstractMesh mesh, [void onCompiled(Material material), Partial<dynamic /*{
            clipPlane: boolean;
        }*/> options]);

    external Promise<Null> forceCompilationAsync(AbstractMesh mesh, [Partial<dynamic /*{
            clipPlane: boolean;
        }*/> options]);

    external void markAsDirty(num flag);

    external void JS$_markAllSubMeshesAsDirty(void func(MaterialDefines defines));

    external void JS$_markAllSubMeshesAsImageProcessingDirty();

    external void JS$_markAllSubMeshesAsTexturesDirty();

    external void JS$_markAllSubMeshesAsFresnelDirty();

    external void JS$_markAllSubMeshesAsFresnelAndMiscDirty();

    external void JS$_markAllSubMeshesAsLightsDirty();

    external void JS$_markAllSubMeshesAsAttributesDirty();

    external void JS$_markAllSubMeshesAsMiscDirty();

    external void JS$_markAllSubMeshesAsTexturesAndMiscDirty();

    external void dispose([bool forceDisposeEffect, bool forceDisposeTextures]);

    external dynamic serialize();

    external static MultiMaterial ParseMultiMaterial(dynamic parsedMultiMaterial, Scene scene);

    external static dynamic Parse(dynamic parsedMaterial, Scene scene, String rootUrl);
}

@JS("BABYLON.MaterialHelper")
class MaterialHelper {
    // @Ignore
    MaterialHelper .fakeConstructor$();

    external static void BindEyePosition(Effect effect, Scene scene);

    external static void PrepareDefinesForMergedUV(BaseTexture texture, dynamic defines, String key);

    external static void BindTextureMatrix(BaseTexture texture, UniformBuffer uniformBuffer, String key);

    external static void PrepareDefinesForMisc(AbstractMesh mesh, Scene scene, bool useLogarithmicDepth, bool pointsCloud, bool fogEnabled, bool alphaTest, dynamic defines);

    external static void PrepareDefinesForFrameBoundValues(Scene scene, Engine engine, dynamic defines, bool useInstances, [bool/*bool|Null*/ useClipPlane]);

    external static bool PrepareDefinesForAttributes(AbstractMesh mesh, dynamic defines, bool useVertexColor, bool useBones, [bool useMorphTargets, bool useVertexAlpha]);

    external static bool PrepareDefinesForLights(Scene scene, AbstractMesh mesh, dynamic defines, bool specularSupported, [num maxSimultaneousLights, bool disableLighting]);

    external static void PrepareUniformsAndSamplersList(dynamic/*List<String>|EffectCreationOptions*/ uniformsListOrOptions, [List<String> samplersList, dynamic defines, num maxSimultaneousLights]);

    external static num HandleFallbacksForShadows(dynamic defines, EffectFallbacks fallbacks, [num maxSimultaneousLights, num rank]);

    external static void PrepareAttributesForMorphTargets(List<String> attribs, AbstractMesh mesh, dynamic defines);

    external static void PrepareAttributesForBones(List<String> attribs, AbstractMesh mesh, dynamic defines, EffectFallbacks fallbacks);

    external static void PrepareAttributesForInstances(List<String> attribs, dynamic defines);

    external static void BindLightShadow(Light light, Scene scene, AbstractMesh mesh, String lightIndex, Effect effect);

    external static void BindLightProperties(Light light, Effect effect, num lightIndex);

    external static void BindLights(Scene scene, AbstractMesh mesh, Effect effect, dynamic defines, [num maxSimultaneousLights, bool usePhysicalLightFalloff]);

    external static get JS$_tempFogColor;

    external static set JS$_tempFogColor(v);

    external static void BindFogParameters(Scene scene, AbstractMesh mesh, Effect effect, [bool linearSpace]);

    external static void BindBonesParameters([AbstractMesh mesh, Effect effect]);

    external static void BindMorphTargetParameters(AbstractMesh abstractMesh, Effect effect);

    external static void BindLogDepth(dynamic defines, Effect effect, Scene scene);

    external static void BindClipPlane(Effect effect, Scene scene);
}

@JS("BABYLON.MultiMaterial")
class MultiMaterial extends Material {
    // @Ignore
    MultiMaterial .fakeConstructor$() : super.fakeConstructor$();
    external get JS$_subMaterials;

    external set JS$_subMaterials(v);

    external List<Material /*Material|Null*/> get subMaterials;

    external set subMaterials(List<Material /*Material|Null*/> v);

    external factory MultiMaterial(String name, Scene scene);

    external get JS$_hookArray;

    external set JS$_hookArray(v);

    external Material/*Material|Null*/ getSubMaterial(num index);

    external List<BaseTexture> getActiveTextures();

    external String getClassName();

    external bool isReadyForSubMesh(AbstractMesh mesh, BaseSubMesh subMesh, [bool useInstances]);

    external MultiMaterial clone(String name, [bool cloneChildren]);

    external dynamic serialize();

    external void dispose([bool forceDisposeEffect, bool forceDisposeTextures]);
}

@JS("BABYLON.PushMaterial")
class PushMaterial extends Material {
    // @Ignore
    PushMaterial .fakeConstructor$() : super.fakeConstructor$();
    external Effect get JS$_activeEffect;

    external set JS$_activeEffect(Effect v);

    external Matrix get JS$_normalMatrix;

    external set JS$_normalMatrix(Matrix v);

    external factory PushMaterial(String name, Scene scene);

    external Effect getEffect();

    external bool isReady([AbstractMesh mesh, bool useInstances]);

    external void bindOnlyWorldMatrix(Matrix world);

    external void bindOnlyNormalMatrix(Matrix normalMatrix);

    external void bind(Matrix world, [Mesh mesh]);

    external void JS$_afterBind(Mesh mesh, [Effect/*Effect|Null*/ effect]);

    external bool JS$_mustRebind(Scene scene, Effect effect, [num visibility]);
}

@anonymous
@JS()
abstract class IShaderMaterialOptions {
    external bool get needAlphaBlending;

    external set needAlphaBlending(bool v);

    external bool get needAlphaTesting;

    external set needAlphaTesting(bool v);

    external List<String> get attributes;

    external set attributes(List<String> v);

    external List<String> get uniforms;

    external set uniforms(List<String> v);

    external List<String> get uniformBuffers;

    external set uniformBuffers(List<String> v);

    external List<String> get samplers;

    external set samplers(List<String> v);

    external List<String> get defines;

    external set defines(List<String> v);

    external factory IShaderMaterialOptions({ bool needAlphaBlending, bool needAlphaTesting, List<String> attributes, List<String> uniforms, List<String> uniformBuffers, List<String> samplers, List<String> defines});
}

@JS("BABYLON.ShaderMaterial")
class ShaderMaterial extends Material {
    // @Ignore
    ShaderMaterial .fakeConstructor$() : super.fakeConstructor$();
    external get JS$_shaderPath;

    external set JS$_shaderPath(v);

    external get JS$_options;

    external set JS$_options(v);

    external get JS$_textures;

    external set JS$_textures(v);

    external get JS$_textureArrays;

    external set JS$_textureArrays(v);

    external get JS$_floats;

    external set JS$_floats(v);

    external get JS$_ints;

    external set JS$_ints(v);

    external get JS$_floatsArrays;

    external set JS$_floatsArrays(v);

    external get JS$_colors3;

    external set JS$_colors3(v);

    external get JS$_colors3Arrays;

    external set JS$_colors3Arrays(v);

    external get JS$_colors4;

    external set JS$_colors4(v);

    external get JS$_vectors2;

    external set JS$_vectors2(v);

    external get JS$_vectors3;

    external set JS$_vectors3(v);

    external get JS$_vectors4;

    external set JS$_vectors4(v);

    external get JS$_matrices;

    external set JS$_matrices(v);

    external get JS$_matrices3x3;

    external set JS$_matrices3x3(v);

    external get JS$_matrices2x2;

    external set JS$_matrices2x2(v);

    external get JS$_vectors2Arrays;

    external set JS$_vectors2Arrays(v);

    external get JS$_vectors3Arrays;

    external set JS$_vectors3Arrays(v);

    external get JS$_cachedWorldViewMatrix;

    external set JS$_cachedWorldViewMatrix(v);

    external get JS$_renderId;

    external set JS$_renderId(v);

    external factory ShaderMaterial(String name, Scene scene, dynamic shaderPath, [Partial<IShaderMaterialOptions> options]);

    external String getClassName();

    external bool needAlphaBlending();

    external bool needAlphaTesting();

    external get JS$_checkUniform;

    external set JS$_checkUniform(v);

    external ShaderMaterial setTexture(String name, Texture texture);

    external ShaderMaterial setTextureArray(String name, List<Texture> textures);

    external ShaderMaterial setFloat(String name, num value);

    external ShaderMaterial setInt(String name, num value);

    external ShaderMaterial setFloats(String name, List<num> value);

    external ShaderMaterial setColor3(String name, Color3 value);

    external ShaderMaterial setColor3Array(String name, List<Color3> value);

    external ShaderMaterial setColor4(String name, Color4 value);

    external ShaderMaterial setVector2(String name, Vector2 value);

    external ShaderMaterial setVector3(String name, Vector3 value);

    external ShaderMaterial setVector4(String name, Vector4 value);

    external ShaderMaterial setMatrix(String name, Matrix value);

    external ShaderMaterial setMatrix3x3(String name, Float32List value);

    external ShaderMaterial setMatrix2x2(String name, Float32List value);

    external ShaderMaterial setArray2(String name, List<num> value);

    external ShaderMaterial setArray3(String name, List<num> value);

    external get JS$_checkCache;

    external set JS$_checkCache(v);

    external bool isReady([AbstractMesh mesh, bool useInstances]);

    external void bindOnlyWorldMatrix(Matrix world);

    external void bind(Matrix world, [Mesh mesh]);

    external List<BaseTexture> getActiveTextures();

    external bool hasTexture(BaseTexture texture);

    external ShaderMaterial clone(String name);

    external void dispose([bool forceDisposeEffect, bool forceDisposeTextures]);

    external dynamic serialize();

    external static ShaderMaterial Parse(dynamic source, Scene scene, String rootUrl);
}

@JS("BABYLON.StandardMaterialDefines")
class StandardMaterialDefines extends MaterialDefines implements IImageProcessingConfigurationDefines {
    // @Ignore
    StandardMaterialDefines .fakeConstructor$() : super.fakeConstructor$();
    external bool get MAINUV1;

    external set MAINUV1(bool v);

    external bool get MAINUV2;

    external set MAINUV2(bool v);

    external bool get DIFFUSE;

    external set DIFFUSE(bool v);

    external num get DIFFUSEDIRECTUV;

    external set DIFFUSEDIRECTUV(num v);

    external bool get AMBIENT;

    external set AMBIENT(bool v);

    external num get AMBIENTDIRECTUV;

    external set AMBIENTDIRECTUV(num v);

    external bool get OPACITY;

    external set OPACITY(bool v);

    external num get OPACITYDIRECTUV;

    external set OPACITYDIRECTUV(num v);

    external bool get OPACITYRGB;

    external set OPACITYRGB(bool v);

    external bool get REFLECTION;

    external set REFLECTION(bool v);

    external bool get EMISSIVE;

    external set EMISSIVE(bool v);

    external num get EMISSIVEDIRECTUV;

    external set EMISSIVEDIRECTUV(num v);

    external bool get SPECULAR;

    external set SPECULAR(bool v);

    external num get SPECULARDIRECTUV;

    external set SPECULARDIRECTUV(num v);

    external bool get BUMP;

    external set BUMP(bool v);

    external num get BUMPDIRECTUV;

    external set BUMPDIRECTUV(num v);

    external bool get PARALLAX;

    external set PARALLAX(bool v);

    external bool get PARALLAXOCCLUSION;

    external set PARALLAXOCCLUSION(bool v);

    external bool get SPECULAROVERALPHA;

    external set SPECULAROVERALPHA(bool v);

    external bool get CLIPPLANE;

    external set CLIPPLANE(bool v);

    external bool get CLIPPLANE2;

    external set CLIPPLANE2(bool v);

    external bool get CLIPPLANE3;

    external set CLIPPLANE3(bool v);

    external bool get CLIPPLANE4;

    external set CLIPPLANE4(bool v);

    external bool get ALPHATEST;

    external set ALPHATEST(bool v);

    external bool get DEPTHPREPASS;

    external set DEPTHPREPASS(bool v);

    external bool get ALPHAFROMDIFFUSE;

    external set ALPHAFROMDIFFUSE(bool v);

    external bool get POINTSIZE;

    external set POINTSIZE(bool v);

    external bool get FOG;

    external set FOG(bool v);

    external bool get SPECULARTERM;

    external set SPECULARTERM(bool v);

    external bool get DIFFUSEFRESNEL;

    external set DIFFUSEFRESNEL(bool v);

    external bool get OPACITYFRESNEL;

    external set OPACITYFRESNEL(bool v);

    external bool get REFLECTIONFRESNEL;

    external set REFLECTIONFRESNEL(bool v);

    external bool get REFRACTIONFRESNEL;

    external set REFRACTIONFRESNEL(bool v);

    external bool get EMISSIVEFRESNEL;

    external set EMISSIVEFRESNEL(bool v);

    external bool get FRESNEL;

    external set FRESNEL(bool v);

    external bool get NORMAL;

    external set NORMAL(bool v);

    external bool get UV1;

    external set UV1(bool v);

    external bool get UV2;

    external set UV2(bool v);

    external bool get VERTEXCOLOR;

    external set VERTEXCOLOR(bool v);

    external bool get VERTEXALPHA;

    external set VERTEXALPHA(bool v);

    external num get NUM_BONE_INFLUENCERS;

    external set NUM_BONE_INFLUENCERS(num v);

    external num get BonesPerMesh;

    external set BonesPerMesh(num v);

    external bool get INSTANCES;

    external set INSTANCES(bool v);

    external bool get GLOSSINESS;

    external set GLOSSINESS(bool v);

    external bool get ROUGHNESS;

    external set ROUGHNESS(bool v);

    external bool get EMISSIVEASILLUMINATION;

    external set EMISSIVEASILLUMINATION(bool v);

    external bool get LINKEMISSIVEWITHDIFFUSE;

    external set LINKEMISSIVEWITHDIFFUSE(bool v);

    external bool get REFLECTIONFRESNELFROMSPECULAR;

    external set REFLECTIONFRESNELFROMSPECULAR(bool v);

    external bool get LIGHTMAP;

    external set LIGHTMAP(bool v);

    external num get LIGHTMAPDIRECTUV;

    external set LIGHTMAPDIRECTUV(num v);

    external bool get OBJECTSPACE_NORMALMAP;

    external set OBJECTSPACE_NORMALMAP(bool v);

    external bool get USELIGHTMAPASSHADOWMAP;

    external set USELIGHTMAPASSHADOWMAP(bool v);

    external bool get REFLECTIONMAP_3D;

    external set REFLECTIONMAP_3D(bool v);

    external bool get REFLECTIONMAP_SPHERICAL;

    external set REFLECTIONMAP_SPHERICAL(bool v);

    external bool get REFLECTIONMAP_PLANAR;

    external set REFLECTIONMAP_PLANAR(bool v);

    external bool get REFLECTIONMAP_CUBIC;

    external set REFLECTIONMAP_CUBIC(bool v);

    external bool get USE_LOCAL_REFLECTIONMAP_CUBIC;

    external set USE_LOCAL_REFLECTIONMAP_CUBIC(bool v);

    external bool get REFLECTIONMAP_PROJECTION;

    external set REFLECTIONMAP_PROJECTION(bool v);

    external bool get REFLECTIONMAP_SKYBOX;

    external set REFLECTIONMAP_SKYBOX(bool v);

    external bool get REFLECTIONMAP_SKYBOX_TRANSFORMED;

    external set REFLECTIONMAP_SKYBOX_TRANSFORMED(bool v);

    external bool get REFLECTIONMAP_EXPLICIT;

    external set REFLECTIONMAP_EXPLICIT(bool v);

    external bool get REFLECTIONMAP_EQUIRECTANGULAR;

    external set REFLECTIONMAP_EQUIRECTANGULAR(bool v);

    external bool get REFLECTIONMAP_EQUIRECTANGULAR_FIXED;

    external set REFLECTIONMAP_EQUIRECTANGULAR_FIXED(bool v);

    external bool get REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED;

    external set REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED(bool v);

    external bool get INVERTCUBICMAP;

    external set INVERTCUBICMAP(bool v);

    external bool get LOGARITHMICDEPTH;

    external set LOGARITHMICDEPTH(bool v);

    external bool get REFRACTION;

    external set REFRACTION(bool v);

    external bool get REFRACTIONMAP_3D;

    external set REFRACTIONMAP_3D(bool v);

    external bool get REFLECTIONOVERALPHA;

    external set REFLECTIONOVERALPHA(bool v);

    external bool get TWOSIDEDLIGHTING;

    external set TWOSIDEDLIGHTING(bool v);

    external bool get SHADOWFLOAT;

    external set SHADOWFLOAT(bool v);

    external bool get MORPHTARGETS;

    external set MORPHTARGETS(bool v);

    external bool get MORPHTARGETS_NORMAL;

    external set MORPHTARGETS_NORMAL(bool v);

    external bool get MORPHTARGETS_TANGENT;

    external set MORPHTARGETS_TANGENT(bool v);

    external num get NUM_MORPH_INFLUENCERS;

    external set NUM_MORPH_INFLUENCERS(num v);

    external bool get NONUNIFORMSCALING;

    external set NONUNIFORMSCALING(bool v);

    external bool get PREMULTIPLYALPHA;

    external set PREMULTIPLYALPHA(bool v);

    external bool get IMAGEPROCESSING;

    external set IMAGEPROCESSING(bool v);

    external bool get VIGNETTE;

    external set VIGNETTE(bool v);

    external bool get VIGNETTEBLENDMODEMULTIPLY;

    external set VIGNETTEBLENDMODEMULTIPLY(bool v);

    external bool get VIGNETTEBLENDMODEOPAQUE;

    external set VIGNETTEBLENDMODEOPAQUE(bool v);

    external bool get TONEMAPPING;

    external set TONEMAPPING(bool v);

    external bool get TONEMAPPING_ACES;

    external set TONEMAPPING_ACES(bool v);

    external bool get CONTRAST;

    external set CONTRAST(bool v);

    external bool get COLORCURVES;

    external set COLORCURVES(bool v);

    external bool get COLORGRADING;

    external set COLORGRADING(bool v);

    external bool get COLORGRADING3D;

    external set COLORGRADING3D(bool v);

    external bool get SAMPLER3DGREENDEPTH;

    external set SAMPLER3DGREENDEPTH(bool v);

    external bool get SAMPLER3DBGRMAP;

    external set SAMPLER3DBGRMAP(bool v);

    external bool get IMAGEPROCESSINGPOSTPROCESS;

    external set IMAGEPROCESSINGPOSTPROCESS(bool v);

    external bool get IS_REFLECTION_LINEAR;

    external set IS_REFLECTION_LINEAR(bool v);

    external bool get IS_REFRACTION_LINEAR;

    external set IS_REFRACTION_LINEAR(bool v);

    external bool get EXPOSURE;

    external set EXPOSURE(bool v);

    external factory StandardMaterialDefines();

    external void setReflectionMode(String modeToEnable);
}

@JS("BABYLON.StandardMaterial")
class StandardMaterial extends PushMaterial {
    // @Ignore
    StandardMaterial .fakeConstructor$() : super.fakeConstructor$();
    external get JS$_diffuseTexture;

    external set JS$_diffuseTexture(v);

    external BaseTexture/*BaseTexture|Null*/ get diffuseTexture;

    external set diffuseTexture(BaseTexture/*BaseTexture|Null*/ v);

    external get JS$_ambientTexture;

    external set JS$_ambientTexture(v);

    external BaseTexture/*BaseTexture|Null*/ get ambientTexture;

    external set ambientTexture(BaseTexture/*BaseTexture|Null*/ v);

    external get JS$_opacityTexture;

    external set JS$_opacityTexture(v);

    external BaseTexture/*BaseTexture|Null*/ get opacityTexture;

    external set opacityTexture(BaseTexture/*BaseTexture|Null*/ v);

    external get JS$_reflectionTexture;

    external set JS$_reflectionTexture(v);

    external BaseTexture/*BaseTexture|Null*/ get reflectionTexture;

    external set reflectionTexture(BaseTexture/*BaseTexture|Null*/ v);

    external get JS$_emissiveTexture;

    external set JS$_emissiveTexture(v);

    external BaseTexture/*BaseTexture|Null*/ get emissiveTexture;

    external set emissiveTexture(BaseTexture/*BaseTexture|Null*/ v);

    external get JS$_specularTexture;

    external set JS$_specularTexture(v);

    external BaseTexture/*BaseTexture|Null*/ get specularTexture;

    external set specularTexture(BaseTexture/*BaseTexture|Null*/ v);

    external get JS$_bumpTexture;

    external set JS$_bumpTexture(v);

    external BaseTexture/*BaseTexture|Null*/ get bumpTexture;

    external set bumpTexture(BaseTexture/*BaseTexture|Null*/ v);

    external get JS$_lightmapTexture;

    external set JS$_lightmapTexture(v);

    external BaseTexture/*BaseTexture|Null*/ get lightmapTexture;

    external set lightmapTexture(BaseTexture/*BaseTexture|Null*/ v);

    external get JS$_refractionTexture;

    external set JS$_refractionTexture(v);

    external BaseTexture/*BaseTexture|Null*/ get refractionTexture;

    external set refractionTexture(BaseTexture/*BaseTexture|Null*/ v);

    external Color3 get ambientColor;

    external set ambientColor(Color3 v);

    external Color3 get diffuseColor;

    external set diffuseColor(Color3 v);

    external Color3 get specularColor;

    external set specularColor(Color3 v);

    external Color3 get emissiveColor;

    external set emissiveColor(Color3 v);

    external num get specularPower;

    external set specularPower(num v);

    external get JS$_useAlphaFromDiffuseTexture;

    external set JS$_useAlphaFromDiffuseTexture(v);

    external bool get useAlphaFromDiffuseTexture;

    external set useAlphaFromDiffuseTexture(bool v);

    external get JS$_useEmissiveAsIllumination;

    external set JS$_useEmissiveAsIllumination(v);

    external bool get useEmissiveAsIllumination;

    external set useEmissiveAsIllumination(bool v);

    external get JS$_linkEmissiveWithDiffuse;

    external set JS$_linkEmissiveWithDiffuse(v);

    external bool get linkEmissiveWithDiffuse;

    external set linkEmissiveWithDiffuse(bool v);

    external get JS$_useSpecularOverAlpha;

    external set JS$_useSpecularOverAlpha(v);

    external bool get useSpecularOverAlpha;

    external set useSpecularOverAlpha(bool v);

    external get JS$_useReflectionOverAlpha;

    external set JS$_useReflectionOverAlpha(v);

    external bool get useReflectionOverAlpha;

    external set useReflectionOverAlpha(bool v);

    external get JS$_disableLighting;

    external set JS$_disableLighting(v);

    external bool get disableLighting;

    external set disableLighting(bool v);

    external get JS$_useObjectSpaceNormalMap;

    external set JS$_useObjectSpaceNormalMap(v);

    external bool get useObjectSpaceNormalMap;

    external set useObjectSpaceNormalMap(bool v);

    external get JS$_useParallax;

    external set JS$_useParallax(v);

    external bool get useParallax;

    external set useParallax(bool v);

    external get JS$_useParallaxOcclusion;

    external set JS$_useParallaxOcclusion(v);

    external bool get useParallaxOcclusion;

    external set useParallaxOcclusion(bool v);

    external num get parallaxScaleBias;

    external set parallaxScaleBias(num v);

    external get JS$_roughness;

    external set JS$_roughness(v);

    external num get roughness;

    external set roughness(num v);

    external num get indexOfRefraction;

    external set indexOfRefraction(num v);

    external bool get invertRefractionY;

    external set invertRefractionY(bool v);

    external num get alphaCutOff;

    external set alphaCutOff(num v);

    external get JS$_useLightmapAsShadowmap;

    external set JS$_useLightmapAsShadowmap(v);

    external bool get useLightmapAsShadowmap;

    external set useLightmapAsShadowmap(bool v);

    external get JS$_diffuseFresnelParameters;

    external set JS$_diffuseFresnelParameters(v);

    external FresnelParameters get diffuseFresnelParameters;

    external set diffuseFresnelParameters(FresnelParameters v);

    external get JS$_opacityFresnelParameters;

    external set JS$_opacityFresnelParameters(v);

    external FresnelParameters get opacityFresnelParameters;

    external set opacityFresnelParameters(FresnelParameters v);

    external get JS$_reflectionFresnelParameters;

    external set JS$_reflectionFresnelParameters(v);

    external FresnelParameters get reflectionFresnelParameters;

    external set reflectionFresnelParameters(FresnelParameters v);

    external get JS$_refractionFresnelParameters;

    external set JS$_refractionFresnelParameters(v);

    external FresnelParameters get refractionFresnelParameters;

    external set refractionFresnelParameters(FresnelParameters v);

    external get JS$_emissiveFresnelParameters;

    external set JS$_emissiveFresnelParameters(v);

    external FresnelParameters get emissiveFresnelParameters;

    external set emissiveFresnelParameters(FresnelParameters v);

    external get JS$_useReflectionFresnelFromSpecular;

    external set JS$_useReflectionFresnelFromSpecular(v);

    external bool get useReflectionFresnelFromSpecular;

    external set useReflectionFresnelFromSpecular(bool v);

    external get JS$_useGlossinessFromSpecularMapAlpha;

    external set JS$_useGlossinessFromSpecularMapAlpha(v);

    external bool get useGlossinessFromSpecularMapAlpha;

    external set useGlossinessFromSpecularMapAlpha(bool v);

    external get JS$_maxSimultaneousLights;

    external set JS$_maxSimultaneousLights(v);

    external num get maxSimultaneousLights;

    external set maxSimultaneousLights(num v);

    external get JS$_invertNormalMapX;

    external set JS$_invertNormalMapX(v);

    external bool get invertNormalMapX;

    external set invertNormalMapX(bool v);

    external get JS$_invertNormalMapY;

    external set JS$_invertNormalMapY(v);

    external bool get invertNormalMapY;

    external set invertNormalMapY(bool v);

    external get JS$_twoSidedLighting;

    external set JS$_twoSidedLighting(v);

    external bool get twoSidedLighting;

    external set twoSidedLighting(bool v);

    external ImageProcessingConfiguration get JS$_imageProcessingConfiguration;

    external set JS$_imageProcessingConfiguration(ImageProcessingConfiguration v);

    external ImageProcessingConfiguration get imageProcessingConfiguration;

    external set imageProcessingConfiguration(ImageProcessingConfiguration v);

    external get JS$_imageProcessingObserver;

    external set JS$_imageProcessingObserver(v);

    external void JS$_attachImageProcessingConfiguration(ImageProcessingConfiguration/*ImageProcessingConfiguration|Null*/ configuration);

    external bool get cameraColorCurvesEnabled;

    external set cameraColorCurvesEnabled(bool v);

    external bool get cameraColorGradingEnabled;

    external set cameraColorGradingEnabled(bool v);

    external bool get cameraToneMappingEnabled;

    external set cameraToneMappingEnabled(bool v);

    external num get cameraExposure;

    external set cameraExposure(num v);

    external num get cameraContrast;

    external set cameraContrast(num v);

    external BaseTexture/*BaseTexture|Null*/ get cameraColorGradingTexture;

    external set cameraColorGradingTexture(BaseTexture/*BaseTexture|Null*/ v);

    external ColorCurves/*ColorCurves|Null*/ get cameraColorCurves;

    external set cameraColorCurves(ColorCurves/*ColorCurves|Null*/ v);

    external Function/*(shaderName: string, uniforms: string[], uniformBuffers: string[], samplers: string[], defines: StandardMaterialDefines) => string*/ get customShaderNameResolve;

    external set customShaderNameResolve(Function/*(shaderName: string, uniforms: string[], uniformBuffers: string[], samplers: string[], defines: StandardMaterialDefines) => string*/ v);

    external SmartArray<RenderTargetTexture> get JS$_renderTargets;

    external set JS$_renderTargets(SmartArray<RenderTargetTexture> v);

    external Matrix get JS$_worldViewProjectionMatrix;

    external set JS$_worldViewProjectionMatrix(Matrix v);

    external Color3 get JS$_globalAmbientColor;

    external set JS$_globalAmbientColor(Color3 v);

    external bool get JS$_useLogarithmicDepth;

    external set JS$_useLogarithmicDepth(bool v);

    external factory StandardMaterial(String name, Scene scene);

    external bool get hasRenderTargetTextures;

    external set hasRenderTargetTextures(bool v);

    external String getClassName();

    external bool get useLogarithmicDepth;

    external set useLogarithmicDepth(bool v);

    external bool needAlphaBlending();

    external bool needAlphaTesting();

    external bool JS$_shouldUseAlphaFromDiffuseTexture();

    external BaseTexture/*BaseTexture|Null*/ getAlphaTestTexture();

    external bool isReadyForSubMesh(AbstractMesh mesh, SubMesh subMesh, [bool useInstances]);

    external void buildUniformLayout();

    external void unbind();

    external void bindForSubMesh(Matrix world, Mesh mesh, SubMesh subMesh);

    external List<IAnimatable> getAnimatables();

    external List<BaseTexture> getActiveTextures();

    external bool hasTexture(BaseTexture texture);

    external void dispose([bool forceDisposeEffect, bool forceDisposeTextures]);

    external StandardMaterial clone(String name);

    external dynamic serialize();

    external static StandardMaterial Parse(dynamic source, Scene scene, String rootUrl);

    external static get JS$_DiffuseTextureEnabled;

    external static set JS$_DiffuseTextureEnabled(v);

    external static bool get DiffuseTextureEnabled;

    external static set DiffuseTextureEnabled(bool v);

    external static get JS$_AmbientTextureEnabled;

    external static set JS$_AmbientTextureEnabled(v);

    external static bool get AmbientTextureEnabled;

    external static set AmbientTextureEnabled(bool v);

    external static get JS$_OpacityTextureEnabled;

    external static set JS$_OpacityTextureEnabled(v);

    external static bool get OpacityTextureEnabled;

    external static set OpacityTextureEnabled(bool v);

    external static get JS$_ReflectionTextureEnabled;

    external static set JS$_ReflectionTextureEnabled(v);

    external static bool get ReflectionTextureEnabled;

    external static set ReflectionTextureEnabled(bool v);

    external static get JS$_EmissiveTextureEnabled;

    external static set JS$_EmissiveTextureEnabled(v);

    external static bool get EmissiveTextureEnabled;

    external static set EmissiveTextureEnabled(bool v);

    external static get JS$_SpecularTextureEnabled;

    external static set JS$_SpecularTextureEnabled(v);

    external static bool get SpecularTextureEnabled;

    external static set SpecularTextureEnabled(bool v);

    external static get JS$_BumpTextureEnabled;

    external static set JS$_BumpTextureEnabled(v);

    external static bool get BumpTextureEnabled;

    external static set BumpTextureEnabled(bool v);

    external static get JS$_LightmapTextureEnabled;

    external static set JS$_LightmapTextureEnabled(v);

    external static bool get LightmapTextureEnabled;

    external static set LightmapTextureEnabled(bool v);

    external static get JS$_RefractionTextureEnabled;

    external static set JS$_RefractionTextureEnabled(v);

    external static bool get RefractionTextureEnabled;

    external static set RefractionTextureEnabled(bool v);

    external static get JS$_ColorGradingTextureEnabled;

    external static set JS$_ColorGradingTextureEnabled(v);

    external static bool get ColorGradingTextureEnabled;

    external static set ColorGradingTextureEnabled(bool v);

    external static get JS$_FresnelEnabled;

    external static set JS$_FresnelEnabled(v);

    external static bool get FresnelEnabled;

    external static set FresnelEnabled(bool v);
}

@JS("BABYLON.UniformBuffer")
class UniformBuffer {
    // @Ignore
    UniformBuffer .fakeConstructor$();

    external get JS$_engine;

    external set JS$_engine(v);

    external get JS$_buffer;

    external set JS$_buffer(v);

    external get JS$_data;

    external set JS$_data(v);

    external get JS$_bufferData;

    external set JS$_bufferData(v);

    external get JS$_dynamic;

    external set JS$_dynamic(v);

    external get JS$_uniformLocations;

    external set JS$_uniformLocations(v);

    external get JS$_uniformSizes;

    external set JS$_uniformSizes(v);

    external get JS$_uniformLocationPointer;

    external set JS$_uniformLocationPointer(v);

    external get JS$_needSync;

    external set JS$_needSync(v);

    external get JS$_noUBO;

    external set JS$_noUBO(v);

    external get JS$_currentEffect;

    external set JS$_currentEffect(v);

    external static get JS$_MAX_UNIFORM_SIZE;

    external static set JS$_MAX_UNIFORM_SIZE(v);

    external static get JS$_tempBuffer;

    external static set JS$_tempBuffer(v);

    external VoidFunc2<String, Float32List> get updateMatrix3x3;

    external set updateMatrix3x3(VoidFunc2<String, Float32List> v);

    external VoidFunc2<String, Float32List> get updateMatrix2x2;

    external set updateMatrix2x2(VoidFunc2<String, Float32List> v);

    external VoidFunc2<String, num> get updateFloat;

    external set updateFloat(VoidFunc2<String, num> v);

    external VoidFunc4Opt1<String, num, num, String> get updateFloat2;

    external set updateFloat2(VoidFunc4Opt1<String, num, num, String> v);

    external Function/*(name: string, x: number, y: number, z: number, suffix?: string) => void*/ get updateFloat3;

    external set updateFloat3(Function/*(name: string, x: number, y: number, z: number, suffix?: string) => void*/ v);

    external Function/*(name: string, x: number, y: number, z: number, w: number, suffix?: string) => void*/ get updateFloat4;

    external set updateFloat4(Function/*(name: string, x: number, y: number, z: number, w: number, suffix?: string) => void*/ v);

    external VoidFunc2<String, Matrix> get updateMatrix;

    external set updateMatrix(VoidFunc2<String, Matrix> v);

    external VoidFunc2<String, Vector3> get updateVector3;

    external set updateVector3(VoidFunc2<String, Vector3> v);

    external VoidFunc2<String, Vector4> get updateVector4;

    external set updateVector4(VoidFunc2<String, Vector4> v);

    external VoidFunc3Opt1<String, Color3, String> get updateColor3;

    external set updateColor3(VoidFunc3Opt1<String, Color3, String> v);

    external VoidFunc4Opt1<String, Color3, num, String> get updateColor4;

    external set updateColor4(VoidFunc4Opt1<String, Color3, num, String> v);

    external factory UniformBuffer(Engine engine, [List<num> data, bool JS$dynamic]);

    external bool get useUbo;

    external set useUbo(bool v);

    external bool get isSync;

    external set isSync(bool v);

    external bool isDynamic();

    external Float32List getData();

    external Buffer/*Buffer|Null*/ getBuffer();

    external get JS$_fillAlignment;

    external set JS$_fillAlignment(v);

    external void addUniform(String name, dynamic/*num|List<num>*/ size);

    external void addMatrix(String name, Matrix mat);

    external void addFloat2(String name, num x, num y);

    external void addFloat3(String name, num x, num y, num z);

    external void addColor3(String name, Color3 color);

    external void addColor4(String name, Color3 color, num alpha);

    external void addVector3(String name, Vector3 vector);

    external void addMatrix3x3(String name);

    external void addMatrix2x2(String name);

    external void create();

    external void JS$_rebuild();

    external void update();

    external void updateUniform(String uniformName, dynamic/*List<num>|Float32List*/ data, num size);

    external get JS$_updateMatrix3x3ForUniform;

    external set JS$_updateMatrix3x3ForUniform(v);

    external get JS$_updateMatrix3x3ForEffect;

    external set JS$_updateMatrix3x3ForEffect(v);

    external get JS$_updateMatrix2x2ForEffect;

    external set JS$_updateMatrix2x2ForEffect(v);

    external get JS$_updateMatrix2x2ForUniform;

    external set JS$_updateMatrix2x2ForUniform(v);

    external get JS$_updateFloatForEffect;

    external set JS$_updateFloatForEffect(v);

    external get JS$_updateFloatForUniform;

    external set JS$_updateFloatForUniform(v);

    external get JS$_updateFloat2ForEffect;

    external set JS$_updateFloat2ForEffect(v);

    external get JS$_updateFloat2ForUniform;

    external set JS$_updateFloat2ForUniform(v);

    external get JS$_updateFloat3ForEffect;

    external set JS$_updateFloat3ForEffect(v);

    external get JS$_updateFloat3ForUniform;

    external set JS$_updateFloat3ForUniform(v);

    external get JS$_updateFloat4ForEffect;

    external set JS$_updateFloat4ForEffect(v);

    external get JS$_updateFloat4ForUniform;

    external set JS$_updateFloat4ForUniform(v);

    external get JS$_updateMatrixForEffect;

    external set JS$_updateMatrixForEffect(v);

    external get JS$_updateMatrixForUniform;

    external set JS$_updateMatrixForUniform(v);

    external get JS$_updateVector3ForEffect;

    external set JS$_updateVector3ForEffect(v);

    external get JS$_updateVector3ForUniform;

    external set JS$_updateVector3ForUniform(v);

    external get JS$_updateVector4ForEffect;

    external set JS$_updateVector4ForEffect(v);

    external get JS$_updateVector4ForUniform;

    external set JS$_updateVector4ForUniform(v);

    external get JS$_updateColor3ForEffect;

    external set JS$_updateColor3ForEffect(v);

    external get JS$_updateColor3ForUniform;

    external set JS$_updateColor3ForUniform(v);

    external get JS$_updateColor4ForEffect;

    external set JS$_updateColor4ForEffect(v);

    external get JS$_updateColor4ForUniform;

    external set JS$_updateColor4ForUniform(v);

    external void setTexture(String name, BaseTexture/*BaseTexture|Null*/ texture);

    external void updateUniformDirectly(String uniformName, dynamic/*List<num>|Float32List*/ data);

    external void bindToEffect(Effect effect, String name);

    external void dispose();
}

@JS("BABYLON.Scalar")
class Scalar {
    // @Ignore
    Scalar .fakeConstructor$();

    external static num get TwoPi;

    external static set TwoPi(num v);

    external static bool WithinEpsilon(num a, num b, [num epsilon]);

    external static String ToHex(num i);

    external static num Sign(num value);

    external static num Clamp(num value, [num min, num max]);

    external static num Log2(num value);

    external static num Repeat(num value, num length);

    external static num Normalize(num value, num min, num max);

    external static num Denormalize(num normalized, num min, num max);

    external static num DeltaAngle(num current, num target);

    external static num PingPong(num tx, num length);

    external static num SmoothStep(num from, num to, num tx);

    external static num MoveTowards(num current, num target, num maxDelta);

    external static num MoveTowardsAngle(num current, num target, num maxDelta);

    external static num Lerp(num start, num end, num amount);

    external static num LerpAngle(num start, num end, num amount);

    external static num InverseLerp(num a, num b, num value);

    external static num Hermite(num value1, num tangent1, num value2, num tangent2, num amount);

    external static num RandomRange(num min, num max);

    external static num RangeToPercent(num number, num min, num max);

    external static num PercentToRange(num percent, num min, num max);

    external static num NormalizeRadians(num angle);
}

@JS("BABYLON.ToGammaSpace")
external num get ToGammaSpace;

@JS("BABYLON.ToLinearSpace")
external get ToLinearSpace;

@JS("BABYLON.Epsilon")
external get Epsilon;

@JS("BABYLON.Color3")
class Color3 {
    // @Ignore
    Color3 .fakeConstructor$();

    external num get r;

    external set r(num v);

    external num get g;

    external set g(num v);

    external num get b;

    external set b(num v);

    external factory Color3([num r, num g, num b]);

    external String toString();

    external String getClassName();

    external num getHashCode();

    external Color3 toArray(dynamic/*List<num>|Float32List*/ array, [num index]);

    external Color4 toColor4([num alpha]);

    external List<num> asArray();

    external num toLuminance();

    external Color3 multiply(Color3 otherColor);

    external Color3 multiplyToRef(Color3 otherColor, Color3 result);

    external bool equals(Color3 otherColor);

    external bool equalsFloats(num r, num g, num b);

    external Color3 scale(num scale);

    external Color3 scaleToRef(num scale, Color3 result);

    external Color3 scaleAndAddToRef(num scale, Color3 result);

    external Color3 clampToRef(dynamic/*num|dynamic*/ min, dynamic/*num|dynamic*/ max, Color3 result);

    external Color3 add(Color3 otherColor);

    external Color3 addToRef(Color3 otherColor, Color3 result);

    external Color3 subtract(Color3 otherColor);

    external Color3 subtractToRef(Color3 otherColor, Color3 result);

    external Color3 clone();

    external Color3 copyFrom(Color3 source);

    external Color3 copyFromFloats(num r, num g, num b);

    external Color3 JS$set(num r, num g, num b);

    external String toHexString();

    external Color3 toLinearSpace();

    external Color3 toLinearSpaceToRef(Color3 convertedColor);

    external Color3 toGammaSpace();

    external Color3 toGammaSpaceToRef(Color3 convertedColor);

    external static Color3 FromHexString(String hex);

    external static Color3 FromArray(ArrayLike<num> array, [num offset]);

    external static Color3 FromInts(num r, num g, num b);

    external static Color3 Lerp(Color3 start, Color3 end, num amount);

    external static void LerpToRef(Color3 left, Color3 right, num amount, Color3 result);

    external static Color3 Red();

    external static Color3 Green();

    external static Color3 Blue();

    external static Color3 Black();

    external static Color3 White();

    external static Color3 Purple();

    external static Color3 Magenta();

    external static Color3 Yellow();

    external static Color3 Gray();

    external static Color3 Teal();

    external static Color3 Random();
}

@JS("BABYLON.Color4")
class Color4 {
    // @Ignore
    Color4 .fakeConstructor$();

    external num get r;

    external set r(num v);

    external num get g;

    external set g(num v);

    external num get b;

    external set b(num v);

    external num get a;

    external set a(num v);

    external factory Color4([num r, num g, num b, num a]);

    external Color4 addInPlace(Color4 right);

    external List<num> asArray();

    external Color4 toArray(List<num> array, [num index]);

    external Color4 add(Color4 right);

    external Color4 subtract(Color4 right);

    external Color4 subtractToRef(Color4 right, Color4 result);

    external Color4 scale(num scale);

    external Color4 scaleToRef(num scale, Color4 result);

    external Color4 scaleAndAddToRef(num scale, Color4 result);

    external Color4 clampToRef(dynamic/*num|dynamic*/ min, dynamic/*num|dynamic*/ max, Color4 result);

    external Color4 multiply(Color4 color);

    external Color4 multiplyToRef(Color4 color, Color4 result);

    external String toString();

    external String getClassName();

    external num getHashCode();

    external Color4 clone();

    external Color4 copyFrom(Color4 source);

    external Color4 copyFromFloats(num r, num g, num b, num a);

    external Color4 JS$set(num r, num g, num b, num a);

    external String toHexString();

    external Color4 toLinearSpace();

    external Color4 toLinearSpaceToRef(Color4 convertedColor);

    external Color4 toGammaSpace();

    external Color4 toGammaSpaceToRef(Color4 convertedColor);

    external static Color4 FromHexString(String hex);

    external static Color4 Lerp(Color4 left, Color4 right, num amount);

    external static void LerpToRef(Color4 left, Color4 right, num amount, Color4 result);

    external static Color4 FromColor3(Color3 color3, [num alpha]);

    external static Color4 FromArray(ArrayLike<num> array, [num offset]);

    external static Color4 FromInts(num r, num g, num b, num a);

    external static List<num> CheckColors4(List<num> colors, num count);
}

@JS("BABYLON.Vector2")
class Vector2 {
    // @Ignore
    Vector2 .fakeConstructor$();

    external num get x;

    external set x(num v);

    external num get y;

    external set y(num v);

    external factory Vector2([num x, num y]);

    external String toString();

    external String getClassName();

    external num getHashCode();

    external Vector2 toArray(dynamic/*List<num>|Float32List*/ array, [num index]);

    external List<num> asArray();

    external Vector2 copyFrom(Vector2 source);

    external Vector2 copyFromFloats(num x, num y);

    external Vector2 JS$set(num x, num y);

    external Vector2 add(Vector2 otherVector);

    external Vector2 addToRef(Vector2 otherVector, Vector2 result);

    external Vector2 addInPlace(Vector2 otherVector);

    external Vector2 addVector3(Vector3 otherVector);

    external Vector2 subtract(Vector2 otherVector);

    external Vector2 subtractToRef(Vector2 otherVector, Vector2 result);

    external Vector2 subtractInPlace(Vector2 otherVector);

    external Vector2 multiplyInPlace(Vector2 otherVector);

    external Vector2 multiply(Vector2 otherVector);

    external Vector2 multiplyToRef(Vector2 otherVector, Vector2 result);

    external Vector2 multiplyByFloats(num x, num y);

    external Vector2 divide(Vector2 otherVector);

    external Vector2 divideToRef(Vector2 otherVector, Vector2 result);

    external Vector2 divideInPlace(Vector2 otherVector);

    external Vector2 negate();

    external Vector2 scaleInPlace(num scale);

    external Vector2 scale(num scale);

    external Vector2 scaleToRef(num scale, Vector2 result);

    external Vector2 scaleAndAddToRef(num scale, Vector2 result);

    external bool equals(Vector2 otherVector);

    external bool equalsWithEpsilon(Vector2 otherVector, [num epsilon]);

    external Vector2 floor();

    external Vector2 fract();

    external num length();

    external num lengthSquared();

    external Vector2 normalize();

    external Vector2 clone();

    external static Vector2 Zero();

    external static Vector2 One();

    external static Vector2 FromArray(ArrayLike<num> array, [num offset]);

    external static void FromArrayToRef(ArrayLike<num> array, num offset, Vector2 result);

    external static Vector2 CatmullRom(Vector2 value1, Vector2 value2, Vector2 value3, Vector2 value4, num amount);

    external static Vector2 Clamp(Vector2 value, Vector2 min, Vector2 max);

    external static Vector2 Hermite(Vector2 value1, Vector2 tangent1, Vector2 value2, Vector2 tangent2, num amount);

    external static Vector2 Lerp(Vector2 start, Vector2 end, num amount);

    external static num Dot(Vector2 left, Vector2 right);

    external static Vector2 Normalize(Vector2 vector);

    external static Vector2 Minimize(Vector2 left, Vector2 right);

    external static Vector2 Maximize(Vector2 left, Vector2 right);

    external static Vector2 Transform(Vector2 vector, Matrix transformation);

    external static void TransformToRef(Vector2 vector, Matrix transformation, Vector2 result);

    external static bool PointInTriangle(Vector2 p, Vector2 p0, Vector2 p1, Vector2 p2);

    external static num Distance(Vector2 value1, Vector2 value2);

    external static num DistanceSquared(Vector2 value1, Vector2 value2);

    external static Vector2 Center(Vector2 value1, Vector2 value2);

    external static num DistanceOfPointFromSegment(Vector2 p, Vector2 segA, Vector2 segB);
}

@JS("BABYLON.Vector3")
class Vector3 {
    // @Ignore
    Vector3 .fakeConstructor$();

    external num get x;

    external set x(num v);

    external num get y;

    external set y(num v);

    external num get z;

    external set z(num v);

    external factory Vector3([num x, num y, num z]);

    external String toString();

    external String getClassName();

    external num getHashCode();

    external List<num> asArray();

    external Vector3 toArray(dynamic/*List<num>|Float32List*/ array, [num index]);

    external Quaternion toQuaternion();

    external Vector3 addInPlace(Vector3 otherVector);

    external Vector3 add(Vector3 otherVector);

    external Vector3 addToRef(Vector3 otherVector, Vector3 result);

    external Vector3 subtractInPlace(Vector3 otherVector);

    external Vector3 subtract(Vector3 otherVector);

    external Vector3 subtractToRef(Vector3 otherVector, Vector3 result);

    external Vector3 subtractFromFloats(num x, num y, num z);

    external Vector3 subtractFromFloatsToRef(num x, num y, num z, Vector3 result);

    external Vector3 negate();

    external Vector3 scaleInPlace(num scale);

    external Vector3 scale(num scale);

    external Vector3 scaleToRef(num scale, Vector3 result);

    external Vector3 scaleAndAddToRef(num scale, Vector3 result);

    external bool equals(Vector3 otherVector);

    external bool equalsWithEpsilon(Vector3 otherVector, [num epsilon]);

    external bool equalsToFloats(num x, num y, num z);

    external Vector3 multiplyInPlace(Vector3 otherVector);

    external Vector3 multiply(Vector3 otherVector);

    external Vector3 multiplyToRef(Vector3 otherVector, Vector3 result);

    external Vector3 multiplyByFloats(num x, num y, num z);

    external Vector3 divide(Vector3 otherVector);

    external Vector3 divideToRef(Vector3 otherVector, Vector3 result);

    external Vector3 divideInPlace(Vector3 otherVector);

    external Vector3 minimizeInPlace(Vector3 other);

    external Vector3 maximizeInPlace(Vector3 other);

    external Vector3 minimizeInPlaceFromFloats(num x, num y, num z);

    external Vector3 maximizeInPlaceFromFloats(num x, num y, num z);

    external bool get isNonUniform;

    external set isNonUniform(bool v);

    external Vector3 floor();

    external Vector3 fract();

    external num length();

    external num lengthSquared();

    external Vector3 normalize();

    external Vector3 normalizeToNew();

    external Vector3 normalizeToRef(Vector3 reference);

    external Vector3 clone();

    external Vector3 copyFrom(Vector3 source);

    external Vector3 copyFromFloats(num x, num y, num z);

    external Vector3 JS$set(num x, num y, num z);

    external static num GetClipFactor(Vector3 vector0, Vector3 vector1, Vector3 axis, num size);

    external static num GetAngleBetweenVectors(Vector3 vector0, Vector3 vector1, Vector3 normal);

    external static Vector3 FromArray(ArrayLike<num> array, [num offset]);

    external static Vector3 FromFloatArray(Float32List array, [num offset]);

    external static void FromArrayToRef(ArrayLike<num> array, num offset, Vector3 result);

    external static void FromFloatArrayToRef(Float32List array, num offset, Vector3 result);

    external static void FromFloatsToRef(num x, num y, num z, Vector3 result);

    external static Vector3 Zero();

    external static Vector3 One();

    external static Vector3 Up();

    external static Vector3 Down();

    external static Vector3 Forward();

    external static Vector3 Backward();

    external static Vector3 Right();

    external static Vector3 Left();

    external static Vector3 TransformCoordinates(Vector3 vector, Matrix transformation);

    external static void TransformCoordinatesToRef(Vector3 vector, Matrix transformation, Vector3 result);

    external static void TransformCoordinatesFromFloatsToRef(num x, num y, num z, Matrix transformation, Vector3 result);

    external static Vector3 TransformNormal(Vector3 vector, Matrix transformation);

    external static void TransformNormalToRef(Vector3 vector, Matrix transformation, Vector3 result);

    external static void TransformNormalFromFloatsToRef(num x, num y, num z, Matrix transformation, Vector3 result);

    external static Vector3 CatmullRom(Vector3 value1, Vector3 value2, Vector3 value3, Vector3 value4, num amount);

    external static Vector3 Clamp(Vector3 value, Vector3 min, Vector3 max);

    external static Vector3 Hermite(Vector3 value1, Vector3 tangent1, Vector3 value2, Vector3 tangent2, num amount);

    external static Vector3 Lerp(Vector3 start, Vector3 end, num amount);

    external static void LerpToRef(Vector3 start, Vector3 end, num amount, Vector3 result);

    external static num Dot(Vector3 left, Vector3 right);

    external static Vector3 Cross(Vector3 left, Vector3 right);

    external static void CrossToRef(Vector3 left, Vector3 right, Vector3 result);

    external static Vector3 Normalize(Vector3 vector);

    external static void NormalizeToRef(Vector3 vector, Vector3 result);

    external static get JS$_viewportMatrixCache;

    external static set JS$_viewportMatrixCache(v);

    external static Vector3 Project(Vector3 vector, Matrix world, Matrix transform, Viewport viewport);

    external static Vector3 UnprojectFromTransform(Vector3 source, num viewportWidth, num viewportHeight, Matrix world, Matrix transform);

    external static Vector3 Unproject(Vector3 source, num viewportWidth, num viewportHeight, Matrix world, Matrix view, Matrix projection);

    external static void UnprojectToRef(Vector3 source, num viewportWidth, num viewportHeight, Matrix world, Matrix view, Matrix projection, Vector3 result);

    external static void UnprojectFloatsToRef(num sourceX, num sourceY, num sourceZ, num viewportWidth, num viewportHeight, Matrix world, Matrix view, Matrix projection, Vector3 result);

    external static Vector3 Minimize(Vector3 left, Vector3 right);

    external static Vector3 Maximize(Vector3 left, Vector3 right);

    external static num Distance(Vector3 value1, Vector3 value2);

    external static num DistanceSquared(Vector3 value1, Vector3 value2);

    external static Vector3 Center(Vector3 value1, Vector3 value2);

    external static Vector3 RotationFromAxis(Vector3 axis1, Vector3 axis2, Vector3 axis3);

    external static void RotationFromAxisToRef(Vector3 axis1, Vector3 axis2, Vector3 axis3, Vector3 ref);
}

@JS("BABYLON.Vector4")
class Vector4 {
    // @Ignore
    Vector4 .fakeConstructor$();

    external num get x;

    external set x(num v);

    external num get y;

    external set y(num v);

    external num get z;

    external set z(num v);

    external num get w;

    external set w(num v);

    external factory Vector4(num x, num y, num z, num w);

    external String toString();

    external String getClassName();

    external num getHashCode();

    external List<num> asArray();

    external Vector4 toArray(dynamic/*List<num>|Float32List*/ array, [num index]);

    external Vector4 addInPlace(Vector4 otherVector);

    external Vector4 add(Vector4 otherVector);

    external Vector4 addToRef(Vector4 otherVector, Vector4 result);

    external Vector4 subtractInPlace(Vector4 otherVector);

    external Vector4 subtract(Vector4 otherVector);

    external Vector4 subtractToRef(Vector4 otherVector, Vector4 result);

    external Vector4 subtractFromFloats(num x, num y, num z, num w);

    external Vector4 subtractFromFloatsToRef(num x, num y, num z, num w, Vector4 result);

    external Vector4 negate();

    external Vector4 scaleInPlace(num scale);

    external Vector4 scale(num scale);

    external Vector4 scaleToRef(num scale, Vector4 result);

    external Vector4 scaleAndAddToRef(num scale, Vector4 result);

    external bool equals(Vector4 otherVector);

    external bool equalsWithEpsilon(Vector4 otherVector, [num epsilon]);

    external bool equalsToFloats(num x, num y, num z, num w);

    external Vector4 multiplyInPlace(Vector4 otherVector);

    external Vector4 multiply(Vector4 otherVector);

    external Vector4 multiplyToRef(Vector4 otherVector, Vector4 result);

    external Vector4 multiplyByFloats(num x, num y, num z, num w);

    external Vector4 divide(Vector4 otherVector);

    external Vector4 divideToRef(Vector4 otherVector, Vector4 result);

    external Vector4 divideInPlace(Vector4 otherVector);

    external Vector4 minimizeInPlace(Vector4 other);

    external Vector4 maximizeInPlace(Vector4 other);

    external Vector4 floor();

    external Vector4 fract();

    external num length();

    external num lengthSquared();

    external Vector4 normalize();

    external Vector3 toVector3();

    external Vector4 clone();

    external Vector4 copyFrom(Vector4 source);

    external Vector4 copyFromFloats(num x, num y, num z, num w);

    external Vector4 JS$set(num x, num y, num z, num w);

    external static Vector4 FromArray(ArrayLike<num> array, [num offset]);

    external static void FromArrayToRef(ArrayLike<num> array, num offset, Vector4 result);

    external static void FromFloatArrayToRef(Float32List array, num offset, Vector4 result);

    external static void FromFloatsToRef(num x, num y, num z, num w, Vector4 result);

    external static Vector4 Zero();

    external static Vector4 One();

    external static Vector4 Normalize(Vector4 vector);

    external static void NormalizeToRef(Vector4 vector, Vector4 result);

    external static Vector4 Minimize(Vector4 left, Vector4 right);

    external static Vector4 Maximize(Vector4 left, Vector4 right);

    external static num Distance(Vector4 value1, Vector4 value2);

    external static num DistanceSquared(Vector4 value1, Vector4 value2);

    external static Vector4 Center(Vector4 value1, Vector4 value2);

    external static Vector4 TransformNormal(Vector4 vector, Matrix transformation);

    external static void TransformNormalToRef(Vector4 vector, Matrix transformation, Vector4 result);

    external static void TransformNormalFromFloatsToRef(num x, num y, num z, num w, Matrix transformation, Vector4 result);
}

@anonymous
@JS()
abstract class ISize {
    external num get width;

    external set width(num v);

    external num get height;

    external set height(num v);

    external factory ISize({ num width, num height});
}

@JS("BABYLON.Size")
class Size implements ISize {
    // @Ignore
    Size .fakeConstructor$();

    external num get width;

    external set width(num v);

    external num get height;

    external set height(num v);

    external factory Size(num width, num height);

    external String toString();

    external String getClassName();

    external num getHashCode();

    external void copyFrom(Size src);

    external Size copyFromFloats(num width, num height);

    external Size JS$set(num width, num height);

    external Size multiplyByFloats(num w, num h);

    external Size clone();

    external bool equals(Size other);

    external num get surface;

    external set surface(num v);

    external static Size Zero();

    external Size add(Size otherSize);

    external Size subtract(Size otherSize);

    external static Size Lerp(Size start, Size end, num amount);
}

@JS("BABYLON.Quaternion")
class Quaternion {
    // @Ignore
    Quaternion .fakeConstructor$();

    external num get x;

    external set x(num v);

    external num get y;

    external set y(num v);

    external num get z;

    external set z(num v);

    external num get w;

    external set w(num v);

    external factory Quaternion([num x, num y, num z, num w]);

    external String toString();

    external String getClassName();

    external num getHashCode();

    external List<num> asArray();

    external bool equals(Quaternion otherQuaternion);

    external Quaternion clone();

    external Quaternion copyFrom(Quaternion other);

    external Quaternion copyFromFloats(num x, num y, num z, num w);

    external Quaternion JS$set(num x, num y, num z, num w);

    external Quaternion add(Quaternion other);

    external Quaternion addInPlace(Quaternion other);

    external Quaternion subtract(Quaternion other);

    external Quaternion scale(num value);

    external Quaternion scaleToRef(num scale, Quaternion result);

    external Quaternion scaleInPlace(num value);

    external Quaternion scaleAndAddToRef(num scale, Quaternion result);

    external Quaternion multiply(Quaternion q1);

    external Quaternion multiplyToRef(Quaternion q1, Quaternion result);

    external Quaternion multiplyInPlace(Quaternion q1);

    external Quaternion conjugateToRef(Quaternion ref);

    external Quaternion conjugateInPlace();

    external Quaternion conjugate();

    external num length();

    external Quaternion normalize();

    external Vector3 toEulerAngles([String order]);

    external Quaternion toEulerAnglesToRef(Vector3 result, [String order]);

    external Quaternion toRotationMatrix(Matrix result);

    external Quaternion fromRotationMatrix(Matrix matrix);

    external static Quaternion FromRotationMatrix(Matrix matrix);

    external static void FromRotationMatrixToRef(Matrix matrix, Quaternion result);

    external static num Dot(Quaternion left, Quaternion right);

    external static bool AreClose(Quaternion quat0, Quaternion quat1);

    external static Quaternion Zero();

    external static Quaternion Inverse(Quaternion q);

    external static Quaternion Identity();

    external static bool IsIdentity(Quaternion quaternion);

    external static Quaternion RotationAxis(Vector3 axis, num angle);

    external static Quaternion RotationAxisToRef(Vector3 axis, num angle, Quaternion result);

    external static Quaternion FromArray(ArrayLike<num> array, [num offset]);

    external static Quaternion RotationYawPitchRoll(num yaw, num pitch, num roll);

    external static void RotationYawPitchRollToRef(num yaw, num pitch, num roll, Quaternion result);

    external static Quaternion RotationAlphaBetaGamma(num alpha, num beta, num gamma);

    external static void RotationAlphaBetaGammaToRef(num alpha, num beta, num gamma, Quaternion result);

    external static Quaternion RotationQuaternionFromAxis(Vector3 axis1, Vector3 axis2, Vector3 axis3);

    external static void RotationQuaternionFromAxisToRef(Vector3 axis1, Vector3 axis2, Vector3 axis3, Quaternion ref);

    external static Quaternion Slerp(Quaternion left, Quaternion right, num amount);

    external static void SlerpToRef(Quaternion left, Quaternion right, num amount, Quaternion result);

    external static Quaternion Hermite(Quaternion value1, Quaternion tangent1, Quaternion value2, Quaternion tangent2, num amount);
}

@JS("BABYLON.Matrix")
class Matrix {
    // @Ignore
    Matrix .fakeConstructor$();

    external static get JS$_tempQuaternion;

    external static set JS$_tempQuaternion(v);

    external static get JS$_xAxis;

    external static set JS$_xAxis(v);

    external static get JS$_yAxis;

    external static set JS$_yAxis(v);

    external static get JS$_zAxis;

    external static set JS$_zAxis(v);

    external static get JS$_updateFlagSeed;

    external static set JS$_updateFlagSeed(v);

    external static get JS$_identityReadOnly;

    external static set JS$_identityReadOnly(v);

    external get JS$_isIdentity;

    external set JS$_isIdentity(v);

    external get JS$_isIdentityDirty;

    external set JS$_isIdentityDirty(v);

    external num get updateFlag;

    external set updateFlag(num v);

    external Float32List get m;

    external set m(Float32List v);

    external void JS$_markAsUpdated();

    external factory Matrix();

    external bool isIdentity([bool considerAsTextureMatrix]);

    external num determinant();

    external Float32List toArray();

    external Float32List asArray();

    external Matrix invert();

    external Matrix reset();

    external Matrix add(Matrix other);

    external Matrix addToRef(Matrix other, Matrix result);

    external Matrix addToSelf(Matrix other);

    external Matrix invertToRef(Matrix other);

    external Matrix setTranslationFromFloats(num x, num y, num z);

    external Matrix setTranslation(Vector3 vector3);

    external Vector3 getTranslation();

    external Matrix getTranslationToRef(Vector3 result);

    external Matrix removeRotationAndScaling();

    external Matrix multiply(Matrix other);

    external Matrix copyFrom(Matrix other);

    external Matrix copyToArray(Float32List array, [num offset]);

    external Matrix multiplyToRef(Matrix other, Matrix result);

    external Matrix multiplyToArray(Matrix other, Float32List result, num offset);

    external bool equals(Matrix value);

    external Matrix clone();

    external String getClassName();

    external num getHashCode();

    external bool decompose([Vector3 scale, Quaternion rotation, Vector3 translation]);

    external Vector4/*Vector4|Null*/ getRow(num index);

    external Matrix setRow(num index, Vector4 row);

    external Matrix transpose();

    external Matrix transposeToRef(Matrix result);

    external Matrix setRowFromFloats(num index, num x, num y, num z, num w);

    external Matrix scale(num scale);

    external Matrix scaleToRef(num scale, Matrix result);

    external Matrix scaleAndAddToRef(num scale, Matrix result);

    external void toNormalMatrix(Matrix ref);

    external Matrix getRotationMatrix();

    external Matrix getRotationMatrixToRef(Matrix result);

    external static Matrix FromArray(ArrayLike<num> array, [num offset]);

    external static void FromArrayToRef(ArrayLike<num> array, num offset, Matrix result);

    external static void FromFloat32ArrayToRefScaled(Float32List array, num offset, num scale, Matrix result);

    external static void FromValuesToRef(num initialM11, num initialM12, num initialM13, num initialM14, num initialM21, num initialM22, num initialM23, num initialM24, num initialM31, num initialM32, num initialM33, num initialM34, num initialM41, num initialM42, num initialM43, num initialM44, Matrix result);

    external static Matrix get IdentityReadOnly;

    external static set IdentityReadOnly(Matrix v);

    external static Matrix FromValues(num initialM11, num initialM12, num initialM13, num initialM14, num initialM21, num initialM22, num initialM23, num initialM24, num initialM31, num initialM32, num initialM33, num initialM34, num initialM41, num initialM42, num initialM43, num initialM44);

    external static Matrix Compose(Vector3 scale, Quaternion rotation, Vector3 translation);

    external static void ComposeToRef(Vector3 scale, Quaternion rotation, Vector3 translation, Matrix result);

    external static Matrix Identity();

    external static void IdentityToRef(Matrix result);

    external static Matrix Zero();

    external static Matrix RotationX(num angle);

    external static Matrix Invert(Matrix source);

    external static void RotationXToRef(num angle, Matrix result);

    external static Matrix RotationY(num angle);

    external static void RotationYToRef(num angle, Matrix result);

    external static Matrix RotationZ(num angle);

    external static void RotationZToRef(num angle, Matrix result);

    external static Matrix RotationAxis(Vector3 axis, num angle);

    external static void RotationAxisToRef(Vector3 axis, num angle, Matrix result);

    external static Matrix RotationYawPitchRoll(num yaw, num pitch, num roll);

    external static void RotationYawPitchRollToRef(num yaw, num pitch, num roll, Matrix result);

    external static Matrix Scaling(num x, num y, num z);

    external static void ScalingToRef(num x, num y, num z, Matrix result);

    external static Matrix Translation(num x, num y, num z);

    external static void TranslationToRef(num x, num y, num z, Matrix result);

    external static Matrix Lerp(Matrix startValue, Matrix endValue, num gradient);

    external static void LerpToRef(Matrix startValue, Matrix endValue, num gradient, Matrix result);

    external static Matrix DecomposeLerp(Matrix startValue, Matrix endValue, num gradient);

    external static void DecomposeLerpToRef(Matrix startValue, Matrix endValue, num gradient, Matrix result);

    external static Matrix LookAtLH(Vector3 eye, Vector3 target, Vector3 up);

    external static void LookAtLHToRef(Vector3 eye, Vector3 target, Vector3 up, Matrix result);

    external static Matrix LookAtRH(Vector3 eye, Vector3 target, Vector3 up);

    external static void LookAtRHToRef(Vector3 eye, Vector3 target, Vector3 up, Matrix result);

    external static Matrix OrthoLH(num width, num height, num znear, num zfar);

    external static void OrthoLHToRef(num width, num height, num znear, num zfar, Matrix result);

    external static Matrix OrthoOffCenterLH(num left, num right, num bottom, num top, num znear, num zfar);

    external static void OrthoOffCenterLHToRef(num left, num right, num bottom, num top, num znear, num zfar, Matrix result);

    external static Matrix OrthoOffCenterRH(num left, num right, num bottom, num top, num znear, num zfar);

    external static void OrthoOffCenterRHToRef(num left, num right, num bottom, num top, num znear, num zfar, Matrix result);

    external static Matrix PerspectiveLH(num width, num height, num znear, num zfar);

    external static Matrix PerspectiveFovLH(num fov, num aspect, num znear, num zfar);

    external static void PerspectiveFovLHToRef(num fov, num aspect, num znear, num zfar, Matrix result, [bool isVerticalFovFixed]);

    external static Matrix PerspectiveFovRH(num fov, num aspect, num znear, num zfar);

    external static void PerspectiveFovRHToRef(num fov, num aspect, num znear, num zfar, Matrix result, [bool isVerticalFovFixed]);

    external static void PerspectiveFovWebVRToRef(dynamic/*{
            upDegrees: number;
            downDegrees: number;
            leftDegrees: number;
            rightDegrees: number;
        }*/
    fov, num znear, num zfar, Matrix result, [bool rightHanded]);

    external static Matrix GetFinalMatrix(Viewport viewport, Matrix world, Matrix view, Matrix projection, num zmin, num zmax);

    external static Float32List GetAsMatrix2x2(Matrix matrix);

    external static Float32List GetAsMatrix3x3(Matrix matrix);

    external static Matrix Transpose(Matrix matrix);

    external static void TransposeToRef(Matrix matrix, Matrix result);

    external static Matrix Reflection(Plane plane);

    external static void ReflectionToRef(Plane plane, Matrix result);

    external static void FromXYZAxesToRef(Vector3 xaxis, Vector3 yaxis, Vector3 zaxis, Matrix result);

    external static void FromQuaternionToRef(Quaternion quat, Matrix result);
}

@JS("BABYLON.Plane")
class Plane {
    // @Ignore
    Plane .fakeConstructor$();

    external Vector3 get normal;

    external set normal(Vector3 v);

    external num get d;

    external set d(num v);

    external factory Plane(num a, num b, num c, num d);

    external List<num> asArray();

    external Plane clone();

    external String getClassName();

    external num getHashCode();

    external Plane normalize();

    external Plane transform(Matrix transformation);

    external num dotCoordinate(Vector3 point);

    external Plane copyFromPoints(Vector3 point1, Vector3 point2, Vector3 point3);

    external bool isFrontFacingTo(Vector3 direction, num epsilon);

    external num signedDistanceTo(Vector3 point);

    external static Plane FromArray(ArrayLike<num> array);

    external static Plane FromPoints(Vector3 point1, Vector3 point2, Vector3 point3);

    external static Plane FromPositionAndNormal(Vector3 origin, Vector3 normal);

    external static num SignedDistanceToPlaneFromPositionAndNormal(Vector3 origin, Vector3 normal, Vector3 point);
}

@JS("BABYLON.Viewport")
class Viewport {
    // @Ignore
    Viewport .fakeConstructor$();

    external num get x;

    external set x(num v);

    external num get y;

    external set y(num v);

    external num get width;

    external set width(num v);

    external num get height;

    external set height(num v);

    external factory Viewport(num x, num y, num width, num height);

    external Viewport toGlobal(dynamic/*num|Engine*/ renderWidthOrEngine, num renderHeight);

    external Viewport clone();
}

@JS("BABYLON.Frustum")
class Frustum {
    // @Ignore
    Frustum .fakeConstructor$();

    external static List<Plane> GetPlanes(Matrix transform);

    external static void GetNearPlaneToRef(Matrix transform, Plane frustumPlane);

    external static void GetFarPlaneToRef(Matrix transform, Plane frustumPlane);

    external static void GetLeftPlaneToRef(Matrix transform, Plane frustumPlane);

    external static void GetRightPlaneToRef(Matrix transform, Plane frustumPlane);

    external static void GetTopPlaneToRef(Matrix transform, Plane frustumPlane);

    external static void GetBottomPlaneToRef(Matrix transform, Plane frustumPlane);

    external static void GetPlanesToRef(Matrix transform, List<Plane> frustumPlanes);
}

@JS("BABYLON.Space")
class Space {
    external static num get LOCAL;

    external static num get WORLD;

    external static num get BONE;
}

@JS("BABYLON.Axis")
class Axis {
    // @Ignore
    Axis .fakeConstructor$();

    external static Vector3 get X;

    external static set X(Vector3 v);

    external static Vector3 get Y;

    external static set Y(Vector3 v);

    external static Vector3 get Z;

    external static set Z(Vector3 v);
}

@JS("BABYLON.BezierCurve")
class BezierCurve {
    // @Ignore
    BezierCurve .fakeConstructor$();

    external static num Interpolate(num t, num x1, num y1, num x2, num y2);
}

@JS("BABYLON.Orientation")
class Orientation {
    external static num get CW;

    external static num get CCW;
}

@JS("BABYLON.Angle")
class Angle {
    // @Ignore
    Angle .fakeConstructor$();

    external get JS$_radians;

    external set JS$_radians(v);

    external factory Angle(num radians);

    external num degrees();

    external num radians();

    external static Angle BetweenTwoPoints(Vector2 a, Vector2 b);

    external static Angle FromRadians(num radians);

    external static Angle FromDegrees(num degrees);
}

@JS("BABYLON.Arc2")
class Arc2 {
    // @Ignore
    Arc2 .fakeConstructor$();

    external Vector2 get startPoint;

    external set startPoint(Vector2 v);

    external Vector2 get midPoint;

    external set midPoint(Vector2 v);

    external Vector2 get endPoint;

    external set endPoint(Vector2 v);

    external Vector2 get centerPoint;

    external set centerPoint(Vector2 v);

    external num get radius;

    external set radius(num v);

    external Angle get angle;

    external set angle(Angle v);

    external Angle get startAngle;

    external set startAngle(Angle v);

    external num/*enum Orientation*/ get orientation;

    external set orientation(num/*enum Orientation*/ v);

    external factory Arc2(Vector2 startPoint, Vector2 midPoint, Vector2 endPoint);
}

@JS("BABYLON.Path2")
class Path2 {
    // @Ignore
    Path2 .fakeConstructor$();

    external get JS$_points;

    external set JS$_points(v);

    external get JS$_length;

    external set JS$_length(v);

    external bool get closed;

    external set closed(bool v);

    external factory Path2(num x, num y);

    external Path2 addLineTo(num x, num y);

    external Path2 addArcTo(num midX, num midY, num endX, num endY, [num numberOfSegments]);

    external Path2 close();

    external num length();

    external List<Vector2> getPoints();

    external Vector2 getPointAtLengthPosition(num normalizedLengthPosition);

    external static Path2 StartingAt(num x, num y);
}

@JS("BABYLON.Path3D")
class Path3D {
    // @Ignore
    Path3D .fakeConstructor$();

    external List<Vector3> get path;

    external set path(List<Vector3> v);

    external get JS$_curve;

    external set JS$_curve(v);

    external get JS$_distances;

    external set JS$_distances(v);

    external get JS$_tangents;

    external set JS$_tangents(v);

    external get JS$_normals;

    external set JS$_normals(v);

    external get JS$_binormals;

    external set JS$_binormals(v);

    external get JS$_raw;

    external set JS$_raw(v);

    external factory Path3D(List<Vector3> path, [Vector3/*Vector3|Null*/ firstNormal, bool raw]);

    external List<Vector3> getCurve();

    external List<Vector3> getTangents();

    external List<Vector3> getNormals();

    external List<Vector3> getBinormals();

    external List<num> getDistances();

    external Path3D update(List<Vector3> path, [Vector3/*Vector3|Null*/ firstNormal]);

    external get JS$_compute;

    external set JS$_compute(v);

    external get JS$_getFirstNonNullVector;

    external set JS$_getFirstNonNullVector(v);

    external get JS$_getLastNonNullVector;

    external set JS$_getLastNonNullVector(v);

    external get JS$_normalVector;

    external set JS$_normalVector(v);
}

@JS("BABYLON.Curve3")
class Curve3 {
    // @Ignore
    Curve3 .fakeConstructor$();

    external get JS$_points;

    external set JS$_points(v);

    external get JS$_length;

    external set JS$_length(v);

    external static Curve3 CreateQuadraticBezier(Vector3 v0, Vector3 v1, Vector3 v2, num nbPoints);

    external static Curve3 CreateCubicBezier(Vector3 v0, Vector3 v1, Vector3 v2, Vector3 v3, num nbPoints);

    external static Curve3 CreateHermiteSpline(Vector3 p1, Vector3 t1, Vector3 p2, Vector3 t2, num nbPoints);

    external static Curve3 CreateCatmullRomSpline(List<Vector3> points, num nbPoints, [bool closed]);

    external factory Curve3(List<Vector3> points);

    external List<Vector3> getPoints();

    external num length();

    external Curve3 JS$continue(Curve3 curve);

    external get JS$_computeLength;

    external set JS$_computeLength(v);
}

@JS("BABYLON.PositionNormalVertex")
class PositionNormalVertex {
    // @Ignore
    PositionNormalVertex .fakeConstructor$();

    external Vector3 get position;

    external set position(Vector3 v);

    external Vector3 get normal;

    external set normal(Vector3 v);

    external factory PositionNormalVertex([Vector3 position, Vector3 normal]);

    external PositionNormalVertex clone();
}

@JS("BABYLON.PositionNormalTextureVertex")
class PositionNormalTextureVertex {
    // @Ignore
    PositionNormalTextureVertex .fakeConstructor$();

    external Vector3 get position;

    external set position(Vector3 v);

    external Vector3 get normal;

    external set normal(Vector3 v);

    external Vector2 get uv;

    external set uv(Vector2 v);

    external factory PositionNormalTextureVertex([Vector3 position, Vector3 normal, Vector2 uv]);

    external PositionNormalTextureVertex clone();
}

@JS("BABYLON.Tmp")
class Tmp {
    // @Ignore
    Tmp .fakeConstructor$();

    external static List<Color3> get Color3;

    external static set Color3(List<Color3> v);

    external static List<Color4> get Color4;

    external static set Color4(List<Color4> v);

    external static List<Vector2> get Vector2;

    external static set Vector2(List<Vector2> v);

    external static List<Vector3> get Vector3;

    external static set Vector3(List<Vector3> v);

    external static List<Vector4> get Vector4;

    external static set Vector4(List<Vector4> v);

    external static List<Quaternion> get Quaternion;

    external static set Quaternion(List<Quaternion> v);

    external static List<Matrix> get Matrix;

    external static set Matrix(List<Matrix> v);
}

@JS("BABYLON.SphericalPolynomial")
class SphericalPolynomial {
    // @Ignore
    SphericalPolynomial .fakeConstructor$();

    external Vector3 get x;

    external set x(Vector3 v);

    external Vector3 get y;

    external set y(Vector3 v);

    external Vector3 get z;

    external set z(Vector3 v);

    external Vector3 get xx;

    external set xx(Vector3 v);

    external Vector3 get yy;

    external set yy(Vector3 v);

    external Vector3 get zz;

    external set zz(Vector3 v);

    external Vector3 get xy;

    external set xy(Vector3 v);

    external Vector3 get yz;

    external set yz(Vector3 v);

    external Vector3 get zx;

    external set zx(Vector3 v);

    external void addAmbient(Color3 color);

    external void scale(num scale);

    external static SphericalPolynomial FromHarmonics(SphericalHarmonics harmonics);

    external static SphericalPolynomial FromArray(ArrayLike<ArrayLike<num>> data);
}

@JS("BABYLON.SphericalHarmonics")
class SphericalHarmonics {
    // @Ignore
    SphericalHarmonics .fakeConstructor$();

    external Vector3 get l00;

    external set l00(Vector3 v);

    external Vector3 get l1_1;

    external set l1_1(Vector3 v);

    external Vector3 get l10;

    external set l10(Vector3 v);

    external Vector3 get l11;

    external set l11(Vector3 v);

    external Vector3 get l2_2;

    external set l2_2(Vector3 v);

    external Vector3 get l2_1;

    external set l2_1(Vector3 v);

    external Vector3 get l20;

    external set l20(Vector3 v);

    external Vector3 get l21;

    external set l21(Vector3 v);

    external Vector3 get lL22;

    external set lL22(Vector3 v);

    external void addLight(Vector3 direction, Color3 color, num deltaSolidAngle);

    external void scale(num scale);

    external void convertIncidentRadianceToIrradiance();

    external void convertIrradianceToLambertianRadiance();

    external static SphericalHarmonics FromPolynomial(SphericalPolynomial polynomial);

    external static SphericalHarmonics FromArray(ArrayLike<ArrayLike<num>> data);
}

@JS("BABYLON.AbstractMesh")
class AbstractMesh extends TransformNode implements IDisposable, ICullable, IGetSetVerticesData {
    // @Ignore
    AbstractMesh .fakeConstructor$() : super.fakeConstructor$();
    external static num get OCCLUSION_TYPE_NONE;

    external static set OCCLUSION_TYPE_NONE(num v);

    external static num get OCCLUSION_TYPE_OPTIMISTIC;

    external static set OCCLUSION_TYPE_OPTIMISTIC(num v);

    external static num get OCCLUSION_TYPE_STRICT;

    external static set OCCLUSION_TYPE_STRICT(num v);

    external static num get OCCLUSION_ALGORITHM_TYPE_ACCURATE;

    external static set OCCLUSION_ALGORITHM_TYPE_ACCURATE(num v);

    external static num get OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE;

    external static set OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE(num v);

    external static num get CULLINGSTRATEGY_STANDARD;

    external static set CULLINGSTRATEGY_STANDARD(num v);

    external static num get CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY;

    external static set CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY(num v);

    external static num get BILLBOARDMODE_NONE;

    external static set BILLBOARDMODE_NONE(num v);

    external static num get BILLBOARDMODE_X;

    external static set BILLBOARDMODE_X(num v);

    external static num get BILLBOARDMODE_Y;

    external static set BILLBOARDMODE_Y(num v);

    external static num get BILLBOARDMODE_Z;

    external static set BILLBOARDMODE_Z(num v);

    external static num get BILLBOARDMODE_ALL;

    external static set BILLBOARDMODE_ALL(num v);

    external get JS$_facetData;

    external set JS$_facetData(v);

    external num get cullingStrategy;

    external set cullingStrategy(num v);

    external num get facetNb;

    external set facetNb(num v);

    external num get partitioningSubdivisions;

    external set partitioningSubdivisions(num v);

    external num get partitioningBBoxRatio;

    external set partitioningBBoxRatio(num v);

    external bool get mustDepthSortFacets;

    external set mustDepthSortFacets(bool v);

    external Vector3 get facetDepthSortFrom;

    external set facetDepthSortFrom(Vector3 v);

    external bool get isFacetDataEnabled;

    external set isFacetDataEnabled(bool v);

    external bool JS$_updateNonUniformScalingState(bool value);

    external Observable<AbstractMesh> get onCollideObservable;

    external set onCollideObservable(Observable<AbstractMesh> v);

    external get JS$_onCollideObserver;

    external set JS$_onCollideObserver(v);

    external VoidFunc0 get onCollide;

    external set onCollide(VoidFunc0 v);

    external Observable<Vector3> get onCollisionPositionChangeObservable;

    external set onCollisionPositionChangeObservable(Observable<Vector3> v);

    external get JS$_onCollisionPositionChangeObserver;

    external set JS$_onCollisionPositionChangeObserver(v);

    external VoidFunc0 get onCollisionPositionChange;

    external set onCollisionPositionChange(VoidFunc0 v);

    external Observable<AbstractMesh> get onMaterialChangedObservable;

    external set onMaterialChangedObservable(Observable<AbstractMesh> v);

    external bool get definedFacingForward;

    external set definedFacingForward(bool v);

    external WebGLQuery/*WebGLQuery|Null*/ get JS$_occlusionQuery;

    external set JS$_occlusionQuery(WebGLQuery/*WebGLQuery|Null*/ v);

    external get JS$_visibility;

    external set JS$_visibility(v);

    external num get visibility;

    external set visibility(num v);

    external num get alphaIndex;

    external set alphaIndex(num v);

    external bool get isVisible;

    external set isVisible(bool v);

    external bool get isPickable;

    external set isPickable(bool v);

    external bool get showSubMeshesBoundingBox;

    external set showSubMeshesBoundingBox(bool v);

    external bool get isBlocker;

    external set isBlocker(bool v);

    external bool get enablePointerMoveEvents;

    external set enablePointerMoveEvents(bool v);

    external num get renderingGroupId;

    external set renderingGroupId(num v);

    external get JS$_material;

    external set JS$_material(v);

    external Material/*Material|Null*/ get material;

    external set material(Material/*Material|Null*/ v);

    external get JS$_receiveShadows;

    external set JS$_receiveShadows(v);

    external bool get receiveShadows;

    external set receiveShadows(bool v);

    external Color3 get outlineColor;

    external set outlineColor(Color3 v);

    external num get outlineWidth;

    external set outlineWidth(num v);

    external Color3 get overlayColor;

    external set overlayColor(Color3 v);

    external num get overlayAlpha;

    external set overlayAlpha(num v);

    external get JS$_hasVertexAlpha;

    external set JS$_hasVertexAlpha(v);

    external bool get hasVertexAlpha;

    external set hasVertexAlpha(bool v);

    external get JS$_useVertexColors;

    external set JS$_useVertexColors(v);

    external bool get useVertexColors;

    external set useVertexColors(bool v);

    external get JS$_computeBonesUsingShaders;

    external set JS$_computeBonesUsingShaders(v);

    external bool get computeBonesUsingShaders;

    external set computeBonesUsingShaders(bool v);

    external get JS$_numBoneInfluencers;

    external set JS$_numBoneInfluencers(v);

    external num get numBoneInfluencers;

    external set numBoneInfluencers(num v);

    external get JS$_applyFog;

    external set JS$_applyFog(v);

    external bool get applyFog;

    external set applyFog(bool v);

    external bool get useOctreeForRenderingSelection;

    external set useOctreeForRenderingSelection(bool v);

    external bool get useOctreeForPicking;

    external set useOctreeForPicking(bool v);

    external bool get useOctreeForCollisions;

    external set useOctreeForCollisions(bool v);

    external get JS$_layerMask;

    external set JS$_layerMask(v);

    external num get layerMask;

    external set layerMask(num v);

    external bool get alwaysSelectAsActiveMesh;

    external set alwaysSelectAsActiveMesh(bool v);

    external ActionManager/*ActionManager|Null*/ get actionManager;

    external set actionManager(ActionManager/*ActionManager|Null*/ v);

    external get JS$_checkCollisions;

    external set JS$_checkCollisions(v);

    external get JS$_collisionMask;

    external set JS$_collisionMask(v);

    external get JS$_collisionGroup;

    external set JS$_collisionGroup(v);

    external Vector3 get ellipsoid;

    external set ellipsoid(Vector3 v);

    external Vector3 get ellipsoidOffset;

    external set ellipsoidOffset(Vector3 v);

    external get JS$_collider;

    external set JS$_collider(v);

    external get JS$_oldPositionForCollisions;

    external set JS$_oldPositionForCollisions(v);

    external get JS$_diffPositionForCollisions;

    external set JS$_diffPositionForCollisions(v);

    external num get collisionMask;

    external set collisionMask(num v);

    external num get collisionGroup;

    external set collisionGroup(num v);

    external num get edgesWidth;

    external set edgesWidth(num v);

    external Color4 get edgesColor;

    external set edgesColor(Color4 v);

    external IEdgesRenderer/*IEdgesRenderer|Null*/ get JS$_edgesRenderer;

    external set JS$_edgesRenderer(IEdgesRenderer/*IEdgesRenderer|Null*/ v);

    external AbstractMesh/*AbstractMesh|Null*/ get JS$_masterMesh;

    external set JS$_masterMesh(AbstractMesh/*AbstractMesh|Null*/ v);

    external BoundingInfo/*BoundingInfo|Null*/ get JS$_boundingInfo;

    external set JS$_boundingInfo(BoundingInfo/*BoundingInfo|Null*/ v);

    external num get JS$_renderId;

    external set JS$_renderId(num v);

    external List<SubMesh> get subMeshes;

    external set subMeshes(List<SubMesh> v);

    external List<AbstractMesh> get JS$_intersectionsInProgress;

    external set JS$_intersectionsInProgress(List<AbstractMesh> v);

    external bool get JS$_unIndexed;

    external set JS$_unIndexed(bool v);

    external List<Light> get JS$_lightSources;

    external set JS$_lightSources(List<Light> v);

    external List<Vector3>/*List<Vector3>|Null*/ get JS$_positions;

    external set JS$_positions(List<Vector3>/*List<Vector3>|Null*/ v);

    external dynamic get JS$_waitingActions;

    external set JS$_waitingActions(dynamic v);

    external bool/*bool|Null*/ get JS$_waitingFreezeWorldMatrix;

    external set JS$_waitingFreezeWorldMatrix(bool/*bool|Null*/ v);

    external get JS$_skeleton;

    external set JS$_skeleton(v);

    external Float32List/*Float32List|Null*/ get JS$_bonesTransformMatrices;

    external set JS$_bonesTransformMatrices(Float32List/*Float32List|Null*/ v);

    external Skeleton/*Skeleton|Null*/ get skeleton;

    external set skeleton(Skeleton/*Skeleton|Null*/ v);

    external Observable<AbstractMesh> get onRebuildObservable;

    external set onRebuildObservable(Observable<AbstractMesh> v);

    external factory AbstractMesh(String name, [Scene/*Scene|Null*/ scene]);

    external String getClassName();

    external String toString([bool fullDetails]);

    external void JS$_rebuild();

    external void JS$_resyncLightSources();

    external void JS$_resyncLighSource(Light light);

    external void JS$_unBindEffect();

    external void JS$_removeLightSource(Light light);

    external get JS$_markSubMeshesAsDirty;

    external set JS$_markSubMeshesAsDirty(v);

    external void JS$_markSubMeshesAsLightDirty();

    external void JS$_markSubMeshesAsAttributesDirty();

    external void JS$_markSubMeshesAsMiscDirty();

    external Vector3 get scaling;

    external set scaling(Vector3 v);

    external bool get isBlocked;

    external set isBlocked(bool v);

    external AbstractMesh/*AbstractMesh|Null*/ getLOD(Camera camera);

    external num getTotalVertices();

    external dynamic/*List<num>|Int32List|Uint32List|Uint16List|Null*/ getIndices();

    external dynamic/*List<num>|Float32List|Null*/ getVerticesData(String kind);

    external AbstractMesh setVerticesData(String kind, dynamic/*List<num>|Float32List*/ data, [bool updatable, num stride]);

    external AbstractMesh updateVerticesData(String kind, dynamic/*List<num>|Float32List*/ data, [bool updateExtends, bool makeItUnique]);

    external AbstractMesh setIndices(dynamic/*List<num>|Int32List|Uint32List|Uint16List*/ indices, num/*num|Null*/ totalVertices);

    external bool isVerticesDataPresent(String kind);

    external BoundingInfo getBoundingInfo();

    external AbstractMesh normalizeToUnitCube([bool includeDescendants]);

    external AbstractMesh setBoundingInfo(BoundingInfo boundingInfo);

    external bool get useBones;

    external set useBones(bool v);

    external void JS$_preActivate();

    external void JS$_preActivateForIntermediateRendering(num renderId);

    external void JS$_activate(num renderId);

    external Matrix getWorldMatrix();

    external num JS$_getWorldMatrixDeterminant();

    external AbstractMesh movePOV(num amountRight, num amountUp, num amountForward);

    external Vector3 calcMovePOV(num amountRight, num amountUp, num amountForward);

    external AbstractMesh rotatePOV(num flipBack, num twirlClockwise, num tiltRight);

    external Vector3 calcRotatePOV(num flipBack, num twirlClockwise, num tiltRight);

    external dynamic/*{
            min: Vector3;
            max: Vector3;
        }*/
    getHierarchyBoundingVectors([bool includeDescendants, Func1<AbstractMesh, bool>/*Func1<AbstractMesh, bool>|Null*/ predicate]);

    external AbstractMesh JS$_updateBoundingInfo();

    external AbstractMesh JS$_updateSubMeshesBoundingInfo(Matrix matrix);

    external void JS$_afterComputeWorldMatrix();

    external bool isInFrustum(List<Plane> frustumPlanes);

    external bool isCompletelyInFrustum(List<Plane> frustumPlanes);

    external bool intersectsMesh(dynamic/*AbstractMesh|SolidParticle*/ mesh, [bool precise, bool includeDescendants]);

    external bool intersectsPoint(Vector3 point);

    external Vector3 getPositionInCameraSpace([Camera/*Camera|Null*/ camera]);

    external num getDistanceToCamera([Camera/*Camera|Null*/ camera]);

    external bool get checkCollisions;

    external set checkCollisions(bool v);

    external Collider get collider;

    external set collider(Collider v);

    external AbstractMesh moveWithCollisions(Vector3 displacement);

    external get JS$_onCollisionPositionChange;

    external set JS$_onCollisionPositionChange(v);

    external AbstractMesh JS$_collideForSubMesh(SubMesh subMesh, Matrix transformMatrix, Collider collider);

    external AbstractMesh JS$_processCollisionsForSubMeshes(Collider collider, Matrix transformMatrix);

    external AbstractMesh JS$_checkCollision(Collider collider);

    external bool JS$_generatePointsArray();

    external PickingInfo intersects(Ray ray, [bool fastCheck]);

    external AbstractMesh/*AbstractMesh|Null*/ clone(String name, Node newParent, [bool doNotCloneChildren]);

    external AbstractMesh releaseSubMeshes();

    external void dispose([bool doNotRecurse, bool disposeMaterialAndTextures]);

    external AbstractMesh addChild(AbstractMesh mesh);

    external AbstractMesh removeChild(AbstractMesh mesh);

    external get JS$_initFacetData;

    external set JS$_initFacetData(v);

    external AbstractMesh updateFacetData();

    external List<Vector3> getFacetLocalNormals();

    external List<Vector3> getFacetLocalPositions();

    external List<List<num>> getFacetLocalPartitioning();

    external Vector3 getFacetPosition(num i);

    external AbstractMesh getFacetPositionToRef(num i, Vector3 ref);

    external Vector3 getFacetNormal(num i);

    external AbstractMesh getFacetNormalToRef(num i, Vector3 ref);

    external List<num>/*List<num>|Null*/ getFacetsAtLocalCoordinates(num x, num y, num z);

    external num/*num|Null*/ getClosestFacetAtCoordinates(num x, num y, num z, [Vector3 projected, bool checkFace, bool facing]);

    external num/*num|Null*/ getClosestFacetAtLocalCoordinates(num x, num y, num z, [Vector3 projected, bool checkFace, bool facing]);

    external dynamic getFacetDataParameters();

    external AbstractMesh disableFacetData();

    external AbstractMesh updateIndices(dynamic/*List<num>|Int32List|Uint32List|Uint16List*/ indices);

    external AbstractMesh createNormals(bool updatable);

    external AbstractMesh alignWithNormal(Vector3 normal, [Vector3 upDirection]);

    external bool JS$_checkOcclusionQuery();

    external PhysicsImpostor/*PhysicsImpostor|Null*/ get JS$_physicsImpostor;

    external set JS$_physicsImpostor(PhysicsImpostor/*PhysicsImpostor|Null*/ v);

    external PhysicsImpostor/*PhysicsImpostor|Null*/ get physicsImpostor;

    external set physicsImpostor(PhysicsImpostor/*PhysicsImpostor|Null*/ v);

    external PhysicsImpostor/*PhysicsImpostor|Null*/ getPhysicsImpostor();

    external AbstractMesh applyImpulse(Vector3 force, Vector3 contactPoint);

    external AbstractMesh setPhysicsLinkWith(Mesh otherMesh, Vector3 pivot1, Vector3 pivot2, [dynamic options]);

    external Observer<Node>/*Observer<Node>|Null*/ get JS$_disposePhysicsObserver;

    external set JS$_disposePhysicsObserver(Observer<Node>/*Observer<Node>|Null*/ v);

    external bool get JS$_showBoundingBox;

    external set JS$_showBoundingBox(bool v);

    external bool get showBoundingBox;

    external set showBoundingBox(bool v);

    external AbstractMesh disableEdgesRendering();

    external AbstractMesh enableEdgesRendering([num epsilon, bool checkVerticesInsteadOfIndices]);

    external EdgesRenderer/*EdgesRenderer|Null*/ get edgesRenderer;

    external set edgesRenderer(EdgesRenderer/*EdgesRenderer|Null*/ v);

    external bool get JS$_renderOutline;

    external set JS$_renderOutline(bool v);

    external bool get renderOutline;

    external set renderOutline(bool v);

    external bool get JS$_renderOverlay;

    external set JS$_renderOverlay(bool v);

    external bool get renderOverlay;

    external set renderOverlay(bool v);

    external JS$_OcclusionDataStorage get JS$___occlusionDataStorage;

    external set JS$___occlusionDataStorage(JS$_OcclusionDataStorage v);

    external JS$_OcclusionDataStorage get JS$_occlusionDataStorage;

    external set JS$_occlusionDataStorage(JS$_OcclusionDataStorage v);

    external num get occlusionRetryCount;

    external set occlusionRetryCount(num v);

    external num get occlusionType;

    external set occlusionType(num v);

    external num get occlusionQueryAlgorithmType;

    external set occlusionQueryAlgorithmType(num v);

    external bool get isOccluded;

    external set isOccluded(bool v);

    external bool get isOcclusionQueryInProgress;

    external set isOcclusionQueryInProgress(bool v);

    external Octree<SubMesh> get JS$_submeshesOctree;

    external set JS$_submeshesOctree(Octree<SubMesh> v);

    external Octree<SubMesh> createOrUpdateSubmeshesOctree([num maxCapacity, num maxDepth]);
}

@JS("BABYLON.Buffer")
class Buffer {
    // @Ignore
    Buffer .fakeConstructor$();

    external get JS$_engine;

    external set JS$_engine(v);

    external get JS$_buffer;

    external set JS$_buffer(v);

    external dynamic/*List<num>|ByteBuffer|TypedData|Null*/ get JS$_data;

    external set JS$_data(dynamic/*List<num>|ByteBuffer|TypedData|Null*/ v);

    external get JS$_updatable;

    external set JS$_updatable(v);

    external get JS$_instanced;

    external set JS$_instanced(v);

    external num get byteStride;

    external set byteStride(num v);

    external factory Buffer(dynamic engine, dynamic/*List<num>|ByteBuffer|TypedData*/ data, bool updatable, [num stride, bool postponeInternalCreation, bool instanced, bool useBytes]);

    external VertexBuffer createVertexBuffer(String kind, num offset, num size, [num stride, bool instanced, bool useBytes]);

    external bool isUpdatable();

    external dynamic/*List<num>|ByteBuffer|TypedData|Null*/ getData();

    external Buffer/*Buffer|Null*/ getBuffer();

    external num getStrideSize();

    external void create([dynamic/*List<num>|ByteBuffer|TypedData|Null*/ data]);

    external void JS$_rebuild();

    external void update(dynamic/*List<num>|ByteBuffer|TypedData*/ data);

    external void updateDirectly(dynamic/*List<num>|ByteBuffer|TypedData*/ data, num offset, [num vertexCount, bool useBytes]);

    external void dispose();
}

@JS("BABYLON.CSG")
class CSG {
    // @Ignore
    CSG .fakeConstructor$();

    external get polygons;

    external set polygons(v);

    external Matrix get matrix;

    external set matrix(Matrix v);

    external Vector3 get position;

    external set position(Vector3 v);

    external Vector3 get rotation;

    external set rotation(Vector3 v);

    external Quaternion/*Quaternion|Null*/ get rotationQuaternion;

    external set rotationQuaternion(Quaternion/*Quaternion|Null*/ v);

    external Vector3 get scaling;

    external set scaling(Vector3 v);

    external static CSG FromMesh(Mesh mesh);

    external static get FromPolygons;

    external static set FromPolygons(v);

    external CSG clone();

    external CSG union(CSG csg);

    external void unionInPlace(CSG csg);

    external CSG subtract(CSG csg);

    external void subtractInPlace(CSG csg);

    external CSG intersect(CSG csg);

    external void intersectInPlace(CSG csg);

    external CSG inverse();

    external void inverseInPlace();

    external CSG copyTransformAttributes(CSG csg);

    external Mesh buildMeshGeometry(String name, Scene scene, bool keepSubMeshes);

    external Mesh toMesh(String name, Material/*Material|Null*/ material, Scene scene, bool keepSubMeshes);
}

@JS("BABYLON.Geometry")
class Geometry implements IGetSetVerticesData {
    // @Ignore
    Geometry .fakeConstructor$();

    external String get id;

    external set id(String v);

    external num get delayLoadState;

    external set delayLoadState(num v);

    external String/*String|Null*/ get delayLoadingFile;

    external set delayLoadingFile(String/*String|Null*/ v);

    external VoidFunc2Opt1<Geometry, String> get onGeometryUpdated;

    external set onGeometryUpdated(VoidFunc2Opt1<Geometry, String> v);

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_engine;

    external set JS$_engine(v);

    external get JS$_meshes;

    external set JS$_meshes(v);

    external get JS$_totalVertices;

    external set JS$_totalVertices(v);

    external dynamic/*List<num>|Int32List|Uint32List|Uint16List*/ get JS$_indices;

    external set JS$_indices(dynamic/*List<num>|Int32List|Uint32List|Uint16List*/ v);

    external dynamic/*JSMap of <String,VertexBuffer>*/ get JS$_vertexBuffers;

    external set JS$_vertexBuffers(dynamic/*JSMap of <String,VertexBuffer>*/ v);

    external get JS$_isDisposed;

    external set JS$_isDisposed(v);

    external get JS$_extend;

    external set JS$_extend(v);

    external get JS$_boundingBias;

    external set JS$_boundingBias(v);

    external List<String> get JS$_delayInfo;

    external set JS$_delayInfo(List<String> v);

    external get JS$_indexBuffer;

    external set JS$_indexBuffer(v);

    external get JS$_indexBufferIsUpdatable;

    external set JS$_indexBufferIsUpdatable(v);

    external BoundingInfo/*BoundingInfo|Null*/ get JS$_boundingInfo;

    external set JS$_boundingInfo(BoundingInfo/*BoundingInfo|Null*/ v);

    external VoidFunc2<dynamic, Geometry>/*VoidFunc2<dynamic, Geometry>|Null*/ get JS$_delayLoadingFunction;

    external set JS$_delayLoadingFunction(VoidFunc2<dynamic, Geometry>/*VoidFunc2<dynamic, Geometry>|Null*/ v);

    external num get JS$_softwareSkinningFrameId;

    external set JS$_softwareSkinningFrameId(num v);

    external get JS$_vertexArrayObjects;

    external set JS$_vertexArrayObjects(v);

    external get JS$_updatable;

    external set JS$_updatable(v);

    external List<Vector3>/*List<Vector3>|Null*/ get JS$_positions;

    external set JS$_positions(List<Vector3>/*List<Vector3>|Null*/ v);

    external Vector2 get boundingBias;

    external set boundingBias(Vector2 v);

    external static Geometry CreateGeometryForMesh(Mesh mesh);

    external factory Geometry(String id, Scene scene, [VertexData vertexData, bool updatable, Mesh/*Mesh|Null*/ mesh]);

    external dynamic/*{
            minimum: Vector3;
            maximum: Vector3;
        }*/ get extend;

    external set extend(dynamic/*{
            minimum: Vector3;
            maximum: Vector3;
        }*/
    v);

    external Scene getScene();

    external Engine getEngine();

    external bool isReady();

    external bool get doNotSerialize;

    external set doNotSerialize(bool v);

    external void JS$_rebuild();

    external void setAllVerticesData(VertexData vertexData, [bool updatable]);

    external void setVerticesData(String kind, dynamic/*List<num>|Float32List*/ data, [bool updatable, num stride]);

    external void removeVerticesData(String kind);

    external void setVerticesBuffer(VertexBuffer buffer, [num/*num|Null*/ totalVertices]);

    external void updateVerticesDataDirectly(String kind, dynamic/*List<num>|ByteBuffer|TypedData*/ data, num offset, [bool useBytes]);

    external void updateVerticesData(String kind, dynamic/*List<num>|Float32List*/ data, [bool updateExtends]);

    external get JS$_updateBoundingInfo;

    external set JS$_updateBoundingInfo(v);

    external void JS$_bind(Effect/*Effect|Null*/ effect, [Buffer/*Buffer|Null*/ indexToBind]);

    external num getTotalVertices();

    external dynamic/*List<num>|Float32List|Null*/ getVerticesData(String kind, [bool copyWhenShared, bool forceCopy]);

    external bool isVertexBufferUpdatable(String kind);

    external VertexBuffer/*VertexBuffer|Null*/ getVertexBuffer(String kind);

    external dynamic/*JSMap of <String,VertexBuffer>|Null*/ getVertexBuffers();

    external bool isVerticesDataPresent(String kind);

    external List<String> getVerticesDataKinds();

    external void updateIndices(dynamic/*List<num>|Int32List|Uint32List|Uint16List*/ indices, [num offset]);

    external void setIndices(dynamic/*List<num>|Int32List|Uint32List|Uint16List*/ indices, [num/*num|Null*/ totalVertices, bool updatable]);

    external num getTotalIndices();

    external dynamic/*List<num>|Int32List|Uint32List|Uint16List|Null*/ getIndices([bool copyWhenShared, bool forceCopy]);

    external Buffer/*Buffer|Null*/ getIndexBuffer();

    external void JS$_releaseVertexArrayObject([Effect/*Effect|Null*/ effect]);

    external void releaseForMesh(Mesh mesh, [bool shouldDispose]);

    external void applyToMesh(Mesh mesh);

    external get JS$_updateExtend;

    external set JS$_updateExtend(v);

    external get JS$_applyToMesh;

    external set JS$_applyToMesh(v);

    external get notifyUpdate;

    external set notifyUpdate(v);

    external void load(Scene scene, [void onLoaded()]);

    external get JS$_queueLoad;

    external set JS$_queueLoad(v);

    external void toLeftHanded();

    external void JS$_resetPointsArrayCache();

    external bool JS$_generatePointsArray();

    external bool isDisposed();

    external get JS$_disposeVertexArrayObjects;

    external set JS$_disposeVertexArrayObjects(v);

    external void dispose();

    external Geometry copy(String id);

    external dynamic serialize();

    external get toNumberArray;

    external set toNumberArray(v);

    external dynamic serializeVerticeData();

    external static Geometry/*Geometry|Null*/ ExtractFromMesh(Mesh mesh, String id);

    external static String RandomId();

    external static void JS$_ImportGeometry(dynamic parsedGeometry, Mesh mesh);

    external static get JS$_CleanMatricesWeights;

    external static set JS$_CleanMatricesWeights(v);

    external static Geometry/*Geometry|Null*/ Parse(dynamic parsedVertexData, Scene scene, String rootUrl);
}

@JS("BABYLON._PrimitiveGeometry")
class JS$_PrimitiveGeometry extends Geometry {
    // @Ignore
    JS$_PrimitiveGeometry .fakeConstructor$() : super.fakeConstructor$();
    external get JS$_canBeRegenerated;

    external set JS$_canBeRegenerated(v);

    external get JS$_beingRegenerated;

    external set JS$_beingRegenerated(v);

    external factory JS$_PrimitiveGeometry(String id, Scene scene, [bool JS$_canBeRegenerated, Mesh/*Mesh|Null*/ mesh]);

    external bool canBeRegenerated();

    external void regenerate();

    external Geometry asNewGeometry(String id);

    external void setAllVerticesData(VertexData vertexData, [bool updatable]);

    external void setVerticesData(String kind, dynamic/*List<num>|Float32List*/ data, [bool updatable]);

    external VertexData JS$_regenerateVertexData();

    external Geometry copy(String id);

    external dynamic serialize();
}

@JS("BABYLON.RibbonGeometry")
class RibbonGeometry extends JS$_PrimitiveGeometry {
    // @Ignore
    RibbonGeometry .fakeConstructor$() : super.fakeConstructor$();
    external List<List<Vector3>> get pathArray;

    external set pathArray(List<List<Vector3>> v);

    external bool get closeArray;

    external set closeArray(bool v);

    external bool get closePath;

    external set closePath(bool v);

    external num get offset;

    external set offset(num v);

    external num get side;

    external set side(num v);

    external factory RibbonGeometry(String id, Scene scene, List<List<Vector3>> pathArray, bool closeArray, bool closePath, num offset, [bool canBeRegenerated, Mesh mesh, num side]);

    external VertexData JS$_regenerateVertexData();

    external Geometry copy(String id);
}

@JS("BABYLON.BoxGeometry")
class BoxGeometry extends JS$_PrimitiveGeometry {
    // @Ignore
    BoxGeometry .fakeConstructor$() : super.fakeConstructor$();
    external num get size;

    external set size(num v);

    external num get side;

    external set side(num v);

    external factory BoxGeometry(String id, Scene scene, num size, [bool canBeRegenerated, Mesh/*Mesh|Null*/ mesh, num side]);

    external VertexData JS$_regenerateVertexData();

    external Geometry copy(String id);

    external dynamic serialize();

    external static BoxGeometry/*BoxGeometry|Null*/ Parse(dynamic parsedBox, Scene scene);
}

@JS("BABYLON.SphereGeometry")
class SphereGeometry extends JS$_PrimitiveGeometry {
    // @Ignore
    SphereGeometry .fakeConstructor$() : super.fakeConstructor$();
    external num get segments;

    external set segments(num v);

    external num get diameter;

    external set diameter(num v);

    external num get side;

    external set side(num v);

    external factory SphereGeometry(String id, Scene scene, num segments, num diameter, [bool canBeRegenerated, Mesh/*Mesh|Null*/ mesh, num side]);

    external VertexData JS$_regenerateVertexData();

    external Geometry copy(String id);

    external dynamic serialize();

    external static SphereGeometry/*SphereGeometry|Null*/ Parse(dynamic parsedSphere, Scene scene);
}

@JS("BABYLON.DiscGeometry")
class DiscGeometry extends JS$_PrimitiveGeometry {
    // @Ignore
    DiscGeometry .fakeConstructor$() : super.fakeConstructor$();
    external num get radius;

    external set radius(num v);

    external num get tessellation;

    external set tessellation(num v);

    external num get side;

    external set side(num v);

    external factory DiscGeometry(String id, Scene scene, num radius, num tessellation, [bool canBeRegenerated, Mesh/*Mesh|Null*/ mesh, num side]);

    external VertexData JS$_regenerateVertexData();

    external Geometry copy(String id);
}

@JS("BABYLON.CylinderGeometry")
class CylinderGeometry extends JS$_PrimitiveGeometry {
    // @Ignore
    CylinderGeometry .fakeConstructor$() : super.fakeConstructor$();
    external num get height;

    external set height(num v);

    external num get diameterTop;

    external set diameterTop(num v);

    external num get diameterBottom;

    external set diameterBottom(num v);

    external num get tessellation;

    external set tessellation(num v);

    external num get subdivisions;

    external set subdivisions(num v);

    external num get side;

    external set side(num v);

    external factory CylinderGeometry(String id, Scene scene, num height, num diameterTop, num diameterBottom, num tessellation, [num subdivisions, bool canBeRegenerated, Mesh/*Mesh|Null*/ mesh, num side]);

    external VertexData JS$_regenerateVertexData();

    external Geometry copy(String id);

    external dynamic serialize();

    external static CylinderGeometry/*CylinderGeometry|Null*/ Parse(dynamic parsedCylinder, Scene scene);
}

@JS("BABYLON.TorusGeometry")
class TorusGeometry extends JS$_PrimitiveGeometry {
    // @Ignore
    TorusGeometry .fakeConstructor$() : super.fakeConstructor$();
    external num get diameter;

    external set diameter(num v);

    external num get thickness;

    external set thickness(num v);

    external num get tessellation;

    external set tessellation(num v);

    external num get side;

    external set side(num v);

    external factory TorusGeometry(String id, Scene scene, num diameter, num thickness, num tessellation, [bool canBeRegenerated, Mesh/*Mesh|Null*/ mesh, num side]);

    external VertexData JS$_regenerateVertexData();

    external Geometry copy(String id);

    external dynamic serialize();

    external static TorusGeometry/*TorusGeometry|Null*/ Parse(dynamic parsedTorus, Scene scene);
}

@JS("BABYLON.GroundGeometry")
class GroundGeometry extends JS$_PrimitiveGeometry {
    // @Ignore
    GroundGeometry .fakeConstructor$() : super.fakeConstructor$();
    external num get width;

    external set width(num v);

    external num get height;

    external set height(num v);

    external num get subdivisions;

    external set subdivisions(num v);

    external factory GroundGeometry(String id, Scene scene, num width, num height, num subdivisions, [bool canBeRegenerated, Mesh/*Mesh|Null*/ mesh]);

    external VertexData JS$_regenerateVertexData();

    external Geometry copy(String id);

    external dynamic serialize();

    external static GroundGeometry/*GroundGeometry|Null*/ Parse(dynamic parsedGround, Scene scene);
}

@JS("BABYLON.TiledGroundGeometry")
class TiledGroundGeometry extends JS$_PrimitiveGeometry {
    // @Ignore
    TiledGroundGeometry .fakeConstructor$() : super.fakeConstructor$();
    external num get xmin;

    external set xmin(num v);

    external num get zmin;

    external set zmin(num v);

    external num get xmax;

    external set xmax(num v);

    external num get zmax;

    external set zmax(num v);

    external dynamic/*{
            w: number;
            h: number;
        }*/ get subdivisions;

    external set subdivisions(dynamic/*{
            w: number;
            h: number;
        }*/
    v);

    external dynamic/*{
            w: number;
            h: number;
        }*/ get precision;

    external set precision(dynamic/*{
            w: number;
            h: number;
        }*/
    v);

    external factory TiledGroundGeometry(String id, Scene scene, num xmin, num zmin, num xmax, num zmax, dynamic/*{
            w: number;
            h: number;
        }*/
    subdivisions, dynamic/*{
            w: number;
            h: number;
        }*/
    precision, [bool canBeRegenerated, Mesh/*Mesh|Null*/ mesh]);

    external VertexData JS$_regenerateVertexData();

    external Geometry copy(String id);
}

@JS("BABYLON.PlaneGeometry")
class PlaneGeometry extends JS$_PrimitiveGeometry {
    // @Ignore
    PlaneGeometry .fakeConstructor$() : super.fakeConstructor$();
    external num get size;

    external set size(num v);

    external num get side;

    external set side(num v);

    external factory PlaneGeometry(String id, Scene scene, num size, [bool canBeRegenerated, Mesh/*Mesh|Null*/ mesh, num side]);

    external VertexData JS$_regenerateVertexData();

    external Geometry copy(String id);

    external dynamic serialize();

    external static PlaneGeometry/*PlaneGeometry|Null*/ Parse(dynamic parsedPlane, Scene scene);
}

@JS("BABYLON.TorusKnotGeometry")
class TorusKnotGeometry extends JS$_PrimitiveGeometry {
    // @Ignore
    TorusKnotGeometry .fakeConstructor$() : super.fakeConstructor$();
    external num get radius;

    external set radius(num v);

    external num get tube;

    external set tube(num v);

    external num get radialSegments;

    external set radialSegments(num v);

    external num get tubularSegments;

    external set tubularSegments(num v);

    external num get p;

    external set p(num v);

    external num get q;

    external set q(num v);

    external num get side;

    external set side(num v);

    external factory TorusKnotGeometry(String id, Scene scene, num radius, num tube, num radialSegments, num tubularSegments, num p, num q, [bool canBeRegenerated, Mesh/*Mesh|Null*/ mesh, num side]);

    external VertexData JS$_regenerateVertexData();

    external Geometry copy(String id);

    external dynamic serialize();

    external static TorusKnotGeometry/*TorusKnotGeometry|Null*/ Parse(dynamic parsedTorusKnot, Scene scene);
}

@JS("BABYLON.GroundMesh")
class GroundMesh extends Mesh {
    // @Ignore
    GroundMesh .fakeConstructor$() : super.fakeConstructor$();
    external bool get generateOctree;

    external set generateOctree(bool v);

    external get JS$_heightQuads;

    external set JS$_heightQuads(v);

    external num get JS$_subdivisionsX;

    external set JS$_subdivisionsX(num v);

    external num get JS$_subdivisionsY;

    external set JS$_subdivisionsY(num v);

    external num get JS$_width;

    external set JS$_width(num v);

    external num get JS$_height;

    external set JS$_height(num v);

    external num get JS$_minX;

    external set JS$_minX(num v);

    external num get JS$_maxX;

    external set JS$_maxX(num v);

    external num get JS$_minZ;

    external set JS$_minZ(num v);

    external num get JS$_maxZ;

    external set JS$_maxZ(num v);

    external factory GroundMesh(String name, Scene scene);

    external String getClassName();

    external num get subdivisions;

    external set subdivisions(num v);

    external num get subdivisionsX;

    external set subdivisionsX(num v);

    external num get subdivisionsY;

    external set subdivisionsY(num v);

    external void optimize(num chunksCount, [num octreeBlocksSize]);

    external num getHeightAtCoordinates(num x, num z);

    external Vector3 getNormalAtCoordinates(num x, num z);

    external GroundMesh getNormalAtCoordinatesToRef(num x, num z, Vector3 ref);

    external GroundMesh updateCoordinateHeights();

    external get JS$_getFacetAt;

    external set JS$_getFacetAt(v);

    external get JS$_initHeightQuads;

    external set JS$_initHeightQuads(v);

    external get JS$_computeHeightQuads;

    external set JS$_computeHeightQuads(v);

    external void serialize(dynamic serializationObject);

    external static GroundMesh Parse(dynamic parsedMesh, Scene scene);
}

@JS("BABYLON.InstancedMesh")
class InstancedMesh extends AbstractMesh {
    // @Ignore
    InstancedMesh .fakeConstructor$() : super.fakeConstructor$();
    external get JS$_sourceMesh;

    external set JS$_sourceMesh(v);

    external get JS$_currentLOD;

    external set JS$_currentLOD(v);

    external factory InstancedMesh(String name, Mesh source);

    external String getClassName();

    external bool get receiveShadows;

    external set receiveShadows(bool v);

    external Material/*Material|Null*/ get material;

    external set material(Material/*Material|Null*/ v);

    external num get visibility;

    external set visibility(num v);

    external Skeleton/*Skeleton|Null*/ get skeleton;

    external set skeleton(Skeleton/*Skeleton|Null*/ v);

    external num get renderingGroupId;

    external set renderingGroupId(num v);

    external num getTotalVertices();

    external Mesh get sourceMesh;

    external set sourceMesh(Mesh v);

    external bool isReady([bool completeCheck]);

    external dynamic/*List<num>|Float32List|Null*/ getVerticesData(String kind, [bool copyWhenShared]);

    external Mesh setVerticesData(String kind, dynamic/*List<num>|Float32List*/ data, [bool updatable, num stride]);

    external Mesh updateVerticesData(String kind, dynamic/*List<num>|Float32List*/ data, [bool updateExtends, bool makeItUnique]);

    external Mesh setIndices(dynamic/*List<num>|Int32List|Uint32List|Uint16List*/ indices, [num/*num|Null*/ totalVertices]);

    external bool isVerticesDataPresent(String kind);

    external dynamic/*List<num>|Int32List|Uint32List|Uint16List|Null*/ getIndices();

    external List<Vector3>/*List<Vector3>|Null*/ get JS$_positions;

    external set JS$_positions(List<Vector3>/*List<Vector3>|Null*/ v);

    external InstancedMesh refreshBoundingInfo();

    external InstancedMesh JS$_preActivate();

    external InstancedMesh JS$_activate(num renderId);

    external AbstractMesh getLOD(Camera camera);

    external InstancedMesh JS$_syncSubMeshes();

    external bool JS$_generatePointsArray();

    external InstancedMesh clone(String name, Node newParent, [bool doNotCloneChildren]);

    external void dispose([bool doNotRecurse, bool disposeMaterialAndTextures]);
}

@JS("BABYLON.LinesMesh")
class LinesMesh extends Mesh {
    // @Ignore
    LinesMesh .fakeConstructor$() : super.fakeConstructor$();
    external dynamic/*bool|dynamic*/ get useVertexColor;

    external set useVertexColor(dynamic/*bool|dynamic*/ v);

    external dynamic/*bool|dynamic*/ get useVertexAlpha;

    external set useVertexAlpha(dynamic/*bool|dynamic*/ v);

    external Color3 get color;

    external set color(Color3 v);

    external num get alpha;

    external set alpha(num v);

    external num get intersectionThreshold;

    external set intersectionThreshold(num v);

    external get JS$_intersectionThreshold;

    external set JS$_intersectionThreshold(v);

    external get JS$_colorShader;

    external set JS$_colorShader(v);

    external factory LinesMesh(String name, [Scene/*Scene|Null*/ scene, Node/*Node|Null*/ parent, LinesMesh source, bool doNotCloneChildren, dynamic/*bool|dynamic*/ useVertexColor, dynamic/*bool|dynamic*/ useVertexAlpha]);

    external String getClassName();

    external Material get material;

    external set material(Material v);

    external bool get checkCollisions;

    external set checkCollisions(bool v);

    external LinesMesh JS$_bind(SubMesh subMesh, Effect effect, num fillMode);

    external LinesMesh JS$_draw(SubMesh subMesh, num fillMode, [num instancesCount]);

    external void dispose([bool doNotRecurse]);

    external LinesMesh clone(String name, [Node newParent, bool doNotCloneChildren]);

    external AbstractMesh enableEdgesRendering([num epsilon, bool checkVerticesInsteadOfIndices]);
}

@JS("BABYLON._CreationDataStorage")
class JS$_CreationDataStorage {
    // @Ignore
    JS$_CreationDataStorage .fakeConstructor$();

    external bool get closePath;

    external set closePath(bool v);

    external bool get closeArray;

    external set closeArray(bool v);

    external List<num> get idx;

    external set idx(List<num> v);

    external num get dashSize;

    external set dashSize(num v);

    external num get gapSize;

    external set gapSize(num v);

    external Path3D get path3D;

    external set path3D(Path3D v);

    external List<List<Vector3>> get pathArray;

    external set pathArray(List<List<Vector3>> v);

    external num get arc;

    external set arc(num v);

    external num get radius;

    external set radius(num v);

    external num get cap;

    external set cap(num v);

    external num get tessellation;

    external set tessellation(num v);
}

@JS("BABYLON._InstanceDataStorage")
class JS$_InstanceDataStorage {
    // @Ignore
    JS$_InstanceDataStorage .fakeConstructor$();

    external dynamic get visibleInstances;

    external set visibleInstances(dynamic v);

    external List<num> get renderIdForInstances;

    external set renderIdForInstances(List<num> v);

    external JS$_InstancesBatch get batchCache;

    external set batchCache(JS$_InstancesBatch v);

    external num get instancesBufferSize;

    external set instancesBufferSize(num v);

    external Buffer/*Buffer|Null*/ get instancesBuffer;

    external set instancesBuffer(Buffer/*Buffer|Null*/ v);

    external Float32List get instancesData;

    external set instancesData(Float32List v);

    external num get overridenInstanceCount;

    external set overridenInstanceCount(num v);
}

@JS("BABYLON._InstancesBatch")
class JS$_InstancesBatch {
    // @Ignore
    JS$_InstancesBatch .fakeConstructor$();

    external bool get mustReturn;

    external set mustReturn(bool v);

    external List<List<InstancedMesh> /*List<InstancedMesh>|Null*/> get visibleInstances;

    external set visibleInstances(List<List<InstancedMesh> /*List<InstancedMesh>|Null*/> v);

    external List<bool> get renderSelf;

    external set renderSelf(List<bool> v);
}

@JS("BABYLON.Mesh")
class Mesh extends AbstractMesh implements IGetSetVerticesData {
    // @Ignore
    Mesh .fakeConstructor$() : super.fakeConstructor$();
    external static num get FRONTSIDE;

    external static set FRONTSIDE(num v);

    external static num get BACKSIDE;

    external static set BACKSIDE(num v);

    external static num get DOUBLESIDE;

    external static set DOUBLESIDE(num v);

    external static num get DEFAULTSIDE;

    external static set DEFAULTSIDE(num v);

    external static num get NO_CAP;

    external static set NO_CAP(num v);

    external static num get CAP_START;

    external static set CAP_START(num v);

    external static num get CAP_END;

    external static set CAP_END(num v);

    external static num get CAP_ALL;

    external static set CAP_ALL(num v);

    external get JS$_onBeforeRenderObservable;

    external set JS$_onBeforeRenderObservable(v);

    external get JS$_onAfterRenderObservable;

    external set JS$_onAfterRenderObservable(v);

    external get JS$_onBeforeDrawObservable;

    external set JS$_onBeforeDrawObservable(v);

    external Observable<Mesh> get onBeforeRenderObservable;

    external set onBeforeRenderObservable(Observable<Mesh> v);

    external Observable<Mesh> get onAfterRenderObservable;

    external set onAfterRenderObservable(Observable<Mesh> v);

    external Observable<Mesh> get onBeforeDrawObservable;

    external set onBeforeDrawObservable(Observable<Mesh> v);

    external get JS$_onBeforeDrawObserver;

    external set JS$_onBeforeDrawObserver(v);

    external VoidFunc0 get onBeforeDraw;

    external set onBeforeDraw(VoidFunc0 v);

    external num get delayLoadState;

    external set delayLoadState(num v);

    external List<InstancedMesh> get instances;

    external set instances(List<InstancedMesh> v);

    external String get delayLoadingFile;

    external set delayLoadingFile(String v);

    external dynamic get JS$_binaryInfo;

    external set JS$_binaryInfo(dynamic v);

    external get JS$_LODLevels;

    external set JS$_LODLevels(v);

    external VoidFunc3<num, Mesh, Mesh /*Mesh|Null*/> get onLODLevelSelection;

    external set onLODLevelSelection(VoidFunc3<num, Mesh, Mesh /*Mesh|Null*/> v);

    external get JS$_morphTargetManager;

    external set JS$_morphTargetManager(v);

    external MorphTargetManager/*MorphTargetManager|Null*/ get morphTargetManager;

    external set morphTargetManager(MorphTargetManager/*MorphTargetManager|Null*/ v);

    external JS$_CreationDataStorage/*JS$_CreationDataStorage|Null*/ get JS$_creationDataStorage;

    external set JS$_creationDataStorage(JS$_CreationDataStorage/*JS$_CreationDataStorage|Null*/ v);

    external Geometry/*Geometry|Null*/ get JS$_geometry;

    external set JS$_geometry(Geometry/*Geometry|Null*/ v);

    external List<String> get JS$_delayInfo;

    external set JS$_delayInfo(List<String> v);

    external VoidFunc2<dynamic, Mesh> get JS$_delayLoadingFunction;

    external set JS$_delayLoadingFunction(VoidFunc2<dynamic, Mesh> v);

    external JS$_InstanceDataStorage get JS$_instanceDataStorage;

    external set JS$_instanceDataStorage(JS$_InstanceDataStorage v);

    external get JS$_effectiveMaterial;

    external set JS$_effectiveMaterial(v);

    external bool get JS$_shouldGenerateFlatShading;

    external set JS$_shouldGenerateFlatShading(bool v);

    external get JS$_preActivateId;

    external set JS$_preActivateId(v);

    external num get JS$_originalBuilderSideOrientation;

    external set JS$_originalBuilderSideOrientation(num v);

    external num/*num|Null*/ get overrideMaterialSideOrientation;

    external set overrideMaterialSideOrientation(num/*num|Null*/ v);

    external get JS$_areNormalsFrozen;

    external set JS$_areNormalsFrozen(v);

    external get JS$_sourcePositions;

    external set JS$_sourcePositions(v);

    external get JS$_sourceNormals;

    external set JS$_sourceNormals(v);

    external get JS$_source;

    external set JS$_source(v);

    external Mesh/*Mesh|Null*/ get source;

    external set source(Mesh/*Mesh|Null*/ v);

    external bool get isUnIndexed;

    external set isUnIndexed(bool v);

    external factory Mesh(String name, [Scene/*Scene|Null*/ scene, Node/*Node|Null*/ parent, Mesh/*Mesh|Null*/ source, bool doNotCloneChildren, bool clonePhysicsImpostor]);

    external String getClassName();

    external String toString([bool fullDetails]);

    external void JS$_unBindEffect();

    external bool get hasLODLevels;

    external set hasLODLevels(bool v);

    external List<MeshLODLevel> getLODLevels();

    external get JS$_sortLODLevels;

    external set JS$_sortLODLevels(v);

    external Mesh addLODLevel(num distance, Mesh/*Mesh|Null*/ mesh);

    external Mesh/*Mesh|Null*/ getLODLevelAtDistance(num distance);

    external Mesh removeLODLevel(Mesh mesh);

    external AbstractMesh/*AbstractMesh|Null*/ getLOD(Camera camera, [BoundingSphere boundingSphere]);

    external Geometry/*Geometry|Null*/ get geometry;

    external set geometry(Geometry/*Geometry|Null*/ v);

    external num getTotalVertices();

    external dynamic/*List<num>|Float32List|Null*/ getVerticesData(String kind, [bool copyWhenShared, bool forceCopy]);

    external VertexBuffer/*VertexBuffer|Null*/ getVertexBuffer(String kind);

    external bool isVerticesDataPresent(String kind);

    external bool isVertexBufferUpdatable(String kind);

    external List<String> getVerticesDataKinds();

    external num getTotalIndices();

    external dynamic/*List<num>|Int32List|Uint32List|Uint16List|Null*/ getIndices([bool copyWhenShared, bool forceCopy]);

    external bool get isBlocked;

    external set isBlocked(bool v);

    external bool isReady([bool completeCheck, bool forceInstanceSupport]);

    external bool get areNormalsFrozen;

    external set areNormalsFrozen(bool v);

    external Mesh freezeNormals();

    external Mesh unfreezeNormals();

    external num get overridenInstanceCount;

    external set overridenInstanceCount(num v);

    external Mesh JS$_preActivate();

    external Mesh JS$_preActivateForIntermediateRendering(num renderId);

    external Mesh JS$_registerInstanceForRenderId(InstancedMesh instance, num renderId);

    external Mesh refreshBoundingInfo();

    external Mesh JS$_refreshBoundingInfo(bool applySkeleton);

    external get JS$_getPositionData;

    external set JS$_getPositionData(v);

    external SubMesh/*SubMesh|Null*/ JS$_createGlobalSubMesh(bool force);

    external void subdivide(num count);

    external Mesh setVerticesData(String kind, dynamic/*List<num>|Float32List*/ data, [bool updatable, num stride]);

    external void markVerticesDataAsUpdatable(String kind, [bool updatable]);

    external Mesh setVerticesBuffer(VertexBuffer buffer);

    external Mesh updateVerticesData(String kind, dynamic/*List<num>|Float32List*/ data, [bool updateExtends, bool makeItUnique]);

    external Mesh updateMeshPositions(void positionFunction(dynamic/*List<num>|Float32List*/ data), [bool computeNormals]);

    external Mesh makeGeometryUnique();

    external Mesh setIndices(dynamic/*List<num>|Int32List|Uint32List|Uint16List*/ indices, [num/*num|Null*/ totalVertices, bool updatable]);

    external Mesh updateIndices(dynamic/*List<num>|Int32List|Uint32List|Uint16List*/ indices, [num offset]);

    external Mesh toLeftHanded();

    external Mesh JS$_bind(SubMesh subMesh, Effect effect, num fillMode);

    external Mesh JS$_draw(SubMesh subMesh, num fillMode, [num instancesCount, bool alternate]);

    external Mesh registerBeforeRender(void func(AbstractMesh mesh));

    external Mesh unregisterBeforeRender(void func(AbstractMesh mesh));

    external Mesh registerAfterRender(void func(AbstractMesh mesh));

    external Mesh unregisterAfterRender(void func(AbstractMesh mesh));

    external JS$_InstancesBatch JS$_getInstancesRenderList(num subMeshId);

    external Mesh JS$_renderWithInstances(SubMesh subMesh, num fillMode, JS$_InstancesBatch batch, Effect effect, Engine engine);

    external Mesh JS$_processRendering(SubMesh subMesh, Effect effect, num fillMode, JS$_InstancesBatch batch, bool hardwareInstancedRendering, void onBeforeDraw(bool isInstance, Matrix world, [Material effectiveMaterial]), [Material effectiveMaterial]);

    external Mesh render(SubMesh subMesh, bool enableAlphaMode);

    external get JS$_onBeforeDraw;

    external set JS$_onBeforeDraw(v);

    external void cleanMatrixWeights();

    external get normalizeSkinFourWeights;

    external set normalizeSkinFourWeights(v);

    external get normalizeSkinWeightsAndExtra;

    external set normalizeSkinWeightsAndExtra(v);

    external dynamic/*{
            skinned: boolean;
            valid: boolean;
            report: string;
        }*/
    validateSkinning();

    external Mesh JS$_checkDelayState();

    external get JS$_queueLoad;

    external set JS$_queueLoad(v);

    external bool isInFrustum(List<Plane> frustumPlanes);

    external Mesh setMaterialByID(String id);

    external List<IAnimatable> getAnimatables();

    external Mesh bakeTransformIntoVertices(Matrix transform);

    external Mesh bakeCurrentTransformIntoVertices();

    external List<Vector3>/*List<Vector3>|Null*/ get JS$_positions;

    external set JS$_positions(List<Vector3>/*List<Vector3>|Null*/ v);

    external Mesh JS$_resetPointsArrayCache();

    external bool JS$_generatePointsArray();

    external Mesh clone([String name, Node newParent, bool doNotCloneChildren, bool clonePhysicsImpostor]);

    external void dispose([bool doNotRecurse, bool disposeMaterialAndTextures]);

    external Mesh applyDisplacementMap(String url, num minHeight, num maxHeight, [void onSuccess(Mesh mesh), Vector2 uvOffset, Vector2 uvScale, bool forceUpdate]);

    external Mesh applyDisplacementMapFromBuffer(Uint8List buffer, num heightMapWidth, num heightMapHeight, num minHeight, num maxHeight, [Vector2 uvOffset, Vector2 uvScale, bool forceUpdate]);

    external Mesh convertToFlatShadedMesh();

    external Mesh convertToUnIndexedMesh();

    external Mesh flipFaces([bool flipNormals]);

    external InstancedMesh createInstance(String name);

    external Mesh synchronizeInstances();

    external Mesh optimizeIndices([void successCallback([Mesh mesh])]);

    external void serialize(dynamic serializationObject);

    external void JS$_syncGeometryWithMorphTargetManager();

    external static Mesh Parse(dynamic parsedMesh, Scene scene, String rootUrl);

    external static Mesh CreateRibbon(String name, List<List<Vector3>> pathArray, dynamic/*bool|dynamic*/ closeArray, bool closePath, num offset, [Scene scene, bool updatable, num sideOrientation, Mesh instance]);

    external static Mesh CreateDisc(String name, num radius, num tessellation, [Scene/*Scene|Null*/ scene, bool updatable, num sideOrientation]);

    external static Mesh CreateBox(String name, num size, [Scene/*Scene|Null*/ scene, bool updatable, num sideOrientation]);

    external static Mesh CreateSphere(String name, num segments, num diameter, [Scene scene, bool updatable, num sideOrientation]);

    external static Mesh CreateCylinder(String name, num height, num diameterTop, num diameterBottom, num tessellation, dynamic subdivisions, [Scene scene, dynamic updatable, num sideOrientation]);

    external static Mesh CreateTorus(String name, num diameter, num thickness, num tessellation, [Scene scene, bool updatable, num sideOrientation]);

    external static Mesh CreateTorusKnot(String name, num radius, num tube, num radialSegments, num tubularSegments, num p, num q, [Scene scene, bool updatable, num sideOrientation]);

    external static LinesMesh CreateLines(String name, List<Vector3> points, [Scene/*Scene|Null*/ scene, bool updatable, LinesMesh/*LinesMesh|Null*/ instance]);

    external static LinesMesh CreateDashedLines(String name, List<Vector3> points, num dashSize, num gapSize, num dashNb, [Scene/*Scene|Null*/ scene, bool updatable, LinesMesh instance]);

    external static Mesh CreatePolygon(String name, List<Vector3> shape, Scene scene, [List<List<Vector3>> holes, bool updatable, num sideOrientation]);

    external static Mesh ExtrudePolygon(String name, List<Vector3> shape, num depth, Scene scene, [List<List<Vector3>> holes, bool updatable, num sideOrientation]);

    external static Mesh ExtrudeShape(String name, List<Vector3> shape, List<Vector3> path, num scale, num rotation, num cap, [Scene/*Scene|Null*/ scene, bool updatable, num sideOrientation, Mesh instance]);

    external static Mesh ExtrudeShapeCustom(String name, List<Vector3> shape, List<Vector3> path, Function scaleFunction, Function rotationFunction, bool ribbonCloseArray, bool ribbonClosePath, num cap, Scene scene, [bool updatable, num sideOrientation, Mesh instance]);

    external static Mesh CreateLathe(String name, List<Vector3> shape, num radius, num tessellation, Scene scene, [bool updatable, num sideOrientation]);

    external static Mesh CreatePlane(String name, num size, Scene scene, [bool updatable, num sideOrientation]);

    external static Mesh CreateGround(String name, num width, num height, num subdivisions, [Scene scene, bool updatable]);

    external static Mesh CreateTiledGround(String name, num xmin, num zmin, num xmax, num zmax, dynamic/*{
            w: number;
            h: number;
        }*/
    subdivisions, dynamic/*{
            w: number;
            h: number;
        }*/
    precision, Scene scene, [bool updatable]);

    external static GroundMesh CreateGroundFromHeightMap(String name, String url, num width, num height, num subdivisions, num minHeight, num maxHeight, Scene scene, [bool updatable, void onReady(GroundMesh mesh), num alphaFilter]);

    external static Mesh CreateTube(String name, List<Vector3> path, num radius, num tessellation, dynamic/*{
            (i: number, distance: number): number;
        }*/
    radiusFunction, num cap, Scene scene, [bool updatable, num sideOrientation, Mesh instance]);

    external static Mesh CreatePolyhedron(String name, dynamic/*{
            type?: number;
            size?: number;
            sizeX?: number;
            sizeY?: number;
            sizeZ?: number;
            custom?: any;
            faceUV?: Vector4[];
            faceColors?: Color4[];
            updatable?: boolean;
            sideOrientation?: number;
        }*/
    options, Scene scene);

    external static Mesh CreateIcoSphere(String name, dynamic/*{
            radius?: number;
            flat?: boolean;
            subdivisions?: number;
            sideOrientation?: number;
            updatable?: boolean;
        }*/
    options, Scene scene);

    external static Mesh CreateDecal(String name, AbstractMesh sourceMesh, Vector3 position, Vector3 normal, Vector3 size, num angle);

    external Float32List setPositionsForCPUSkinning();

    external Float32List setNormalsForCPUSkinning();

    external Mesh applySkeleton(Skeleton skeleton);

    external static dynamic/*{
            min: Vector3;
            max: Vector3;
        }*/
    MinMax(List<AbstractMesh> meshes);

    external static Vector3 Center(dynamic/*{
            min: Vector3;
            max: Vector3;
        }|List<AbstractMesh>*/
    meshesOrMinMaxVector);

    external static Mesh/*Mesh|Null*/ MergeMeshes(List<Mesh> meshes, [bool disposeSource, bool allow32BitsIndices, Mesh meshSubclass, bool subdivideWithSubMeshes]);

    external Mesh simplify(List<ISimplificationSettings> settings, [bool parallelProcessing, num/*enum SimplificationType*/ simplificationType, void successCallback([Mesh mesh, num submeshIndex])]);

    external List<IParticleSystem> getEmittedParticleSystems();

    external List<IParticleSystem> getHierarchyEmittedParticleSystems();
}

@anonymous
@JS()
abstract class IGetSetVerticesData {
    external bool isVerticesDataPresent(String kind);

    external dynamic/*List<num>|Float32List|Null*/ getVerticesData(String kind, [bool copyWhenShared, bool forceCopy]);

    external dynamic/*List<num>|Int32List|Uint32List|Uint16List|Null*/ getIndices([bool copyWhenShared, bool forceCopy]);

    external void setVerticesData(String kind, dynamic/*List<num>|Float32List*/ data, bool updatable);

    external void updateVerticesData(String kind, dynamic/*List<num>|Float32List*/ data, [bool updateExtends, bool makeItUnique]);

    external void setIndices(dynamic/*List<num>|Int32List|Uint32List|Uint16List*/ indices, num/*num|Null*/ totalVertices, [bool updatable]);
}

@JS("BABYLON.VertexData")
class VertexData {
    // @Ignore
    VertexData .fakeConstructor$();

    external dynamic/*List<num>|Float32List|Null*/ get positions;

    external set positions(dynamic/*List<num>|Float32List|Null*/ v);

    external dynamic/*List<num>|Float32List|Null*/ get normals;

    external set normals(dynamic/*List<num>|Float32List|Null*/ v);

    external dynamic/*List<num>|Float32List|Null*/ get tangents;

    external set tangents(dynamic/*List<num>|Float32List|Null*/ v);

    external dynamic/*List<num>|Float32List|Null*/ get uvs;

    external set uvs(dynamic/*List<num>|Float32List|Null*/ v);

    external dynamic/*List<num>|Float32List|Null*/ get uvs2;

    external set uvs2(dynamic/*List<num>|Float32List|Null*/ v);

    external dynamic/*List<num>|Float32List|Null*/ get uvs3;

    external set uvs3(dynamic/*List<num>|Float32List|Null*/ v);

    external dynamic/*List<num>|Float32List|Null*/ get uvs4;

    external set uvs4(dynamic/*List<num>|Float32List|Null*/ v);

    external dynamic/*List<num>|Float32List|Null*/ get uvs5;

    external set uvs5(dynamic/*List<num>|Float32List|Null*/ v);

    external dynamic/*List<num>|Float32List|Null*/ get uvs6;

    external set uvs6(dynamic/*List<num>|Float32List|Null*/ v);

    external dynamic/*List<num>|Float32List|Null*/ get colors;

    external set colors(dynamic/*List<num>|Float32List|Null*/ v);

    external dynamic/*List<num>|Float32List|Null*/ get matricesIndices;

    external set matricesIndices(dynamic/*List<num>|Float32List|Null*/ v);

    external dynamic/*List<num>|Float32List|Null*/ get matricesWeights;

    external set matricesWeights(dynamic/*List<num>|Float32List|Null*/ v);

    external dynamic/*List<num>|Float32List|Null*/ get matricesIndicesExtra;

    external set matricesIndicesExtra(dynamic/*List<num>|Float32List|Null*/ v);

    external dynamic/*List<num>|Float32List|Null*/ get matricesWeightsExtra;

    external set matricesWeightsExtra(dynamic/*List<num>|Float32List|Null*/ v);

    external dynamic/*List<num>|Int32List|Uint32List|Uint16List|Null*/ get indices;

    external set indices(dynamic/*List<num>|Int32List|Uint32List|Uint16List|Null*/ v);

    external void JS$set(dynamic/*List<num>|Float32List*/ data, String kind);

    external VertexData applyToMesh(Mesh mesh, [bool updatable]);

    external VertexData applyToGeometry(Geometry geometry, [bool updatable]);

    external VertexData updateMesh(Mesh mesh, [bool updateExtends, bool makeItUnique]);

    external VertexData updateGeometry(Geometry geometry, [bool updateExtends, bool makeItUnique]);

    external get JS$_applyTo;

    external set JS$_applyTo(v);

    external get JS$_update;

    external set JS$_update(v);

    external VertexData transform(Matrix matrix);

    external VertexData merge(VertexData other, [bool use32BitsIndices]);

    external get JS$_mergeElement;

    external set JS$_mergeElement(v);

    external get JS$_validate;

    external set JS$_validate(v);

    external dynamic serialize();

    external static VertexData ExtractFromMesh(Mesh mesh, [bool copyWhenShared, bool forceCopy]);

    external static VertexData ExtractFromGeometry(Geometry geometry, [bool copyWhenShared, bool forceCopy]);

    external static get JS$_ExtractFrom;

    external static set JS$_ExtractFrom(v);

    external static VertexData CreateRibbon(dynamic/*{
            pathArray: Vector3[][];
            closeArray?: boolean;
            closePath?: boolean;
            offset?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            invertUV?: boolean;
            uvs?: Vector2[];
            colors?: Color4[];
        }*/
    options);

    external static VertexData CreateBox(dynamic/*{
            size?: number;
            width?: number;
            height?: number;
            depth?: number;
            faceUV?: Vector4[];
            faceColors?: Color4[];
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }*/
    options);

    external static VertexData CreateSphere(dynamic/*{
            segments?: number;
            diameter?: number;
            diameterX?: number;
            diameterY?: number;
            diameterZ?: number;
            arc?: number;
            slice?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }*/
    options);

    external static VertexData CreateCylinder(dynamic/*{
            height?: number;
            diameterTop?: number;
            diameterBottom?: number;
            diameter?: number;
            tessellation?: number;
            subdivisions?: number;
            arc?: number;
            faceColors?: Color4[];
            faceUV?: Vector4[];
            hasRings?: boolean;
            enclose?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }*/
    options);

    external static VertexData CreateTorus(dynamic/*{
            diameter?: number;
            thickness?: number;
            tessellation?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }*/
    options);

    external static VertexData CreateLineSystem(dynamic/*{
            lines: Vector3[][];
            colors?: Nullable<Color4[][]>;
        }*/
    options);

    external static VertexData CreateDashedLines(dynamic/*{
            points: Vector3[];
            dashSize?: number;
            gapSize?: number;
            dashNb?: number;
        }*/
    options);

    external static VertexData CreateGround(dynamic/*{
            width?: number;
            height?: number;
            subdivisions?: number;
            subdivisionsX?: number;
            subdivisionsY?: number;
        }*/
    options);

    external static VertexData CreateTiledGround(dynamic/*{
            xmin: number;
            zmin: number;
            xmax: number;
            zmax: number;
            subdivisions?: {
                w: number;
                h: number;
            };
            precision?: {
                w: number;
                h: number;
            };
        }*/
    options);

    external static VertexData CreateGroundFromHeightMap(dynamic/*{
            width: number;
            height: number;
            subdivisions: number;
            minHeight: number;
            maxHeight: number;
            colorFilter: Color3;
            buffer: Uint8Array;
            bufferWidth: number;
            bufferHeight: number;
            alphaFilter: number;
        }*/
    options);

    external static VertexData CreatePlane(dynamic/*{
            size?: number;
            width?: number;
            height?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }*/
    options);

    external static VertexData CreateDisc(dynamic/*{
            radius?: number;
            tessellation?: number;
            arc?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }*/
    options);

    external static VertexData CreatePolygon(Mesh polygon, num sideOrientation, [List<Vector4> fUV, List<Color4> fColors, Vector4 frontUVs, Vector4 backUVs]);

    external static VertexData CreateIcoSphere(dynamic/*{
            radius?: number;
            radiusX?: number;
            radiusY?: number;
            radiusZ?: number;
            flat?: boolean;
            subdivisions?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }*/
    options);

    external static VertexData CreatePolyhedron(dynamic/*{
            type?: number;
            size?: number;
            sizeX?: number;
            sizeY?: number;
            sizeZ?: number;
            custom?: any;
            faceUV?: Vector4[];
            faceColors?: Color4[];
            flat?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }*/
    options);

    external static VertexData CreateTorusKnot(dynamic/*{
            radius?: number;
            tube?: number;
            radialSegments?: number;
            tubularSegments?: number;
            p?: number;
            q?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }*/
    options);

    external static void ComputeNormals(dynamic positions, dynamic indices, dynamic normals, [dynamic/*{
            facetNormals?: any;
            facetPositions?: any;
            facetPartitioning?: any;
            ratio?: number;
            bInfo?: any;
            bbSize?: Vector3;
            subDiv?: any;
            useRightHandedSystem?: boolean;
            depthSort?: boolean;
            distanceTo?: Vector3;
            depthSortedFacets?: any;
        }*/
    options]);

    external static get JS$_ComputeSides;

    external static set JS$_ComputeSides(v);

    external static void ImportVertexData(dynamic parsedVertexData, Geometry geometry);
}

@JS("BABYLON.MeshBuilder")
class MeshBuilder {
    // @Ignore
    MeshBuilder .fakeConstructor$();

    external static get updateSideOrientation;

    external static set updateSideOrientation(v);

    external static Mesh CreateBox(String name, dynamic/*{
            size?: number;
            width?: number;
            height?: number;
            depth?: number;
            faceUV?: Vector4[];
            faceColors?: Color4[];
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            updatable?: boolean;
        }*/
    options, [Scene/*Scene|Null*/ scene]);

    external static Mesh CreateSphere(String name, dynamic/*{
            segments?: number;
            diameter?: number;
            diameterX?: number;
            diameterY?: number;
            diameterZ?: number;
            arc?: number;
            slice?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            updatable?: boolean;
        }*/
    options, dynamic scene);

    external static Mesh CreateDisc(String name, dynamic/*{
            radius?: number;
            tessellation?: number;
            arc?: number;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }*/
    options, [Scene/*Scene|Null*/ scene]);

    external static Mesh CreateIcoSphere(String name, dynamic/*{
            radius?: number;
            radiusX?: number;
            radiusY?: number;
            radiusZ?: number;
            flat?: boolean;
            subdivisions?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            updatable?: boolean;
        }*/
    options, Scene scene);

    external static Mesh CreateRibbon(String name, dynamic/*{
            pathArray: Vector3[][];
            closeArray?: boolean;
            closePath?: boolean;
            offset?: number;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            instance?: Mesh;
            invertUV?: boolean;
            uvs?: Vector2[];
            colors?: Color4[];
        }*/
    options, [Scene/*Scene|Null*/ scene]);

    external static Mesh CreateCylinder(String name, dynamic/*{
            height?: number;
            diameterTop?: number;
            diameterBottom?: number;
            diameter?: number;
            tessellation?: number;
            subdivisions?: number;
            arc?: number;
            faceColors?: Color4[];
            faceUV?: Vector4[];
            updatable?: boolean;
            hasRings?: boolean;
            enclose?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }*/
    options, dynamic scene);

    external static Mesh CreateTorus(String name, dynamic/*{
            diameter?: number;
            thickness?: number;
            tessellation?: number;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }*/
    options, dynamic scene);

    external static Mesh CreateTorusKnot(String name, dynamic/*{
            radius?: number;
            tube?: number;
            radialSegments?: number;
            tubularSegments?: number;
            p?: number;
            q?: number;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }*/
    options, dynamic scene);

    external static LinesMesh CreateLineSystem(String name, dynamic/*{
            lines: Vector3[][];
            updatable?: boolean;
            instance?: Nullable<LinesMesh>;
            colors?: Nullable<Color4[][]>;
            useVertexAlpha?: boolean;
        }*/
    options, Scene/*Scene|Null*/ scene);

    external static LinesMesh CreateLines(String name, dynamic/*{
            points: Vector3[];
            updatable?: boolean;
            instance?: Nullable<LinesMesh>;
            colors?: Color4[];
            useVertexAlpha?: boolean;
        }*/
    options, [Scene/*Scene|Null*/ scene]);

    external static LinesMesh CreateDashedLines(String name, dynamic/*{
            points: Vector3[];
            dashSize?: number;
            gapSize?: number;
            dashNb?: number;
            updatable?: boolean;
            instance?: LinesMesh;
        }*/
    options, [Scene/*Scene|Null*/ scene]);

    external static Mesh ExtrudeShape(String name, dynamic/*{
            shape: Vector3[];
            path: Vector3[];
            scale?: number;
            rotation?: number;
            cap?: number;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            instance?: Mesh;
            invertUV?: boolean;
        }*/
    options, [Scene/*Scene|Null*/ scene]);

    external static Mesh ExtrudeShapeCustom(String name, dynamic/*{
            shape: Vector3[];
            path: Vector3[];
            scaleFunction?: any;
            rotationFunction?: any;
            ribbonCloseArray?: boolean;
            ribbonClosePath?: boolean;
            cap?: number;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            instance?: Mesh;
            invertUV?: boolean;
        }*/
    options, Scene scene);

    external static Mesh CreateLathe(String name, dynamic/*{
            shape: Vector3[];
            radius?: number;
            tessellation?: number;
            clip?: number;
            arc?: number;
            closed?: boolean;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            cap?: number;
            invertUV?: boolean;
        }*/
    options, Scene scene);

    external static Mesh CreatePlane(String name, dynamic/*{
            size?: number;
            width?: number;
            height?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            updatable?: boolean;
            sourcePlane?: Plane;
        }*/
    options, Scene scene);

    external static Mesh CreateGround(String name, dynamic/*{
            width?: number;
            height?: number;
            subdivisions?: number;
            subdivisionsX?: number;
            subdivisionsY?: number;
            updatable?: boolean;
        }*/
    options, dynamic scene);

    external static Mesh CreateTiledGround(String name, dynamic/*{
            xmin: number;
            zmin: number;
            xmax: number;
            zmax: number;
            subdivisions?: {
                w: number;
                h: number;
            };
            precision?: {
                w: number;
                h: number;
            };
            updatable?: boolean;
        }*/
    options, Scene scene);

    external static GroundMesh CreateGroundFromHeightMap(String name, String url, dynamic/*{
            width?: number;
            height?: number;
            subdivisions?: number;
            minHeight?: number;
            maxHeight?: number;
            colorFilter?: Color3;
            alphaFilter?: number;
            updatable?: boolean;
            onReady?: (mesh: GroundMesh) => void;
        }*/
    options, Scene scene);

    external static Mesh CreatePolygon(String name, dynamic/*{
            shape: Vector3[];
            holes?: Vector3[][];
            depth?: number;
            faceUV?: Vector4[];
            faceColors?: Color4[];
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }*/
    options, Scene scene);

    external static Mesh ExtrudePolygon(String name, dynamic/*{
            shape: Vector3[];
            holes?: Vector3[][];
            depth?: number;
            faceUV?: Vector4[];
            faceColors?: Color4[];
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }*/
    options, Scene scene);

    external static Mesh CreateTube(String name, dynamic/*{
            path: Vector3[];
            radius?: number;
            tessellation?: number;
            radiusFunction?: {
                (i: number, distance: number): number;
            };
            cap?: number;
            arc?: number;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            instance?: Mesh;
            invertUV?: boolean;
        }*/
    options, Scene scene);

    external static Mesh CreatePolyhedron(String name, dynamic/*{
            type?: number;
            size?: number;
            sizeX?: number;
            sizeY?: number;
            sizeZ?: number;
            custom?: any;
            faceUV?: Vector4[];
            faceColors?: Color4[];
            flat?: boolean;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }*/
    options, Scene scene);

    external static Mesh CreateDecal(String name, AbstractMesh sourceMesh, dynamic/*{
            position?: Vector3;
            normal?: Vector3;
            size?: Vector3;
            angle?: number;
        }*/
    options);

    external static get JS$_ExtrudeShapeGeneric;

    external static set JS$_ExtrudeShapeGeneric(v);
}

@JS("BABYLON.MeshLODLevel")
class MeshLODLevel {
    // @Ignore
    MeshLODLevel .fakeConstructor$();

    external num get distance;

    external set distance(num v);

    external Mesh/*Mesh|Null*/ get mesh;

    external set mesh(Mesh/*Mesh|Null*/ v);

    external factory MeshLODLevel(num distance, Mesh/*Mesh|Null*/ mesh);
}

@anonymous
@JS()
abstract class ISimplifier {
    external void simplify(ISimplificationSettings settings, void successCallback(Mesh simplifiedMeshes), [void errorCallback()]);
}

@anonymous
@JS()
abstract class ISimplificationSettings {
    external num get quality;

    external set quality(num v);

    external num get distance;

    external set distance(num v);

    external bool get optimizeMesh;

    external set optimizeMesh(bool v);

    external factory ISimplificationSettings({ num quality, num distance, bool optimizeMesh});
}

@JS("BABYLON.SimplificationSettings")
class SimplificationSettings implements ISimplificationSettings {
    // @Ignore
    SimplificationSettings .fakeConstructor$();

    external num get quality;

    external set quality(num v);

    external num get distance;

    external set distance(num v);

    external dynamic/*bool|dynamic*/ get optimizeMesh;

    external set optimizeMesh(dynamic/*bool|dynamic*/ v);

    external factory SimplificationSettings(num quality, num distance, [dynamic/*bool|dynamic*/ optimizeMesh]);
}

@anonymous
@JS()
abstract class ISimplificationTask {
    external List<ISimplificationSettings> get settings;

    external set settings(List<ISimplificationSettings> v);

    external num/*enum SimplificationType*/ get simplificationType;

    external set simplificationType(num/*enum SimplificationType*/ v);

    external Mesh get mesh;

    external set mesh(Mesh v);

    external VoidFunc0 get successCallback;

    external set successCallback(VoidFunc0 v);

    external bool get parallelProcessing;

    external set parallelProcessing(bool v);

    external factory ISimplificationTask({ List<ISimplificationSettings> settings, num/*enum SimplificationType*/ simplificationType, Mesh mesh, VoidFunc0 successCallback, bool parallelProcessing});
}

@JS("BABYLON.SimplificationQueue")
class SimplificationQueue {
    // @Ignore
    SimplificationQueue .fakeConstructor$();

    external get JS$_simplificationArray;

    external set JS$_simplificationArray(v);

    external bool get running;

    external set running(bool v);

    external factory SimplificationQueue();

    external void addTask(ISimplificationTask task);

    external void executeNext();

    external void runSimplification(ISimplificationTask task);

    external get getSimplifier;

    external set getSimplifier(v);
}

@JS("BABYLON.SimplificationType")
class SimplificationType {
    external static num get QUADRATIC;
}

@anonymous
@JS()
abstract class Scene {
    external SimplificationQueue get JS$_simplificationQueue;

    external set JS$_simplificationQueue(SimplificationQueue v);

    external SimplificationQueue get simplificationQueue;

    external set simplificationQueue(SimplificationQueue v);
}

@anonymous
@JS()
abstract class Mesh {
    external Mesh simplify(List<ISimplificationSettings> settings, [bool parallelProcessing, num/*enum SimplificationType*/ simplificationType, void successCallback([Mesh mesh, num submeshIndex])]);
}

@JS("BABYLON.SimplicationQueueSceneComponent")
class SimplicationQueueSceneComponent implements ISceneComponent {
    // @Ignore
    SimplicationQueueSceneComponent .fakeConstructor$();

    external String get name;

    external set name(String v);

    external Scene get scene;

    external set scene(Scene v);

    external factory SimplicationQueueSceneComponent(Scene scene);

    external void register();

    external void rebuild();

    external void dispose();

    external get JS$_beforeCameraUpdate;

    external set JS$_beforeCameraUpdate(v);
}

@JS("BABYLON.Polygon")
class Polygon {
    // @Ignore
    Polygon .fakeConstructor$();

    external static List<Vector2> Rectangle(num xmin, num ymin, num xmax, num ymax);

    external static List<Vector2> Circle(num radius, [num cx, num cy, num numberOfSides]);

    external static List<Vector2> Parse(String input);

    external static Path2 StartingAt(num x, num y);
}

@JS("BABYLON.PolygonMeshBuilder")
class PolygonMeshBuilder {
    // @Ignore
    PolygonMeshBuilder .fakeConstructor$();

    external get JS$_points;

    external set JS$_points(v);

    external get JS$_outlinepoints;

    external set JS$_outlinepoints(v);

    external get JS$_holes;

    external set JS$_holes(v);

    external get JS$_name;

    external set JS$_name(v);

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_epoints;

    external set JS$_epoints(v);

    external get JS$_eholes;

    external set JS$_eholes(v);

    external get JS$_addToepoint;

    external set JS$_addToepoint(v);

    external factory PolygonMeshBuilder(String name, dynamic/*Path2|List<Vector2>|dynamic*/ contours, Scene scene);

    external PolygonMeshBuilder addHole(List<Vector2> hole);

    external Mesh build([bool updatable, num depth]);

    external get addSide;

    external set addSide(v);
}

@JS("BABYLON.BaseSubMesh")
class BaseSubMesh {
    // @Ignore
    BaseSubMesh .fakeConstructor$();

    external MaterialDefines/*MaterialDefines|Null*/ get JS$_materialDefines;

    external set JS$_materialDefines(MaterialDefines/*MaterialDefines|Null*/ v);

    external Effect/*Effect|Null*/ get JS$_materialEffect;

    external set JS$_materialEffect(Effect/*Effect|Null*/ v);

    external Effect/*Effect|Null*/ get effect;

    external set effect(Effect/*Effect|Null*/ v);

    external void setEffect(Effect/*Effect|Null*/ effect, [MaterialDefines/*MaterialDefines|Null*/ defines]);
}

@JS("BABYLON.SubMesh")
class SubMesh extends BaseSubMesh implements ICullable {
    // @Ignore
    SubMesh .fakeConstructor$() : super.fakeConstructor$();
    external num get materialIndex;

    external set materialIndex(num v);

    external num get verticesStart;

    external set verticesStart(num v);

    external num get verticesCount;

    external set verticesCount(num v);

    external num get indexStart;

    external set indexStart(num v);

    external num get indexCount;

    external set indexCount(num v);

    external num get JS$_linesIndexCount;

    external set JS$_linesIndexCount(num v);

    external get JS$_mesh;

    external set JS$_mesh(v);

    external get JS$_renderingMesh;

    external set JS$_renderingMesh(v);

    external get JS$_boundingInfo;

    external set JS$_boundingInfo(v);

    external get JS$_linesIndexBuffer;

    external set JS$_linesIndexBuffer(v);

    external List<Vector3>/*List<Vector3>|Null*/ get JS$_lastColliderWorldVertices;

    external set JS$_lastColliderWorldVertices(List<Vector3>/*List<Vector3>|Null*/ v);

    external List<Plane> get JS$_trianglePlanes;

    external set JS$_trianglePlanes(List<Plane> v);

    external Matrix get JS$_lastColliderTransformMatrix;

    external set JS$_lastColliderTransformMatrix(Matrix v);

    external num get JS$_renderId;

    external set JS$_renderId(num v);

    external num get JS$_alphaIndex;

    external set JS$_alphaIndex(num v);

    external num get JS$_distanceToCamera;

    external set JS$_distanceToCamera(num v);

    external num get JS$_id;

    external set JS$_id(num v);

    external get JS$_currentMaterial;

    external set JS$_currentMaterial(v);

    external static SubMesh AddToMesh(num materialIndex, num verticesStart, num verticesCount, num indexStart, num indexCount, AbstractMesh mesh, [Mesh renderingMesh, bool createBoundingBox]);

    external factory SubMesh(num materialIndex, num verticesStart, num verticesCount, num indexStart, num indexCount, AbstractMesh mesh, [Mesh renderingMesh, bool createBoundingBox]);

    external bool get IsGlobal;

    external set IsGlobal(bool v);

    external BoundingInfo getBoundingInfo();

    external SubMesh setBoundingInfo(BoundingInfo boundingInfo);

    external AbstractMesh getMesh();

    external Mesh getRenderingMesh();

    external Material/*Material|Null*/ getMaterial();

    external SubMesh refreshBoundingInfo();

    external bool JS$_checkCollision(Collider collider);

    external SubMesh updateBoundingInfo(Matrix world);

    external bool isInFrustum(List<Plane> frustumPlanes);

    external bool isCompletelyInFrustum(List<Plane> frustumPlanes);

    external SubMesh render(bool enableAlphaMode);

    external Buffer JS$_getLinesIndexBuffer(dynamic/*List<num>|Int32List|Uint32List|Uint16List*/ indices, Engine engine);

    external bool canIntersects(Ray ray);

    external IntersectionInfo/*IntersectionInfo|Null*/ intersects(Ray ray, List<Vector3> positions, dynamic/*List<num>|Int32List|Uint32List|Uint16List*/ indices, [bool fastCheck]);

    external get JS$_intersectLines;

    external set JS$_intersectLines(v);

    external get JS$_intersectTriangles;

    external set JS$_intersectTriangles(v);

    external void JS$_rebuild();

    external SubMesh clone(AbstractMesh newMesh, [Mesh newRenderingMesh]);

    external void dispose();

    external static SubMesh CreateFromIndices(num materialIndex, num startIndex, num indexCount, AbstractMesh mesh, [Mesh renderingMesh]);
}

@JS("BABYLON.TransformNode")
class TransformNode extends Node {
    // @Ignore
    TransformNode .fakeConstructor$() : super.fakeConstructor$();
    external static num get BILLBOARDMODE_NONE;

    external static set BILLBOARDMODE_NONE(num v);

    external static num get BILLBOARDMODE_X;

    external static set BILLBOARDMODE_X(num v);

    external static num get BILLBOARDMODE_Y;

    external static set BILLBOARDMODE_Y(num v);

    external static num get BILLBOARDMODE_Z;

    external static set BILLBOARDMODE_Z(num v);

    external static num get BILLBOARDMODE_ALL;

    external static set BILLBOARDMODE_ALL(num v);

    external get JS$_forward;

    external set JS$_forward(v);

    external get JS$_forwardInverted;

    external set JS$_forwardInverted(v);

    external get JS$_up;

    external set JS$_up(v);

    external get JS$_right;

    external set JS$_right(v);

    external get JS$_rightInverted;

    external set JS$_rightInverted(v);

    external get JS$_position;

    external set JS$_position(v);

    external get JS$_rotation;

    external set JS$_rotation(v);

    external get JS$_rotationQuaternion;

    external set JS$_rotationQuaternion(v);

    external Vector3 get JS$_scaling;

    external set JS$_scaling(Vector3 v);

    external bool get JS$_isDirty;

    external set JS$_isDirty(bool v);

    external get JS$_transformToBoneReferal;

    external set JS$_transformToBoneReferal(v);

    external num get billboardMode;

    external set billboardMode(num v);

    external num get scalingDeterminant;

    external set scalingDeterminant(num v);

    external bool get infiniteDistance;

    external set infiniteDistance(bool v);

    external bool get ignoreNonUniformScaling;

    external set ignoreNonUniformScaling(bool v);

    external Matrix get JS$_poseMatrix;

    external set JS$_poseMatrix(Matrix v);

    external get JS$_localWorld;

    external set JS$_localWorld(v);

    external get JS$_absolutePosition;

    external set JS$_absolutePosition(v);

    external get JS$_pivotMatrix;

    external set JS$_pivotMatrix(v);

    external get JS$_pivotMatrixInverse;

    external set JS$_pivotMatrixInverse(v);

    external get JS$_postMultiplyPivotMatrix;

    external set JS$_postMultiplyPivotMatrix(v);

    external bool get JS$_isWorldMatrixFrozen;

    external set JS$_isWorldMatrixFrozen(bool v);

    external Observable<TransformNode> get onAfterWorldMatrixUpdateObservable;

    external set onAfterWorldMatrixUpdateObservable(Observable<TransformNode> v);

    external factory TransformNode(String name, [Scene/*Scene|Null*/ scene, bool isPure]);

    external String getClassName();

    external Vector3 get position;

    external set position(Vector3 v);

    external Vector3 get rotation;

    external set rotation(Vector3 v);

    external Vector3 get scaling;

    external set scaling(Vector3 v);

    external Quaternion/*Quaternion|Null*/ get rotationQuaternion;

    external set rotationQuaternion(Quaternion/*Quaternion|Null*/ v);

    external Vector3 get forward;

    external set forward(Vector3 v);

    external Vector3 get up;

    external set up(Vector3 v);

    external Vector3 get right;

    external set right(Vector3 v);

    external TransformNode updatePoseMatrix(Matrix matrix);

    external Matrix getPoseMatrix();

    external bool JS$_isSynchronized();

    external void JS$_initCache();

    external TransformNode markAsDirty(String property);

    external Vector3 get absolutePosition;

    external set absolutePosition(Vector3 v);

    external TransformNode setPreTransformMatrix(Matrix matrix);

    external TransformNode setPivotMatrix(Matrix matrix, [bool postMultiplyPivotMatrix]);

    external Matrix getPivotMatrix();

    external TransformNode freezeWorldMatrix();

    external TransformNode unfreezeWorldMatrix();

    external bool get isWorldMatrixFrozen;

    external set isWorldMatrixFrozen(bool v);

    external Vector3 getAbsolutePosition();

    external TransformNode setAbsolutePosition(Vector3 absolutePosition);

    external TransformNode setPositionWithLocalVector(Vector3 vector3);

    external Vector3 getPositionExpressedInLocalSpace();

    external TransformNode locallyTranslate(Vector3 vector3);

    external static get JS$_lookAtVectorCache;

    external static set JS$_lookAtVectorCache(v);

    external TransformNode lookAt(Vector3 targetPoint, [num yawCor, num pitchCor, num rollCor, num/*enum Space*/ space]);

    external Vector3 getDirection(Vector3 localAxis);

    external TransformNode getDirectionToRef(Vector3 localAxis, Vector3 result);

    external TransformNode setPivotPoint(Vector3 point, [num/*enum Space*/ space]);

    external Vector3 getPivotPoint();

    external TransformNode getPivotPointToRef(Vector3 result);

    external Vector3 getAbsolutePivotPoint();

    external TransformNode getAbsolutePivotPointToRef(Vector3 result);

    external TransformNode setParent(Node/*Node|Null*/ node);

    external get JS$_nonUniformScaling;

    external set JS$_nonUniformScaling(v);

    external bool get nonUniformScaling;

    external set nonUniformScaling(bool v);

    external bool JS$_updateNonUniformScalingState(bool value);

    external TransformNode attachToBone(Bone bone, TransformNode affectedTransformNode);

    external TransformNode detachFromBone();

    external static get JS$_rotationAxisCache;

    external static set JS$_rotationAxisCache(v);

    external TransformNode rotate(Vector3 axis, num amount, [num/*enum Space*/ space]);

    external TransformNode rotateAround(Vector3 point, Vector3 axis, num amount);

    external TransformNode translate(Vector3 axis, num distance, [num/*enum Space*/ space]);

    external TransformNode addRotation(num x, num y, num z);

    external Matrix computeWorldMatrix([bool force]);

    external void JS$_afterComputeWorldMatrix();

    external TransformNode registerAfterWorldMatrixUpdate(void func(TransformNode mesh));

    external TransformNode unregisterAfterWorldMatrixUpdate(void func(TransformNode mesh));

    external TransformNode/*TransformNode|Null*/ clone(String name, Node newParent, [bool doNotCloneChildren]);

    external dynamic serialize([dynamic currentSerializationObject]);

    external static TransformNode Parse(dynamic parsedTransformNode, Scene scene, String rootUrl);

    external void dispose([bool doNotRecurse, bool disposeMaterialAndTextures]);
}

@JS("BABYLON.VertexBuffer")
class VertexBuffer {
    // @Ignore
    VertexBuffer .fakeConstructor$();

    external Buffer get JS$_buffer;

    external set JS$_buffer(Buffer v);

    external get JS$_kind;

    external set JS$_kind(v);

    external get JS$_size;

    external set JS$_size(v);

    external get JS$_ownsBuffer;

    external set JS$_ownsBuffer(v);

    external get JS$_instanced;

    external set JS$_instanced(v);

    external get JS$_instanceDivisor;

    external set JS$_instanceDivisor(v);

    external static num get BYTE;

    external static set BYTE(num v);

    external static num get UNSIGNED_BYTE;

    external static set UNSIGNED_BYTE(num v);

    external static num get SHORT;

    external static set SHORT(num v);

    external static num get UNSIGNED_SHORT;

    external static set UNSIGNED_SHORT(num v);

    external static num get INT;

    external static set INT(num v);

    external static num get UNSIGNED_INT;

    external static set UNSIGNED_INT(num v);

    external static num get FLOAT;

    external static set FLOAT(num v);

    external num get instanceDivisor;

    external set instanceDivisor(num v);

    external num get byteStride;

    external set byteStride(num v);

    external num get byteOffset;

    external set byteOffset(num v);

    external bool get normalized;

    external set normalized(bool v);

    external num get type;

    external set type(num v);

    external factory VertexBuffer(dynamic engine, dynamic/*List<num>|ByteBuffer|TypedData|Buffer*/ data, String kind, bool updatable, [bool postponeInternalCreation, num stride, bool instanced, num offset, num size, num type, bool normalized, bool useBytes]);

    external void JS$_rebuild();

    external String getKind();

    external bool isUpdatable();

    external dynamic/*List<num>|ByteBuffer|TypedData|Null*/ getData();

    external Buffer/*Buffer|Null*/ getBuffer();

    external num getStrideSize();

    external num getOffset();

    external num getSize();

    external bool getIsInstanced();

    external num getInstanceDivisor();

    external void create([dynamic/*List<num>|ByteBuffer|TypedData*/ data]);

    external void update(dynamic/*List<num>|ByteBuffer|TypedData*/ data);

    external void updateDirectly(dynamic/*List<num>|ByteBuffer|TypedData*/ data, num offset, [bool useBytes]);

    external void dispose();

    external void forEach(num count, void callback(num value, num index));

    external static String get PositionKind;

    external static set PositionKind(String v);

    external static String get NormalKind;

    external static set NormalKind(String v);

    external static String get TangentKind;

    external static set TangentKind(String v);

    external static String get UVKind;

    external static set UVKind(String v);

    external static String get UV2Kind;

    external static set UV2Kind(String v);

    external static String get UV3Kind;

    external static set UV3Kind(String v);

    external static String get UV4Kind;

    external static set UV4Kind(String v);

    external static String get UV5Kind;

    external static set UV5Kind(String v);

    external static String get UV6Kind;

    external static set UV6Kind(String v);

    external static String get ColorKind;

    external static set ColorKind(String v);

    external static String get MatricesIndicesKind;

    external static set MatricesIndicesKind(String v);

    external static String get MatricesWeightsKind;

    external static set MatricesWeightsKind(String v);

    external static String get MatricesIndicesExtraKind;

    external static set MatricesIndicesExtraKind(String v);

    external static String get MatricesWeightsExtraKind;

    external static set MatricesWeightsExtraKind(String v);

    external static num DeduceStride(String kind);

    external static num GetTypeByteLength(num type);

    external static void ForEach(dynamic/*List<num>|ByteBuffer|TypedData*/ data, num byteOffset, num byteStride, num componentCount, num componentType, num count, bool normalized, void callback(num value, num index));

    external static get JS$_GetFloatValue;

    external static set JS$_GetFloatValue(v);
}

@JS("BABYLON.MorphTarget")
class MorphTarget implements IAnimatable {
    // @Ignore
    MorphTarget .fakeConstructor$();

    external String get name;

    external set name(String v);

    external List<Animation> get animations;

    external set animations(List<Animation> v);

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_positions;

    external set JS$_positions(v);

    external get JS$_normals;

    external set JS$_normals(v);

    external get JS$_tangents;

    external set JS$_tangents(v);

    external get JS$_influence;

    external set JS$_influence(v);

    external Observable<bool> get onInfluenceChanged;

    external set onInfluenceChanged(Observable<bool> v);

    external Observable<Null> get JS$_onDataLayoutChanged;

    external set JS$_onDataLayoutChanged(Observable<Null> v);

    external num get influence;

    external set influence(num v);

    external get JS$_animationPropertiesOverride;

    external set JS$_animationPropertiesOverride(v);

    external AnimationPropertiesOverride/*AnimationPropertiesOverride|Null*/ get animationPropertiesOverride;

    external set animationPropertiesOverride(AnimationPropertiesOverride/*AnimationPropertiesOverride|Null*/ v);

    external factory MorphTarget(String name, [num influence, Scene/*Scene|Null*/ scene]);

    external bool get hasPositions;

    external set hasPositions(bool v);

    external bool get hasNormals;

    external set hasNormals(bool v);

    external bool get hasTangents;

    external set hasTangents(bool v);

    external void setPositions(dynamic/*List<num>|Float32List|Null*/ data);

    external dynamic/*List<num>|Float32List|Null*/ getPositions();

    external void setNormals(dynamic/*List<num>|Float32List|Null*/ data);

    external dynamic/*List<num>|Float32List|Null*/ getNormals();

    external void setTangents(dynamic/*List<num>|Float32List|Null*/ data);

    external dynamic/*List<num>|Float32List|Null*/ getTangents();

    external dynamic serialize();

    external static MorphTarget Parse(dynamic serializationObject);

    external static MorphTarget FromMesh(AbstractMesh mesh, [String name, num influence]);
}

@JS("BABYLON.MorphTargetManager")
class MorphTargetManager {
    // @Ignore
    MorphTargetManager .fakeConstructor$();

    external get JS$_targets;

    external set JS$_targets(v);

    external get JS$_targetInfluenceChangedObservers;

    external set JS$_targetInfluenceChangedObservers(v);

    external get JS$_targetDataLayoutChangedObservers;

    external set JS$_targetDataLayoutChangedObservers(v);

    external get JS$_activeTargets;

    external set JS$_activeTargets(v);

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_influences;

    external set JS$_influences(v);

    external get JS$_supportsNormals;

    external set JS$_supportsNormals(v);

    external get JS$_supportsTangents;

    external set JS$_supportsTangents(v);

    external get JS$_vertexCount;

    external set JS$_vertexCount(v);

    external get JS$_uniqueId;

    external set JS$_uniqueId(v);

    external get JS$_tempInfluences;

    external set JS$_tempInfluences(v);

    external factory MorphTargetManager([Scene/*Scene|Null*/ scene]);

    external num get uniqueId;

    external set uniqueId(num v);

    external num get vertexCount;

    external set vertexCount(num v);

    external bool get supportsNormals;

    external set supportsNormals(bool v);

    external bool get supportsTangents;

    external set supportsTangents(bool v);

    external num get numTargets;

    external set numTargets(num v);

    external num get numInfluencers;

    external set numInfluencers(num v);

    external Float32List get influences;

    external set influences(Float32List v);

    external MorphTarget getActiveTarget(num index);

    external MorphTarget getTarget(num index);

    external void addTarget(MorphTarget target);

    external void removeTarget(MorphTarget target);

    external dynamic serialize();

    external get JS$_syncActiveTargets;

    external set JS$_syncActiveTargets(v);

    external void synchronize();

    external static MorphTargetManager Parse(dynamic serializationObject, Scene scene);
}

@JS("BABYLON.BaseParticleSystem")
class BaseParticleSystem {
    // @Ignore
    BaseParticleSystem .fakeConstructor$();

    external static num get BLENDMODE_ONEONE;

    external static set BLENDMODE_ONEONE(num v);

    external static num get BLENDMODE_STANDARD;

    external static set BLENDMODE_STANDARD(num v);

    external static num get BLENDMODE_ADD;

    external static set BLENDMODE_ADD(num v);

    external static num get BLENDMODE_MULTIPLY;

    external static set BLENDMODE_MULTIPLY(num v);

    external static num get BLENDMODE_MULTIPLYADD;

    external static set BLENDMODE_MULTIPLYADD(num v);

    external List<Animation> get animations;

    external set animations(List<Animation> v);

    external String get id;

    external set id(String v);

    external String get name;

    external set name(String v);

    external num get renderingGroupId;

    external set renderingGroupId(num v);

    external dynamic/*AbstractMesh|Vector3|Null*/ get emitter;

    external set emitter(dynamic/*AbstractMesh|Vector3|Null*/ v);

    external num get emitRate;

    external set emitRate(num v);

    external num get manualEmitCount;

    external set manualEmitCount(num v);

    external num get updateSpeed;

    external set updateSpeed(num v);

    external num get targetStopDuration;

    external set targetStopDuration(num v);

    external bool get disposeOnStop;

    external set disposeOnStop(bool v);

    external num get minEmitPower;

    external set minEmitPower(num v);

    external num get maxEmitPower;

    external set maxEmitPower(num v);

    external num get minLifeTime;

    external set minLifeTime(num v);

    external num get maxLifeTime;

    external set maxLifeTime(num v);

    external num get minSize;

    external set minSize(num v);

    external num get maxSize;

    external set maxSize(num v);

    external num get minScaleX;

    external set minScaleX(num v);

    external num get maxScaleX;

    external set maxScaleX(num v);

    external num get minScaleY;

    external set minScaleY(num v);

    external num get maxScaleY;

    external set maxScaleY(num v);

    external num get minInitialRotation;

    external set minInitialRotation(num v);

    external num get maxInitialRotation;

    external set maxInitialRotation(num v);

    external num get minAngularSpeed;

    external set minAngularSpeed(num v);

    external num get maxAngularSpeed;

    external set maxAngularSpeed(num v);

    external Texture/*Texture|Null*/ get particleTexture;

    external set particleTexture(Texture/*Texture|Null*/ v);

    external num get layerMask;

    external set layerMask(num v);

    external dynamic get customShader;

    external set customShader(dynamic v);

    external bool get preventAutoStart;

    external set preventAutoStart(bool v);

    external ProceduralTexture/*ProceduralTexture|Null*/ get noiseTexture;

    external set noiseTexture(ProceduralTexture/*ProceduralTexture|Null*/ v);

    external Vector3 get noiseStrength;

    external set noiseStrength(Vector3 v);

    external VoidFunc0/*VoidFunc0|Null*/ get onAnimationEnd;

    external set onAnimationEnd(VoidFunc0/*VoidFunc0|Null*/ v);

    external num get blendMode;

    external set blendMode(num v);

    external bool get forceDepthWrite;

    external set forceDepthWrite(bool v);

    external num get preWarmCycles;

    external set preWarmCycles(num v);

    external num get preWarmStepOffset;

    external set preWarmStepOffset(num v);

    external num get spriteCellChangeSpeed;

    external set spriteCellChangeSpeed(num v);

    external num get startSpriteCellID;

    external set startSpriteCellID(num v);

    external num get endSpriteCellID;

    external set endSpriteCellID(num v);

    external num get spriteCellWidth;

    external set spriteCellWidth(num v);

    external num get spriteCellHeight;

    external set spriteCellHeight(num v);

    external bool get spriteRandomStartCell;

    external set spriteRandomStartCell(bool v);

    external Vector2 get translationPivot;

    external set translationPivot(Vector2 v);

    external bool get JS$_isAnimationSheetEnabled;

    external set JS$_isAnimationSheetEnabled(bool v);

    external bool get beginAnimationOnStart;

    external set beginAnimationOnStart(bool v);

    external num get beginAnimationFrom;

    external set beginAnimationFrom(num v);

    external num get beginAnimationTo;

    external set beginAnimationTo(num v);

    external bool get beginAnimationLoop;

    external set beginAnimationLoop(bool v);

    external bool get isAnimationSheetEnabled;

    external set isAnimationSheetEnabled(bool v);

    external Scene getScene();

    external Vector3 get gravity;

    external set gravity(Vector3 v);

    external List<ColorGradient>/*List<ColorGradient>|Null*/ get JS$_colorGradients;

    external set JS$_colorGradients(List<ColorGradient>/*List<ColorGradient>|Null*/ v);

    external List<FactorGradient>/*List<FactorGradient>|Null*/ get JS$_sizeGradients;

    external set JS$_sizeGradients(List<FactorGradient>/*List<FactorGradient>|Null*/ v);

    external List<FactorGradient>/*List<FactorGradient>|Null*/ get JS$_lifeTimeGradients;

    external set JS$_lifeTimeGradients(List<FactorGradient>/*List<FactorGradient>|Null*/ v);

    external List<FactorGradient>/*List<FactorGradient>|Null*/ get JS$_angularSpeedGradients;

    external set JS$_angularSpeedGradients(List<FactorGradient>/*List<FactorGradient>|Null*/ v);

    external List<FactorGradient>/*List<FactorGradient>|Null*/ get JS$_velocityGradients;

    external set JS$_velocityGradients(List<FactorGradient>/*List<FactorGradient>|Null*/ v);

    external List<FactorGradient>/*List<FactorGradient>|Null*/ get JS$_limitVelocityGradients;

    external set JS$_limitVelocityGradients(List<FactorGradient>/*List<FactorGradient>|Null*/ v);

    external List<FactorGradient>/*List<FactorGradient>|Null*/ get JS$_dragGradients;

    external set JS$_dragGradients(List<FactorGradient>/*List<FactorGradient>|Null*/ v);

    external List<FactorGradient>/*List<FactorGradient>|Null*/ get JS$_emitRateGradients;

    external set JS$_emitRateGradients(List<FactorGradient>/*List<FactorGradient>|Null*/ v);

    external List<FactorGradient>/*List<FactorGradient>|Null*/ get JS$_startSizeGradients;

    external set JS$_startSizeGradients(List<FactorGradient>/*List<FactorGradient>|Null*/ v);

    external List<Color3Gradient>/*List<Color3Gradient>|Null*/ get JS$_rampGradients;

    external set JS$_rampGradients(List<Color3Gradient>/*List<Color3Gradient>|Null*/ v);

    external List<FactorGradient>/*List<FactorGradient>|Null*/ get JS$_colorRemapGradients;

    external set JS$_colorRemapGradients(List<FactorGradient>/*List<FactorGradient>|Null*/ v);

    external List<FactorGradient>/*List<FactorGradient>|Null*/ get JS$_alphaRemapGradients;

    external set JS$_alphaRemapGradients(List<FactorGradient>/*List<FactorGradient>|Null*/ v);

    external bool/*bool|Null*/ JS$_hasTargetStopDurationDependantGradient();

    external num get startDelay;

    external set startDelay(num v);

    external List<FactorGradient>/*List<FactorGradient>|Null*/ getDragGradients();

    external num get limitVelocityDamping;

    external set limitVelocityDamping(num v);

    external List<FactorGradient>/*List<FactorGradient>|Null*/ getLimitVelocityGradients();

    external List<ColorGradient>/*List<ColorGradient>|Null*/ getColorGradients();

    external List<FactorGradient>/*List<FactorGradient>|Null*/ getSizeGradients();

    external List<FactorGradient>/*List<FactorGradient>|Null*/ getColorRemapGradients();

    external List<FactorGradient>/*List<FactorGradient>|Null*/ getAlphaRemapGradients();

    external List<FactorGradient>/*List<FactorGradient>|Null*/ getLifeTimeGradients();

    external List<FactorGradient>/*List<FactorGradient>|Null*/ getAngularSpeedGradients();

    external List<FactorGradient>/*List<FactorGradient>|Null*/ getVelocityGradients();

    external List<FactorGradient>/*List<FactorGradient>|Null*/ getStartSizeGradients();

    external List<FactorGradient>/*List<FactorGradient>|Null*/ getEmitRateGradients();

    external Vector3 get direction1;

    external set direction1(Vector3 v);

    external Vector3 get direction2;

    external set direction2(Vector3 v);

    external Vector3 get minEmitBox;

    external set minEmitBox(Vector3 v);

    external Vector3 get maxEmitBox;

    external set maxEmitBox(Vector3 v);

    external Color4 get color1;

    external set color1(Color4 v);

    external Color4 get color2;

    external set color2(Color4 v);

    external Color4 get colorDead;

    external set colorDead(Color4 v);

    external Color4 get textureMask;

    external set textureMask(Color4 v);

    external IParticleEmitterType get particleEmitterType;

    external set particleEmitterType(IParticleEmitterType v);

    external bool get JS$_isSubEmitter;

    external set JS$_isSubEmitter(bool v);

    external num get billboardMode;

    external set billboardMode(num v);

    external bool get JS$_isBillboardBased;

    external set JS$_isBillboardBased(bool v);

    external bool get isBillboardBased;

    external set isBillboardBased(bool v);

    external Scene get JS$_scene;

    external set JS$_scene(Scene v);

    external ImageProcessingConfigurationDefines get JS$_imageProcessingConfigurationDefines;

    external set JS$_imageProcessingConfigurationDefines(ImageProcessingConfigurationDefines v);

    external ImageProcessingConfiguration get JS$_imageProcessingConfiguration;

    external set JS$_imageProcessingConfiguration(ImageProcessingConfiguration v);

    external ImageProcessingConfiguration get imageProcessingConfiguration;

    external set imageProcessingConfiguration(ImageProcessingConfiguration v);

    external void JS$_attachImageProcessingConfiguration(ImageProcessingConfiguration/*ImageProcessingConfiguration|Null*/ configuration);

    external void JS$_reset();

    external BaseParticleSystem JS$_removeGradientAndTexture(num gradient, List<IValueGradient>/*List<IValueGradient>|Null*/ gradients, RawTexture/*RawTexture|Null*/ texture);

    external factory BaseParticleSystem(String name);

    external PointParticleEmitter createPointEmitter(Vector3 direction1, Vector3 direction2);

    external HemisphericParticleEmitter createHemisphericEmitter([num radius, num radiusRange]);

    external SphereParticleEmitter createSphereEmitter([num radius, num radiusRange]);

    external SphereDirectedParticleEmitter createDirectedSphereEmitter([num radius, Vector3 direction1, Vector3 direction2]);

    external CylinderParticleEmitter createCylinderEmitter([num radius, num height, num radiusRange, num directionRandomizer]);

    external CylinderDirectedParticleEmitter createDirectedCylinderEmitter([num radius, num height, num radiusRange, Vector3 direction1, Vector3 direction2]);

    external ConeParticleEmitter createConeEmitter([num radius, num angle]);

    external BoxParticleEmitter createBoxEmitter(Vector3 direction1, Vector3 direction2, Vector3 minEmitBox, Vector3 maxEmitBox);
}

@JS("BABYLON.GPUParticleSystem")
class GPUParticleSystem extends BaseParticleSystem implements IDisposable, IParticleSystem, IAnimatable {
    // @Ignore
    GPUParticleSystem .fakeConstructor$() : super.fakeConstructor$();
    external num get layerMask;

    external set layerMask(num v);

    external get JS$_capacity;

    external set JS$_capacity(v);

    external get JS$_activeCount;

    external set JS$_activeCount(v);

    external get JS$_currentActiveCount;

    external set JS$_currentActiveCount(v);

    external get JS$_accumulatedCount;

    external set JS$_accumulatedCount(v);

    external get JS$_renderEffect;

    external set JS$_renderEffect(v);

    external get JS$_updateEffect;

    external set JS$_updateEffect(v);

    external get JS$_buffer0;

    external set JS$_buffer0(v);

    external get JS$_buffer1;

    external set JS$_buffer1(v);

    external get JS$_spriteBuffer;

    external set JS$_spriteBuffer(v);

    external get JS$_updateVAO;

    external set JS$_updateVAO(v);

    external get JS$_renderVAO;

    external set JS$_renderVAO(v);

    external get JS$_targetIndex;

    external set JS$_targetIndex(v);

    external get JS$_sourceBuffer;

    external set JS$_sourceBuffer(v);

    external get JS$_targetBuffer;

    external set JS$_targetBuffer(v);

    external get JS$_engine;

    external set JS$_engine(v);

    external get JS$_currentRenderId;

    external set JS$_currentRenderId(v);

    external get JS$_started;

    external set JS$_started(v);

    external get JS$_stopped;

    external set JS$_stopped(v);

    external get JS$_timeDelta;

    external set JS$_timeDelta(v);

    external get JS$_randomTexture;

    external set JS$_randomTexture(v);

    external get JS$_randomTexture2;

    external set JS$_randomTexture2(v);

    external get JS$_attributesStrideSize;

    external set JS$_attributesStrideSize(v);

    external get JS$_updateEffectOptions;

    external set JS$_updateEffectOptions(v);

    external get JS$_randomTextureSize;

    external set JS$_randomTextureSize(v);

    external get JS$_actualFrame;

    external set JS$_actualFrame(v);

    external get JS$_rawTextureWidth;

    external set JS$_rawTextureWidth(v);

    external static bool get IsSupported;

    external static set IsSupported(bool v);

    external Observable<GPUParticleSystem> get onDisposeObservable;

    external set onDisposeObservable(Observable<GPUParticleSystem> v);

    external num getCapacity();

    external bool get forceDepthWrite;

    external set forceDepthWrite(bool v);

    external num get activeParticleCount;

    external set activeParticleCount(num v);

    external get JS$_preWarmDone;

    external set JS$_preWarmDone(v);

    external bool isReady();

    external bool isStarted();

    external void start([num delay]);

    external void stop();

    external void reset();

    external String getClassName();

    external get JS$_colorGradientsTexture;

    external set JS$_colorGradientsTexture(v);

    external BaseParticleSystem JS$_removeGradientAndTexture(num gradient, List<IValueGradient>/*List<IValueGradient>|Null*/ gradients, RawTexture texture);

    external GPUParticleSystem addColorGradient(num gradient, Color4 color1, [Color4 color2]);

    external GPUParticleSystem removeColorGradient(num gradient);

    external get JS$_angularSpeedGradientsTexture;

    external set JS$_angularSpeedGradientsTexture(v);

    external get JS$_sizeGradientsTexture;

    external set JS$_sizeGradientsTexture(v);

    external get JS$_velocityGradientsTexture;

    external set JS$_velocityGradientsTexture(v);

    external get JS$_limitVelocityGradientsTexture;

    external set JS$_limitVelocityGradientsTexture(v);

    external get JS$_dragGradientsTexture;

    external set JS$_dragGradientsTexture(v);

    external get JS$_addFactorGradient;

    external set JS$_addFactorGradient(v);

    external GPUParticleSystem addSizeGradient(num gradient, num factor);

    external GPUParticleSystem removeSizeGradient(num gradient);

    external GPUParticleSystem addAngularSpeedGradient(num gradient, num factor);

    external GPUParticleSystem removeAngularSpeedGradient(num gradient);

    external GPUParticleSystem addVelocityGradient(num gradient, num factor);

    external GPUParticleSystem removeVelocityGradient(num gradient);

    external GPUParticleSystem addLimitVelocityGradient(num gradient, num factor);

    external GPUParticleSystem removeLimitVelocityGradient(num gradient);

    external GPUParticleSystem addDragGradient(num gradient, num factor);

    external GPUParticleSystem removeDragGradient(num gradient);

    external IParticleSystem addEmitRateGradient(num gradient, num factor, [num factor2]);

    external IParticleSystem removeEmitRateGradient(num gradient);

    external IParticleSystem addStartSizeGradient(num gradient, num factor, [num factor2]);

    external IParticleSystem removeStartSizeGradient(num gradient);

    external IParticleSystem addColorRemapGradient(num gradient, num min, num max);

    external IParticleSystem removeColorRemapGradient(num gradient);

    external IParticleSystem addAlphaRemapGradient(num gradient, num min, num max);

    external IParticleSystem removeAlphaRemapGradient(num gradient);

    external IParticleSystem addRampGradient(num gradient, Color3 color);

    external IParticleSystem removeRampGradient(num gradient);

    external List<Color3Gradient>/*List<Color3Gradient>|Null*/ getRampGradients();

    external bool get useRampGradients;

    external set useRampGradients(bool v);

    external IParticleSystem addLifeTimeGradient(num gradient, num factor, [num factor2]);

    external IParticleSystem removeLifeTimeGradient(num gradient);

    external factory GPUParticleSystem(String name, Partial<dynamic /*{
            capacity: number;
            randomTextureSize: number;
        }*/> options, Scene scene, [bool isAnimationSheetEnabled]);

    external void JS$_reset();

    external get JS$_createUpdateVAO;

    external set JS$_createUpdateVAO(v);

    external get JS$_createRenderVAO;

    external set JS$_createRenderVAO(v);

    external get JS$_initialize;

    external set JS$_initialize(v);

    external void JS$_recreateUpdateEffect();

    external void JS$_recreateRenderEffect();

    external void animate([bool preWarm]);

    external get JS$_createFactorGradientTexture;

    external set JS$_createFactorGradientTexture(v);

    external get JS$_createSizeGradientTexture;

    external set JS$_createSizeGradientTexture(v);

    external get JS$_createAngularSpeedGradientTexture;

    external set JS$_createAngularSpeedGradientTexture(v);

    external get JS$_createVelocityGradientTexture;

    external set JS$_createVelocityGradientTexture(v);

    external get JS$_createLimitVelocityGradientTexture;

    external set JS$_createLimitVelocityGradientTexture(v);

    external get JS$_createDragGradientTexture;

    external set JS$_createDragGradientTexture(v);

    external get JS$_createColorGradientTexture;

    external set JS$_createColorGradientTexture(v);

    external num render([bool preWarm]);

    external void rebuild();

    external get JS$_releaseBuffers;

    external set JS$_releaseBuffers(v);

    external get JS$_releaseVAOs;

    external set JS$_releaseVAOs(v);

    external void dispose([bool disposeTexture]);

    external GPUParticleSystem clone(String name, dynamic newEmitter);

    external dynamic serialize();

    external static GPUParticleSystem Parse(dynamic parsedParticleSystem, Scene scene, String rootUrl, [bool doNotStart]);
}

@anonymous
@JS()
abstract class IParticleSystem {
    external List<Animation> get animations;

    external set animations(List<Animation> v);

    external String get id;

    external set id(String v);

    external String get name;

    external set name(String v);

    external dynamic/*AbstractMesh|Vector3|Null*/ get emitter;

    external set emitter(dynamic/*AbstractMesh|Vector3|Null*/ v);

    external bool get isBillboardBased;

    external set isBillboardBased(bool v);

    external num get renderingGroupId;

    external set renderingGroupId(num v);

    external num get layerMask;

    external set layerMask(num v);

    external num get updateSpeed;

    external set updateSpeed(num v);

    external num get targetStopDuration;

    external set targetStopDuration(num v);

    external Texture/*Texture|Null*/ get particleTexture;

    external set particleTexture(Texture/*Texture|Null*/ v);

    external num get blendMode;

    external set blendMode(num v);

    external num get minLifeTime;

    external set minLifeTime(num v);

    external num get maxLifeTime;

    external set maxLifeTime(num v);

    external num get minSize;

    external set minSize(num v);

    external num get maxSize;

    external set maxSize(num v);

    external num get minScaleX;

    external set minScaleX(num v);

    external num get maxScaleX;

    external set maxScaleX(num v);

    external num get minScaleY;

    external set minScaleY(num v);

    external num get maxScaleY;

    external set maxScaleY(num v);

    external Color4 get color1;

    external set color1(Color4 v);

    external Color4 get color2;

    external set color2(Color4 v);

    external Color4 get colorDead;

    external set colorDead(Color4 v);

    external num get emitRate;

    external set emitRate(num v);

    external Vector3 get gravity;

    external set gravity(Vector3 v);

    external num get minEmitPower;

    external set minEmitPower(num v);

    external num get maxEmitPower;

    external set maxEmitPower(num v);

    external num get minAngularSpeed;

    external set minAngularSpeed(num v);

    external num get maxAngularSpeed;

    external set maxAngularSpeed(num v);

    external num get minInitialRotation;

    external set minInitialRotation(num v);

    external num get maxInitialRotation;

    external set maxInitialRotation(num v);

    external IParticleEmitterType/*IParticleEmitterType|Null*/ get particleEmitterType;

    external set particleEmitterType(IParticleEmitterType/*IParticleEmitterType|Null*/ v);

    external num get startDelay;

    external set startDelay(num v);

    external num get preWarmCycles;

    external set preWarmCycles(num v);

    external num get preWarmStepOffset;

    external set preWarmStepOffset(num v);

    external num get spriteCellChangeSpeed;

    external set spriteCellChangeSpeed(num v);

    external num get startSpriteCellID;

    external set startSpriteCellID(num v);

    external num get endSpriteCellID;

    external set endSpriteCellID(num v);

    external num get spriteCellWidth;

    external set spriteCellWidth(num v);

    external num get spriteCellHeight;

    external set spriteCellHeight(num v);

    external bool get spriteRandomStartCell;

    external set spriteRandomStartCell(bool v);

    external bool get isAnimationSheetEnabled;

    external set isAnimationSheetEnabled(bool v);

    external Vector2 get translationPivot;

    external set translationPivot(Vector2 v);

    external BaseTexture/*BaseTexture|Null*/ get noiseTexture;

    external set noiseTexture(BaseTexture/*BaseTexture|Null*/ v);

    external Vector3 get noiseStrength;

    external set noiseStrength(Vector3 v);

    external num get billboardMode;

    external set billboardMode(num v);

    external num get limitVelocityDamping;

    external set limitVelocityDamping(num v);

    external bool get beginAnimationOnStart;

    external set beginAnimationOnStart(bool v);

    external num get beginAnimationFrom;

    external set beginAnimationFrom(num v);

    external num get beginAnimationTo;

    external set beginAnimationTo(num v);

    external bool get beginAnimationLoop;

    external set beginAnimationLoop(bool v);

    external bool get disposeOnStop;

    external set disposeOnStop(bool v);

    external num getCapacity();

    external bool isStarted();

    external void animate();

    external num render();

    external void dispose([bool disposeTexture]);

    external IParticleSystem/*IParticleSystem|Null*/ clone(String name, dynamic newEmitter);

    external dynamic serialize();

    external void rebuild();

    external void start([num delay]);

    external void stop();

    external void reset();

    external bool isReady();

    external IParticleSystem addColorGradient(num gradient, Color4 color1, [Color4 color2]);

    external IParticleSystem removeColorGradient(num gradient);

    external IParticleSystem addSizeGradient(num gradient, num factor, [num factor2]);

    external IParticleSystem removeSizeGradient(num gradient);

    /*external List<ColorGradient>|Null getColorGradients();*/
    /*external List<ColorGradient>|Null getColorGradients();*/
    external T getColorGradients();

    external List<FactorGradient>/*List<FactorGradient>|Null*/ getSizeGradients();

    external List<FactorGradient>/*List<FactorGradient>|Null*/ getAngularSpeedGradients();

    external IParticleSystem addAngularSpeedGradient(num gradient, num factor, [num factor2]);

    external IParticleSystem removeAngularSpeedGradient(num gradient);

    external List<FactorGradient>/*List<FactorGradient>|Null*/ getVelocityGradients();

    external IParticleSystem addVelocityGradient(num gradient, num factor, [num factor2]);

    external IParticleSystem removeVelocityGradient(num gradient);

    external List<FactorGradient>/*List<FactorGradient>|Null*/ getLimitVelocityGradients();

    external IParticleSystem addLimitVelocityGradient(num gradient, num factor, [num factor2]);

    external IParticleSystem removeLimitVelocityGradient(num gradient);

    external IParticleSystem addDragGradient(num gradient, num factor, [num factor2]);

    external IParticleSystem removeDragGradient(num gradient);

    external List<FactorGradient>/*List<FactorGradient>|Null*/ getDragGradients();

    external IParticleSystem addEmitRateGradient(num gradient, num factor, [num factor2]);

    external IParticleSystem removeEmitRateGradient(num gradient);

    external List<FactorGradient>/*List<FactorGradient>|Null*/ getEmitRateGradients();

    external IParticleSystem addStartSizeGradient(num gradient, num factor, [num factor2]);

    external IParticleSystem removeStartSizeGradient(num gradient);

    external List<FactorGradient>/*List<FactorGradient>|Null*/ getStartSizeGradients();

    external IParticleSystem addLifeTimeGradient(num gradient, num factor, [num factor2]);

    external IParticleSystem removeLifeTimeGradient(num gradient);

    external List<FactorGradient>/*List<FactorGradient>|Null*/ getLifeTimeGradients();

    external IParticleSystem addRampGradient(num gradient, Color3 color);

    external List<Color3Gradient>/*List<Color3Gradient>|Null*/ getRampGradients();

    external bool get useRampGradients;

    external set useRampGradients(bool v);

    external IParticleSystem addColorRemapGradient(num gradient, num min, num max);

    external List<FactorGradient>/*List<FactorGradient>|Null*/ getColorRemapGradients();

    external IParticleSystem addAlphaRemapGradient(num gradient, num min, num max);

    external List<FactorGradient>/*List<FactorGradient>|Null*/ getAlphaRemapGradients();

    external PointParticleEmitter createPointEmitter(Vector3 direction1, Vector3 direction2);

    external HemisphericParticleEmitter createHemisphericEmitter(num radius, num radiusRange);

    external SphereParticleEmitter createSphereEmitter(num radius, num radiusRange);

    external SphereDirectedParticleEmitter createDirectedSphereEmitter(num radius, Vector3 direction1, Vector3 direction2);

    external CylinderParticleEmitter createCylinderEmitter(num radius, num height, num radiusRange, num directionRandomizer);

    external SphereDirectedParticleEmitter createDirectedCylinderEmitter(num radius, num height, num radiusRange, Vector3 direction1, Vector3 direction2);

    external ConeParticleEmitter createConeEmitter(num radius, num angle);

    external BoxParticleEmitter createBoxEmitter(Vector3 direction1, Vector3 direction2, Vector3 minEmitBox, Vector3 maxEmitBox);

    external Scene getScene();
}

@JS("BABYLON.Particle")
class Particle {
    // @Ignore
    Particle .fakeConstructor$();

    external ParticleSystem get particleSystem;

    external set particleSystem(ParticleSystem v);

    external static get JS$_Count;

    external static set JS$_Count(v);

    external num get id;

    external set id(num v);

    external Vector3 get position;

    external set position(Vector3 v);

    external Vector3 get direction;

    external set direction(Vector3 v);

    external Color4 get color;

    external set color(Color4 v);

    external Color4 get colorStep;

    external set colorStep(Color4 v);

    external num get lifeTime;

    external set lifeTime(num v);

    external num get age;

    external set age(num v);

    external num get size;

    external set size(num v);

    external Vector2 get scale;

    external set scale(Vector2 v);

    external num get angle;

    external set angle(num v);

    external num get angularSpeed;

    external set angularSpeed(num v);

    external num get cellIndex;

    external set cellIndex(num v);

    external Vector4 get remapData;

    external set remapData(Vector4 v);

    external num get JS$_randomCellOffset;

    external set JS$_randomCellOffset(num v);

    external Vector3/*Vector3|Null*/ get JS$_initialDirection;

    external set JS$_initialDirection(Vector3/*Vector3|Null*/ v);

    external List<SubEmitter>/*List<SubEmitter>|Null*/ get JS$_attachedSubEmitters;

    external set JS$_attachedSubEmitters(List<SubEmitter>/*List<SubEmitter>|Null*/ v);

    external num get JS$_initialStartSpriteCellID;

    external set JS$_initialStartSpriteCellID(num v);

    external num get JS$_initialEndSpriteCellID;

    external set JS$_initialEndSpriteCellID(num v);

    external ColorGradient/*ColorGradient|Null*/ get JS$_currentColorGradient;

    external set JS$_currentColorGradient(ColorGradient/*ColorGradient|Null*/ v);

    external Color4 get JS$_currentColor1;

    external set JS$_currentColor1(Color4 v);

    external Color4 get JS$_currentColor2;

    external set JS$_currentColor2(Color4 v);

    external FactorGradient/*FactorGradient|Null*/ get JS$_currentSizeGradient;

    external set JS$_currentSizeGradient(FactorGradient/*FactorGradient|Null*/ v);

    external num get JS$_currentSize1;

    external set JS$_currentSize1(num v);

    external num get JS$_currentSize2;

    external set JS$_currentSize2(num v);

    external FactorGradient/*FactorGradient|Null*/ get JS$_currentAngularSpeedGradient;

    external set JS$_currentAngularSpeedGradient(FactorGradient/*FactorGradient|Null*/ v);

    external num get JS$_currentAngularSpeed1;

    external set JS$_currentAngularSpeed1(num v);

    external num get JS$_currentAngularSpeed2;

    external set JS$_currentAngularSpeed2(num v);

    external FactorGradient/*FactorGradient|Null*/ get JS$_currentVelocityGradient;

    external set JS$_currentVelocityGradient(FactorGradient/*FactorGradient|Null*/ v);

    external num get JS$_currentVelocity1;

    external set JS$_currentVelocity1(num v);

    external num get JS$_currentVelocity2;

    external set JS$_currentVelocity2(num v);

    external FactorGradient/*FactorGradient|Null*/ get JS$_currentLimitVelocityGradient;

    external set JS$_currentLimitVelocityGradient(FactorGradient/*FactorGradient|Null*/ v);

    external num get JS$_currentLimitVelocity1;

    external set JS$_currentLimitVelocity1(num v);

    external num get JS$_currentLimitVelocity2;

    external set JS$_currentLimitVelocity2(num v);

    external FactorGradient/*FactorGradient|Null*/ get JS$_currentDragGradient;

    external set JS$_currentDragGradient(FactorGradient/*FactorGradient|Null*/ v);

    external num get JS$_currentDrag1;

    external set JS$_currentDrag1(num v);

    external num get JS$_currentDrag2;

    external set JS$_currentDrag2(num v);

    external Vector3 get JS$_randomNoiseCoordinates1;

    external set JS$_randomNoiseCoordinates1(Vector3 v);

    external Vector3 get JS$_randomNoiseCoordinates2;

    external set JS$_randomNoiseCoordinates2(Vector3 v);

    external factory Particle(ParticleSystem particleSystem);

    external get updateCellInfoFromSystem;

    external set updateCellInfoFromSystem(v);

    external void updateCellIndex();

    external void JS$_inheritParticleInfoToSubEmitter(SubEmitter subEmitter);

    external void JS$_inheritParticleInfoToSubEmitters();

    external void JS$_reset();

    external void copyTo(Particle other);
}

@JS("BABYLON.ParticleHelper")
class ParticleHelper {
    // @Ignore
    ParticleHelper .fakeConstructor$();

    external static String get BaseAssetsUrl;

    external static set BaseAssetsUrl(String v);

    external static IParticleSystem CreateDefault(dynamic/*AbstractMesh|Vector3|Null*/ emitter, [num capacity, Scene scene, bool useGPU]);

    external static Promise<ParticleSystemSet> CreateAsync(String type, Scene/*Scene|Null*/ scene, [bool gpu]);

    external static ParticleSystemSet ExportSet(List<IParticleSystem> systems);
}

@JS("BABYLON.ParticleSystem")
class ParticleSystem extends BaseParticleSystem implements IDisposable, IAnimatable, IParticleSystem {
    // @Ignore
    ParticleSystem .fakeConstructor$() : super.fakeConstructor$();
    external static num get BILLBOARDMODE_Y;

    external static set BILLBOARDMODE_Y(num v);

    external static num get BILLBOARDMODE_ALL;

    external static set BILLBOARDMODE_ALL(num v);

    external static num get BILLBOARDMODE_STRETCHED;

    external static set BILLBOARDMODE_STRETCHED(num v);

    external VoidFunc1<List<Particle>> get updateFunction;

    external set updateFunction(VoidFunc1<List<Particle>> v);

    external get JS$_emitterWorldMatrix;

    external set JS$_emitterWorldMatrix(v);

    external VoidFunc3<Matrix, Vector3, Particle> get startDirectionFunction;

    external set startDirectionFunction(VoidFunc3<Matrix, Vector3, Particle> v);

    external VoidFunc3<Matrix, Vector3, Particle> get startPositionFunction;

    external set startPositionFunction(VoidFunc3<Matrix, Vector3, Particle> v);

    external Vector3 get JS$_inheritedVelocityOffset;

    external set JS$_inheritedVelocityOffset(Vector3 v);

    external Observable<ParticleSystem> get onDisposeObservable;

    external set onDisposeObservable(Observable<ParticleSystem> v);

    external get JS$_onDisposeObserver;

    external set JS$_onDisposeObserver(v);

    external VoidFunc0 get onDispose;

    external set onDispose(VoidFunc0 v);

    external get JS$_particles;

    external set JS$_particles(v);

    external get JS$_epsilon;

    external set JS$_epsilon(v);

    external get JS$_capacity;

    external set JS$_capacity(v);

    external get JS$_stockParticles;

    external set JS$_stockParticles(v);

    external get JS$_newPartsExcess;

    external set JS$_newPartsExcess(v);

    external get JS$_vertexData;

    external set JS$_vertexData(v);

    external get JS$_vertexBuffer;

    external set JS$_vertexBuffer(v);

    external get JS$_vertexBuffers;

    external set JS$_vertexBuffers(v);

    external get JS$_spriteBuffer;

    external set JS$_spriteBuffer(v);

    external get JS$_indexBuffer;

    external set JS$_indexBuffer(v);

    external get JS$_effect;

    external set JS$_effect(v);

    external get JS$_customEffect;

    external set JS$_customEffect(v);

    external get JS$_cachedDefines;

    external set JS$_cachedDefines(v);

    external get JS$_scaledColorStep;

    external set JS$_scaledColorStep(v);

    external get JS$_colorDiff;

    external set JS$_colorDiff(v);

    external get JS$_scaledDirection;

    external set JS$_scaledDirection(v);

    external get JS$_scaledGravity;

    external set JS$_scaledGravity(v);

    external get JS$_currentRenderId;

    external set JS$_currentRenderId(v);

    external get JS$_alive;

    external set JS$_alive(v);

    external get JS$_useInstancing;

    external set JS$_useInstancing(v);

    external get JS$_started;

    external set JS$_started(v);

    external get JS$_stopped;

    external set JS$_stopped(v);

    external get JS$_actualFrame;

    external set JS$_actualFrame(v);

    external get JS$_scaledUpdateSpeed;

    external set JS$_scaledUpdateSpeed(v);

    external get JS$_vertexBufferSize;

    external set JS$_vertexBufferSize(v);

    external FactorGradient/*FactorGradient|Null*/ get JS$_currentEmitRateGradient;

    external set JS$_currentEmitRateGradient(FactorGradient/*FactorGradient|Null*/ v);

    external num get JS$_currentEmitRate1;

    external set JS$_currentEmitRate1(num v);

    external num get JS$_currentEmitRate2;

    external set JS$_currentEmitRate2(num v);

    external FactorGradient/*FactorGradient|Null*/ get JS$_currentStartSizeGradient;

    external set JS$_currentStartSizeGradient(FactorGradient/*FactorGradient|Null*/ v);

    external num get JS$_currentStartSize1;

    external set JS$_currentStartSize1(num v);

    external num get JS$_currentStartSize2;

    external set JS$_currentStartSize2(num v);

    external get JS$_rawTextureWidth;

    external set JS$_rawTextureWidth(v);

    external get JS$_rampGradientsTexture;

    external set JS$_rampGradientsTexture(v);

    external get JS$_useRampGradients;

    external set JS$_useRampGradients(v);

    external bool get useRampGradients;

    external set useRampGradients(bool v);

    external List<dynamic /*ParticleSystem|SubEmitter|List<SubEmitter>*/> get subEmitters;

    external set subEmitters(List<dynamic /*ParticleSystem|SubEmitter|List<SubEmitter>*/> v);

    external get JS$_subEmitters;

    external set JS$_subEmitters(v);

    external bool get JS$_disposeEmitterOnDispose;

    external set JS$_disposeEmitterOnDispose(bool v);

    external List<ParticleSystem> get activeSubSystems;

    external set activeSubSystems(List<ParticleSystem> v);

    external get JS$_rootParticleSystem;

    external set JS$_rootParticleSystem(v);

    external List<Particle> get particles;

    external set particles(List<Particle> v);

    external String getClassName();

    external factory ParticleSystem(String name, num capacity, Scene scene, [Effect/*Effect|Null*/ customEffect, bool isAnimationSheetEnabled, num epsilon]);

    external get JS$_addFactorGradient;

    external set JS$_addFactorGradient(v);

    external get JS$_removeFactorGradient;

    external set JS$_removeFactorGradient(v);

    external IParticleSystem addLifeTimeGradient(num gradient, num factor, [num factor2]);

    external IParticleSystem removeLifeTimeGradient(num gradient);

    external IParticleSystem addSizeGradient(num gradient, num factor, [num factor2]);

    external IParticleSystem removeSizeGradient(num gradient);

    external IParticleSystem addColorRemapGradient(num gradient, num min, num max);

    external IParticleSystem removeColorRemapGradient(num gradient);

    external IParticleSystem addAlphaRemapGradient(num gradient, num min, num max);

    external IParticleSystem removeAlphaRemapGradient(num gradient);

    external IParticleSystem addAngularSpeedGradient(num gradient, num factor, [num factor2]);

    external IParticleSystem removeAngularSpeedGradient(num gradient);

    external IParticleSystem addVelocityGradient(num gradient, num factor, [num factor2]);

    external IParticleSystem removeVelocityGradient(num gradient);

    external IParticleSystem addLimitVelocityGradient(num gradient, num factor, [num factor2]);

    external IParticleSystem removeLimitVelocityGradient(num gradient);

    external IParticleSystem addDragGradient(num gradient, num factor, [num factor2]);

    external IParticleSystem removeDragGradient(num gradient);

    external IParticleSystem addEmitRateGradient(num gradient, num factor, [num factor2]);

    external IParticleSystem removeEmitRateGradient(num gradient);

    external IParticleSystem addStartSizeGradient(num gradient, num factor, [num factor2]);

    external IParticleSystem removeStartSizeGradient(num gradient);

    external get JS$_createRampGradientTexture;

    external set JS$_createRampGradientTexture(v);

    external List<Color3Gradient>/*List<Color3Gradient>|Null*/ getRampGradients();

    external ParticleSystem addRampGradient(num gradient, Color3 color);

    external ParticleSystem removeRampGradient(num gradient);

    external IParticleSystem addColorGradient(num gradient, Color4 color1, [Color4 color2]);

    external IParticleSystem removeColorGradient(num gradient);

    external get JS$_fetchR;

    external set JS$_fetchR(v);

    external void JS$_reset();

    external get JS$_resetEffect;

    external set JS$_resetEffect(v);

    external get JS$_createVertexBuffers;

    external set JS$_createVertexBuffers(v);

    external get JS$_createIndexBuffer;

    external set JS$_createIndexBuffer(v);

    external num getCapacity();

    external bool isAlive();

    external bool isStarted();

    external get JS$_prepareSubEmitterInternalArray;

    external set JS$_prepareSubEmitterInternalArray(v);

    external void start([num delay]);

    external void stop([bool stopSubEmitters]);

    external void reset();

    external void JS$_appendParticleVertex(num index, Particle particle, num offsetX, num offsetY);

    external VoidFunc1<Particle> get recycleParticle;

    external set recycleParticle(VoidFunc1<Particle> v);

    external get JS$_stopSubEmitters;

    external set JS$_stopSubEmitters(v);

    external get JS$_createParticle;

    external set JS$_createParticle(v);

    external get JS$_removeFromRoot;

    external set JS$_removeFromRoot(v);

    external get JS$_emitFromParticle;

    external set JS$_emitFromParticle(v);

    external get JS$_update;

    external set JS$_update(v);

    external static List<String> JS$_GetAttributeNamesOrOptions([bool isAnimationSheetEnabled, bool isBillboardBased, bool useRampGradients]);

    external static List<String> JS$_GetEffectCreationOptions([bool isAnimationSheetEnabled]);

    external get JS$_getEffect;

    external set JS$_getEffect(v);

    external void animate([bool preWarmOnly]);

    external get JS$_appendParticleVertices;

    external set JS$_appendParticleVertices(v);

    external void rebuild();

    external bool isReady();

    external get JS$_render;

    external set JS$_render(v);

    external num render();

    external void dispose([bool disposeTexture]);

    external ParticleSystem clone(String name, dynamic newEmitter);

    external dynamic serialize();

    external static void JS$_Serialize(dynamic serializationObject, IParticleSystem particleSystem);

    external static void JS$_Parse(dynamic parsedParticleSystem, IParticleSystem particleSystem, Scene scene, String rootUrl);

    external static ParticleSystem Parse(dynamic parsedParticleSystem, Scene scene, String rootUrl, [bool doNotStart]);
}

@JS("BABYLON.ParticleSystemSet")
class ParticleSystemSet implements IDisposable {
    // @Ignore
    ParticleSystemSet .fakeConstructor$();

    external get JS$_emitterCreationOptions;

    external set JS$_emitterCreationOptions(v);

    external get JS$_emitterNode;

    external set JS$_emitterNode(v);

    external List<IParticleSystem> get systems;

    external set systems(List<IParticleSystem> v);

    external TransformNode/*TransformNode|Null*/ get emitterNode;

    external set emitterNode(TransformNode/*TransformNode|Null*/ v);

    external void setEmitterAsSphere(dynamic/*{
            diameter: number;
            segments: number;
            color: Color3;
        }*/
    options, num renderingGroupId, Scene scene);

    external void start([AbstractMesh emitter]);

    external void dispose();

    external dynamic serialize();

    external static ParticleSystemSet Parse(dynamic data, Scene scene, [bool gpu]);
}

@JS("BABYLON.SolidParticle")
class SolidParticle {
    // @Ignore
    SolidParticle .fakeConstructor$();

    external num get idx;

    external set idx(num v);

    external Color4/*Color4|Null*/ get color;

    external set color(Color4/*Color4|Null*/ v);

    external Vector3 get position;

    external set position(Vector3 v);

    external Vector3 get rotation;

    external set rotation(Vector3 v);

    external Quaternion/*Quaternion|Null*/ get rotationQuaternion;

    external set rotationQuaternion(Quaternion/*Quaternion|Null*/ v);

    external Vector3 get scaling;

    external set scaling(Vector3 v);

    external Vector4 get uvs;

    external set uvs(Vector4 v);

    external Vector3 get velocity;

    external set velocity(Vector3 v);

    external Vector3 get pivot;

    external set pivot(Vector3 v);

    external bool get translateFromPivot;

    external set translateFromPivot(bool v);

    external bool get alive;

    external set alive(bool v);

    external bool get isVisible;

    external set isVisible(bool v);

    external num get JS$_pos;

    external set JS$_pos(num v);

    external num get JS$_ind;

    external set JS$_ind(num v);

    external ModelShape get JS$_model;

    external set JS$_model(ModelShape v);

    external num get shapeId;

    external set shapeId(num v);

    external num get idxInShape;

    external set idxInShape(num v);

    external BoundingInfo get JS$_modelBoundingInfo;

    external set JS$_modelBoundingInfo(BoundingInfo v);

    external BoundingInfo get JS$_boundingInfo;

    external set JS$_boundingInfo(BoundingInfo v);

    external SolidParticleSystem get JS$_sps;

    external set JS$_sps(SolidParticleSystem v);

    external bool get JS$_stillInvisible;

    external set JS$_stillInvisible(bool v);

    external List<num> get JS$_rotationMatrix;

    external set JS$_rotationMatrix(List<num> v);

    external num/*num|Null*/ get parentId;

    external set parentId(num/*num|Null*/ v);

    external Vector3 get JS$_globalPosition;

    external set JS$_globalPosition(Vector3 v);

    external factory SolidParticle(num particleIndex, num positionIndex, num indiceIndex, ModelShape/*ModelShape|Null*/ model, num shapeId, num idxInShape, SolidParticleSystem sps, [BoundingInfo/*BoundingInfo|Null*/ modelBoundingInfo]);

    external Vector3 get scale;

    external set scale(Vector3 v);

    external Quaternion/*Quaternion|Null*/ get quaternion;

    external set quaternion(Quaternion/*Quaternion|Null*/ v);

    external bool intersectsMesh(dynamic/*Mesh|SolidParticle*/ target);
}

@JS("BABYLON.ModelShape")
class ModelShape {
    // @Ignore
    ModelShape .fakeConstructor$();

    external num get shapeID;

    external set shapeID(num v);

    external List<Vector3> get JS$_shape;

    external set JS$_shape(List<Vector3> v);

    external List<num> get JS$_shapeUV;

    external set JS$_shapeUV(List<num> v);

    external num get JS$_indicesLength;

    external set JS$_indicesLength(num v);

    external VoidFunc3<SolidParticle, num, num>/*VoidFunc3<SolidParticle, num, num>|Null*/ get JS$_positionFunction;

    external set JS$_positionFunction(VoidFunc3<SolidParticle, num, num>/*VoidFunc3<SolidParticle, num, num>|Null*/ v);

    external VoidFunc3<SolidParticle, Vector3, num>/*VoidFunc3<SolidParticle, Vector3, num>|Null*/ get JS$_vertexFunction;

    external set JS$_vertexFunction(VoidFunc3<SolidParticle, Vector3, num>/*VoidFunc3<SolidParticle, Vector3, num>|Null*/ v);

    external factory ModelShape(num id, List<Vector3> shape, num indicesLength, List<num> shapeUV, VoidFunc3<SolidParticle, num, num>/*VoidFunc3<SolidParticle, num, num>|Null*/ posFunction, VoidFunc3<SolidParticle, Vector3, num>/*VoidFunc3<SolidParticle, Vector3, num>|Null*/ vtxFunction);
}

@JS("BABYLON.DepthSortedParticle")
class DepthSortedParticle {
    // @Ignore
    DepthSortedParticle .fakeConstructor$();

    external num get ind;

    external set ind(num v);

    external num get indicesLength;

    external set indicesLength(num v);

    external num get sqDistance;

    external set sqDistance(num v);
}

@JS("BABYLON.SolidParticleSystem")
class SolidParticleSystem implements IDisposable {
    // @Ignore
    SolidParticleSystem .fakeConstructor$();

    external List<SolidParticle> get particles;

    external set particles(List<SolidParticle> v);

    external num get nbParticles;

    external set nbParticles(num v);

    external bool get billboard;

    external set billboard(bool v);

    external bool get recomputeNormals;

    external set recomputeNormals(bool v);

    external num get counter;

    external set counter(num v);

    external String get name;

    external set name(String v);

    external Mesh get mesh;

    external set mesh(Mesh v);

    external dynamic get vars;

    external set vars(dynamic v);

    external List<dynamic /*{
            idx: number;
            faceId: number;
        }*/> get pickedParticles;

    external set pickedParticles(List<dynamic /*{
            idx: number;
            faceId: number;
        }*/> v);

    external List<DepthSortedParticle> get depthSortedParticles;

    external set depthSortedParticles(List<DepthSortedParticle> v);

    external bool get JS$_bSphereOnly;

    external set JS$_bSphereOnly(bool v);

    external num get JS$_bSphereRadiusFactor;

    external set JS$_bSphereRadiusFactor(num v);

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_positions;

    external set JS$_positions(v);

    external get JS$_indices;

    external set JS$_indices(v);

    external get JS$_normals;

    external set JS$_normals(v);

    external get JS$_colors;

    external set JS$_colors(v);

    external get JS$_uvs;

    external set JS$_uvs(v);

    external get JS$_indices32;

    external set JS$_indices32(v);

    external get JS$_positions32;

    external set JS$_positions32(v);

    external get JS$_normals32;

    external set JS$_normals32(v);

    external get JS$_fixedNormal32;

    external set JS$_fixedNormal32(v);

    external get JS$_colors32;

    external set JS$_colors32(v);

    external get JS$_uvs32;

    external set JS$_uvs32(v);

    external get JS$_index;

    external set JS$_index(v);

    external get JS$_updatable;

    external set JS$_updatable(v);

    external get JS$_pickable;

    external set JS$_pickable(v);

    external get JS$_isVisibilityBoxLocked;

    external set JS$_isVisibilityBoxLocked(v);

    external get JS$_alwaysVisible;

    external set JS$_alwaysVisible(v);

    external get JS$_depthSort;

    external set JS$_depthSort(v);

    external get JS$_shapeCounter;

    external set JS$_shapeCounter(v);

    external get JS$_copy;

    external set JS$_copy(v);

    external get JS$_shape;

    external set JS$_shape(v);

    external get JS$_shapeUV;

    external set JS$_shapeUV(v);

    external get JS$_color;

    external set JS$_color(v);

    external get JS$_computeParticleColor;

    external set JS$_computeParticleColor(v);

    external get JS$_computeParticleTexture;

    external set JS$_computeParticleTexture(v);

    external get JS$_computeParticleRotation;

    external set JS$_computeParticleRotation(v);

    external get JS$_computeParticleVertex;

    external set JS$_computeParticleVertex(v);

    external get JS$_computeBoundingBox;

    external set JS$_computeBoundingBox(v);

    external get JS$_depthSortParticles;

    external set JS$_depthSortParticles(v);

    external get JS$_cam_axisZ;

    external set JS$_cam_axisZ(v);

    external get JS$_cam_axisY;

    external set JS$_cam_axisY(v);

    external get JS$_cam_axisX;

    external set JS$_cam_axisX(v);

    external get JS$_axisZ;

    external set JS$_axisZ(v);

    external get JS$_camera;

    external set JS$_camera(v);

    external get JS$_particle;

    external set JS$_particle(v);

    external get JS$_camDir;

    external set JS$_camDir(v);

    external get JS$_camInvertedPosition;

    external set JS$_camInvertedPosition(v);

    external get JS$_rotMatrix;

    external set JS$_rotMatrix(v);

    external get JS$_invertMatrix;

    external set JS$_invertMatrix(v);

    external get JS$_rotated;

    external set JS$_rotated(v);

    external get JS$_quaternion;

    external set JS$_quaternion(v);

    external get JS$_vertex;

    external set JS$_vertex(v);

    external get JS$_normal;

    external set JS$_normal(v);

    external get JS$_yaw;

    external set JS$_yaw(v);

    external get JS$_pitch;

    external set JS$_pitch(v);

    external get JS$_roll;

    external set JS$_roll(v);

    external get JS$_halfroll;

    external set JS$_halfroll(v);

    external get JS$_halfpitch;

    external set JS$_halfpitch(v);

    external get JS$_halfyaw;

    external set JS$_halfyaw(v);

    external get JS$_sinRoll;

    external set JS$_sinRoll(v);

    external get JS$_cosRoll;

    external set JS$_cosRoll(v);

    external get JS$_sinPitch;

    external set JS$_sinPitch(v);

    external get JS$_cosPitch;

    external set JS$_cosPitch(v);

    external get JS$_sinYaw;

    external set JS$_sinYaw(v);

    external get JS$_cosYaw;

    external set JS$_cosYaw(v);

    external get JS$_mustUnrotateFixedNormals;

    external set JS$_mustUnrotateFixedNormals(v);

    external get JS$_minimum;

    external set JS$_minimum(v);

    external get JS$_maximum;

    external set JS$_maximum(v);

    external get JS$_minBbox;

    external set JS$_minBbox(v);

    external get JS$_maxBbox;

    external set JS$_maxBbox(v);

    external get JS$_particlesIntersect;

    external set JS$_particlesIntersect(v);

    external get JS$_depthSortFunction;

    external set JS$_depthSortFunction(v);

    external get JS$_needs32Bits;

    external set JS$_needs32Bits(v);

    external get JS$_pivotBackTranslation;

    external set JS$_pivotBackTranslation(v);

    external get JS$_scaledPivot;

    external set JS$_scaledPivot(v);

    external get JS$_particleHasParent;

    external set JS$_particleHasParent(v);

    external get JS$_parent;

    external set JS$_parent(v);

    external factory SolidParticleSystem(String name, Scene scene, [dynamic/*{
            updatable?: boolean;
            isPickable?: boolean;
            enableDepthSort?: boolean;
            particleIntersection?: boolean;
            boundingSphereOnly?: boolean;
            bSphereRadiusFactor?: number;
        }*/
    options]);

    external Mesh buildMesh();

    external SolidParticleSystem digest(Mesh mesh, [dynamic/*{
            facetNb?: number;
            number?: number;
            delta?: number;
        }*/
    options]);

    external get JS$_unrotateFixedNormals;

    external set JS$_unrotateFixedNormals(v);

    external get JS$_resetCopy;

    external set JS$_resetCopy(v);

    external get JS$_meshBuilder;

    external set JS$_meshBuilder(v);

    external get JS$_posToShape;

    external set JS$_posToShape(v);

    external get JS$_uvsToShapeUV;

    external set JS$_uvsToShapeUV(v);

    external get JS$_addParticle;

    external set JS$_addParticle(v);

    external num addShape(Mesh mesh, num nb, [dynamic/*{
            positionFunction?: any;
            vertexFunction?: any;
        }*/
    options]);

    external get JS$_rebuildParticle;

    external set JS$_rebuildParticle(v);

    external SolidParticleSystem rebuildMesh();

    external SolidParticleSystem setParticles([num start, num end, bool update]);

    external get JS$_quaternionRotationYPR;

    external set JS$_quaternionRotationYPR(v);

    external get JS$_quaternionToRotationMatrix;

    external set JS$_quaternionToRotationMatrix(v);

    external void dispose();

    external SolidParticleSystem refreshVisibleSize();

    external void setVisibilityBox(num size);

    external bool get isAlwaysVisible;

    external set isAlwaysVisible(bool v);

    external bool get isVisibilityBoxLocked;

    external set isVisibilityBoxLocked(bool v);

    external bool get computeParticleRotation;

    external set computeParticleRotation(bool v);

    external bool get computeParticleColor;

    external set computeParticleColor(bool v);

    external bool get computeParticleTexture;

    external set computeParticleTexture(bool v);

    external bool get computeParticleVertex;

    external set computeParticleVertex(bool v);

    external bool get computeBoundingBox;

    external set computeBoundingBox(bool v);

    external bool get depthSortParticles;

    external set depthSortParticles(bool v);

    external void initParticles();

    external SolidParticle recycleParticle(SolidParticle particle);

    external SolidParticle updateParticle(SolidParticle particle);

    external Vector3 updateParticleVertex(SolidParticle particle, Vector3 vertex, num pt);

    external void beforeUpdateParticles([num start, num stop, bool update]);

    external void afterUpdateParticles([num start, num stop, bool update]);
}

@JS("BABYLON.SubEmitterType")
class SubEmitterType {
    external static num get ATTACHED;

    external static num get END;
}

@JS("BABYLON.SubEmitter")
class SubEmitter {
    // @Ignore
    SubEmitter .fakeConstructor$();

    external ParticleSystem get particleSystem;

    external set particleSystem(ParticleSystem v);

    external num/*enum SubEmitterType*/ get type;

    external set type(num/*enum SubEmitterType*/ v);

    external bool get inheritDirection;

    external set inheritDirection(bool v);

    external num get inheritedVelocityAmount;

    external set inheritedVelocityAmount(num v);

    external factory SubEmitter(ParticleSystem particleSystem);

    external SubEmitter clone();

    external dynamic serialize();

    external static SubEmitter Parse(dynamic serializationObject, Scene scene, String rootUrl);

    external void dispose();
}

@anonymous
@JS()
abstract class PhysicsImpostorJoint {
    external PhysicsImpostor get mainImpostor;

    external set mainImpostor(PhysicsImpostor v);

    external PhysicsImpostor get connectedImpostor;

    external set connectedImpostor(PhysicsImpostor v);

    external PhysicsJoint get joint;

    external set joint(PhysicsJoint v);

    external factory PhysicsImpostorJoint({ PhysicsImpostor mainImpostor, PhysicsImpostor connectedImpostor, PhysicsJoint joint});
}

@anonymous
@JS()
abstract class IPhysicsEnginePlugin {
    external dynamic get world;

    external set world(dynamic v);

    external String get name;

    external set name(String v);

    external void setGravity(Vector3 gravity);

    external void setTimeStep(num timeStep);

    external num getTimeStep();

    external void executeStep(num delta, List<PhysicsImpostor> impostors);

    external void applyImpulse(PhysicsImpostor impostor, Vector3 force, Vector3 contactPoint);

    external void applyForce(PhysicsImpostor impostor, Vector3 force, Vector3 contactPoint);

    external void generatePhysicsBody(PhysicsImpostor impostor);

    external void removePhysicsBody(PhysicsImpostor impostor);

    external void generateJoint(PhysicsImpostorJoint joint);

    external void removeJoint(PhysicsImpostorJoint joint);

    external bool isSupported();

    external void setTransformationFromPhysicsBody(PhysicsImpostor impostor);

    external void setPhysicsBodyTransformation(PhysicsImpostor impostor, Vector3 newPosition, Quaternion newRotation);

    external void setLinearVelocity(PhysicsImpostor impostor, Vector3/*Vector3|Null*/ velocity);

    external void setAngularVelocity(PhysicsImpostor impostor, Vector3/*Vector3|Null*/ velocity);

    external Vector3/*Vector3|Null*/ getLinearVelocity(PhysicsImpostor impostor);

    external Vector3/*Vector3|Null*/ getAngularVelocity(PhysicsImpostor impostor);

    external void setBodyMass(PhysicsImpostor impostor, num mass);

    external num getBodyMass(PhysicsImpostor impostor);

    external num getBodyFriction(PhysicsImpostor impostor);

    external void setBodyFriction(PhysicsImpostor impostor, num friction);

    external num getBodyRestitution(PhysicsImpostor impostor);

    external void setBodyRestitution(PhysicsImpostor impostor, num restitution);

    external void sleepBody(PhysicsImpostor impostor);

    external void wakeUpBody(PhysicsImpostor impostor);

    external void updateDistanceJoint(PhysicsJoint joint, num maxDistance, [num minDistance]);

    external void setMotor(IMotorEnabledJoint joint, num speed, [num maxForce, num motorIndex]);

    external void setLimit(IMotorEnabledJoint joint, num upperLimit, [num lowerLimit, num motorIndex]);

    external num getRadius(PhysicsImpostor impostor);

    external void getBoxSizeToRef(PhysicsImpostor impostor, Vector3 result);

    external void syncMeshWithImpostor(AbstractMesh mesh, PhysicsImpostor impostor);

    external void dispose();
}

@anonymous
@JS()
abstract class IPhysicsEngine {
    external Vector3 get gravity;

    external set gravity(Vector3 v);

    external void setGravity(Vector3 gravity);

    external void setTimeStep(num newTimeStep);

    external num getTimeStep();

    external void dispose();

    external String getPhysicsPluginName();

    external void addImpostor(PhysicsImpostor impostor);

    external void removeImpostor(PhysicsImpostor impostor);

    external void addJoint(PhysicsImpostor mainImpostor, PhysicsImpostor connectedImpostor, PhysicsJoint joint);

    external void removeJoint(PhysicsImpostor mainImpostor, PhysicsImpostor connectedImpostor, PhysicsJoint joint);

    external IPhysicsEnginePlugin getPhysicsPlugin();

    external List<PhysicsImpostor> getImpostors();

    external PhysicsImpostor/*PhysicsImpostor|Null*/ getImpostorForPhysicsObject(IPhysicsEnabledObject object);

    external PhysicsImpostor/*PhysicsImpostor|Null*/ getImpostorWithPhysicsBody(dynamic body);

    external void JS$_step(num delta);
}

@JS("BABYLON.PhysicsEngine")
class PhysicsEngine implements IPhysicsEngine {
    // @Ignore
    PhysicsEngine .fakeConstructor$();

    external get JS$_physicsPlugin;

    external set JS$_physicsPlugin(v);

    external static num get Epsilon;

    external static set Epsilon(num v);

    external get JS$_impostors;

    external set JS$_impostors(v);

    external get JS$_joints;

    external set JS$_joints(v);

    external Vector3 get gravity;

    external set gravity(Vector3 v);

    external factory PhysicsEngine(Vector3/*Vector3|Null*/ gravity, [IPhysicsEnginePlugin JS$_physicsPlugin]);

    external void setGravity(Vector3 gravity);

    external void setTimeStep([num newTimeStep]);

    external num getTimeStep();

    external void dispose();

    external String getPhysicsPluginName();

    external void addImpostor(PhysicsImpostor impostor);

    external void removeImpostor(PhysicsImpostor impostor);

    external void addJoint(PhysicsImpostor mainImpostor, PhysicsImpostor connectedImpostor, PhysicsJoint joint);

    external void removeJoint(PhysicsImpostor mainImpostor, PhysicsImpostor connectedImpostor, PhysicsJoint joint);

    external void JS$_step(num delta);

    external IPhysicsEnginePlugin getPhysicsPlugin();

    external List<PhysicsImpostor> getImpostors();

    external PhysicsImpostor/*PhysicsImpostor|Null*/ getImpostorForPhysicsObject(IPhysicsEnabledObject object);

    external PhysicsImpostor/*PhysicsImpostor|Null*/ getImpostorWithPhysicsBody(dynamic body);
}

@JS("BABYLON.PhysicsEngineSceneComponent")
class PhysicsEngineSceneComponent implements ISceneComponent {
    // @Ignore
    PhysicsEngineSceneComponent .fakeConstructor$();

    external String get name;

    external set name(String v);

    external Scene get scene;

    external set scene(Scene v);

    external factory PhysicsEngineSceneComponent(Scene scene);

    external void register();

    external void rebuild();

    external void dispose();
}

@JS("BABYLON.PhysicsHelper")
class PhysicsHelper {
    // @Ignore
    PhysicsHelper .fakeConstructor$();

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_physicsEngine;

    external set JS$_physicsEngine(v);

    external factory PhysicsHelper(Scene scene);

    external PhysicsRadialExplosionEvent/*PhysicsRadialExplosionEvent|Null*/ applyRadialExplosionImpulse(Vector3 origin, num radius, num strength, [num/*enum PhysicsRadialImpulseFalloff*/ falloff]);

    external PhysicsRadialExplosionEvent/*PhysicsRadialExplosionEvent|Null*/ applyRadialExplosionForce(Vector3 origin, num radius, num strength, [num/*enum PhysicsRadialImpulseFalloff*/ falloff]);

    external PhysicsGravitationalFieldEvent/*PhysicsGravitationalFieldEvent|Null*/ gravitationalField(Vector3 origin, num radius, num strength, [num/*enum PhysicsRadialImpulseFalloff*/ falloff]);

    external PhysicsUpdraftEvent/*PhysicsUpdraftEvent|Null*/ updraft(Vector3 origin, num radius, num strength, num height, [num/*enum PhysicsUpdraftMode*/ updraftMode]);

    external PhysicsVortexEvent/*PhysicsVortexEvent|Null*/ vortex(Vector3 origin, num radius, num strength, num height);
}

@JS("BABYLON.PhysicsRadialExplosionEvent")
class PhysicsRadialExplosionEvent {
    // @Ignore
    PhysicsRadialExplosionEvent .fakeConstructor$();

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_sphere;

    external set JS$_sphere(v);

    external get JS$_sphereOptions;

    external set JS$_sphereOptions(v);

    external get JS$_rays;

    external set JS$_rays(v);

    external get JS$_dataFetched;

    external set JS$_dataFetched(v);

    external factory PhysicsRadialExplosionEvent(Scene scene);

    external PhysicsRadialExplosionEventData getData();

    external PhysicsForceAndContactPoint/*PhysicsForceAndContactPoint|Null*/ getImpostorForceAndContactPoint(PhysicsImpostor impostor, Vector3 origin, num radius, num strength, num/*enum PhysicsRadialImpulseFalloff*/ falloff);

    external void dispose([bool force]);

    external get JS$_prepareSphere;

    external set JS$_prepareSphere(v);

    external get JS$_intersectsWithSphere;

    external set JS$_intersectsWithSphere(v);
}

@JS("BABYLON.PhysicsGravitationalFieldEvent")
class PhysicsGravitationalFieldEvent {
    // @Ignore
    PhysicsGravitationalFieldEvent .fakeConstructor$();

    external get JS$_physicsHelper;

    external set JS$_physicsHelper(v);

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_origin;

    external set JS$_origin(v);

    external get JS$_radius;

    external set JS$_radius(v);

    external get JS$_strength;

    external set JS$_strength(v);

    external get JS$_falloff;

    external set JS$_falloff(v);

    external get JS$_tickCallback;

    external set JS$_tickCallback(v);

    external get JS$_sphere;

    external set JS$_sphere(v);

    external get JS$_dataFetched;

    external set JS$_dataFetched(v);

    external factory PhysicsGravitationalFieldEvent(PhysicsHelper physicsHelper, Scene scene, Vector3 origin, num radius, num strength, [num/*enum PhysicsRadialImpulseFalloff*/ falloff]);

    external PhysicsGravitationalFieldEventData getData();

    external void enable();

    external void disable();

    external void dispose([bool force]);

    external get JS$_tick;

    external set JS$_tick(v);
}

@JS("BABYLON.PhysicsUpdraftEvent")
class PhysicsUpdraftEvent {
    // @Ignore
    PhysicsUpdraftEvent .fakeConstructor$();

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_origin;

    external set JS$_origin(v);

    external get JS$_radius;

    external set JS$_radius(v);

    external get JS$_strength;

    external set JS$_strength(v);

    external get JS$_height;

    external set JS$_height(v);

    external get JS$_updraftMode;

    external set JS$_updraftMode(v);

    external get JS$_physicsEngine;

    external set JS$_physicsEngine(v);

    external get JS$_originTop;

    external set JS$_originTop(v);

    external get JS$_originDirection;

    external set JS$_originDirection(v);

    external get JS$_tickCallback;

    external set JS$_tickCallback(v);

    external get JS$_cylinder;

    external set JS$_cylinder(v);

    external get JS$_cylinderPosition;

    external set JS$_cylinderPosition(v);

    external get JS$_dataFetched;

    external set JS$_dataFetched(v);

    external factory PhysicsUpdraftEvent(Scene JS$_scene, Vector3 JS$_origin, num JS$_radius, num JS$_strength, num JS$_height, num/*enum PhysicsUpdraftMode*/ JS$_updraftMode);

    external PhysicsUpdraftEventData getData();

    external void enable();

    external void disable();

    external void dispose([bool force]);

    external get getImpostorForceAndContactPoint;

    external set getImpostorForceAndContactPoint(v);

    external get JS$_tick;

    external set JS$_tick(v);

    external get JS$_prepareCylinder;

    external set JS$_prepareCylinder(v);

    external get JS$_intersectsWithCylinder;

    external set JS$_intersectsWithCylinder(v);
}

@JS("BABYLON.PhysicsVortexEvent")
class PhysicsVortexEvent {
    // @Ignore
    PhysicsVortexEvent .fakeConstructor$();

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_origin;

    external set JS$_origin(v);

    external get JS$_radius;

    external set JS$_radius(v);

    external get JS$_strength;

    external set JS$_strength(v);

    external get JS$_height;

    external set JS$_height(v);

    external get JS$_physicsEngine;

    external set JS$_physicsEngine(v);

    external get JS$_originTop;

    external set JS$_originTop(v);

    external get JS$_centripetalForceThreshold;

    external set JS$_centripetalForceThreshold(v);

    external get JS$_updraftMultiplier;

    external set JS$_updraftMultiplier(v);

    external get JS$_tickCallback;

    external set JS$_tickCallback(v);

    external get JS$_cylinder;

    external set JS$_cylinder(v);

    external get JS$_cylinderPosition;

    external set JS$_cylinderPosition(v);

    external get JS$_dataFetched;

    external set JS$_dataFetched(v);

    external factory PhysicsVortexEvent(Scene JS$_scene, Vector3 JS$_origin, num JS$_radius, num JS$_strength, num JS$_height);

    external PhysicsVortexEventData getData();

    external void enable();

    external void disable();

    external void dispose([bool force]);

    external get getImpostorForceAndContactPoint;

    external set getImpostorForceAndContactPoint(v);

    external get JS$_tick;

    external set JS$_tick(v);

    external get JS$_prepareCylinder;

    external set JS$_prepareCylinder(v);

    external get JS$_intersectsWithCylinder;

    external set JS$_intersectsWithCylinder(v);
}

@JS("BABYLON.PhysicsRadialImpulseFalloff")
class PhysicsRadialImpulseFalloff {
    external static num get Constant;

    external static num get Linear;
}

@JS("BABYLON.PhysicsUpdraftMode")
class PhysicsUpdraftMode {
    external static num get Center;

    external static num get Perpendicular;
}

@anonymous
@JS()
abstract class PhysicsForceAndContactPoint {
    external Vector3 get force;

    external set force(Vector3 v);

    external Vector3 get contactPoint;

    external set contactPoint(Vector3 v);

    external factory PhysicsForceAndContactPoint({ Vector3 force, Vector3 contactPoint});
}

@anonymous
@JS()
abstract class PhysicsRadialExplosionEventData {
    external Mesh get sphere;

    external set sphere(Mesh v);

    external List<Ray> get rays;

    external set rays(List<Ray> v);

    external factory PhysicsRadialExplosionEventData({ Mesh sphere, List<Ray> rays});
}

@anonymous
@JS()
abstract class PhysicsGravitationalFieldEventData {
    external Mesh get sphere;

    external set sphere(Mesh v);

    external factory PhysicsGravitationalFieldEventData({ Mesh sphere});
}

@anonymous
@JS()
abstract class PhysicsUpdraftEventData {
    external Mesh get cylinder;

    external set cylinder(Mesh v);

    external factory PhysicsUpdraftEventData({ Mesh cylinder});
}

@anonymous
@JS()
abstract class PhysicsVortexEventData {
    external Mesh get cylinder;

    external set cylinder(Mesh v);

    external factory PhysicsVortexEventData({ Mesh cylinder});
}

@anonymous
@JS()
abstract class PhysicsImpostorParameters {
    external num get mass;

    external set mass(num v);

    external num get friction;

    external set friction(num v);

    external num get restitution;

    external set restitution(num v);

    external dynamic get nativeOptions;

    external set nativeOptions(dynamic v);

    external bool get ignoreParent;

    external set ignoreParent(bool v);

    external bool get disableBidirectionalTransformation;

    external set disableBidirectionalTransformation(bool v);

    external factory PhysicsImpostorParameters({ num mass, num friction, num restitution, dynamic nativeOptions, bool ignoreParent, bool disableBidirectionalTransformation});
}

@anonymous
@JS()
abstract class IPhysicsEnabledObject {
    external Vector3 get position;

    external set position(Vector3 v);

    external Quaternion/*Quaternion|Null*/ get rotationQuaternion;

    external set rotationQuaternion(Quaternion/*Quaternion|Null*/ v);

    external Vector3 get scaling;

    external set scaling(Vector3 v);

    external Vector3 get rotation;

    external set rotation(Vector3 v);

    external dynamic get parent;

    external set parent(dynamic v);

    external BoundingInfo getBoundingInfo();

    external Matrix computeWorldMatrix(bool force);

    external Matrix getWorldMatrix();

    external List<AbstractMesh> getChildMeshes([bool directDescendantsOnly]);

    external dynamic/*List<num>|Float32List|Null*/ getVerticesData(String kind);

    external dynamic/*List<num>|Int32List|Uint32List|Uint16List|Null*/ getIndices();

    external Scene getScene();

    external Vector3 getAbsolutePosition();

    external Vector3 getAbsolutePivotPoint();

    external TransformNode rotate(Vector3 axis, num amount, [num/*enum Space*/ space]);

    external TransformNode translate(Vector3 axis, num distance, [num/*enum Space*/ space]);

    external TransformNode setAbsolutePosition(Vector3 absolutePosition);

    external String getClassName();
}

@JS("BABYLON.PhysicsImpostor")
class PhysicsImpostor {
    // @Ignore
    PhysicsImpostor .fakeConstructor$();

    external IPhysicsEnabledObject get object;

    external set object(IPhysicsEnabledObject v);

    external num get type;

    external set type(num v);

    external get JS$_options;

    external set JS$_options(v);

    external get JS$_scene;

    external set JS$_scene(v);

    external static Vector3 get DEFAULT_OBJECT_SIZE;

    external static set DEFAULT_OBJECT_SIZE(Vector3 v);

    external static Quaternion get IDENTITY_QUATERNION;

    external static set IDENTITY_QUATERNION(Quaternion v);

    external get JS$_physicsEngine;

    external set JS$_physicsEngine(v);

    external get JS$_physicsBody;

    external set JS$_physicsBody(v);

    external get JS$_bodyUpdateRequired;

    external set JS$_bodyUpdateRequired(v);

    external get JS$_onBeforePhysicsStepCallbacks;

    external set JS$_onBeforePhysicsStepCallbacks(v);

    external get JS$_onAfterPhysicsStepCallbacks;

    external set JS$_onAfterPhysicsStepCallbacks(v);

    external get JS$_onPhysicsCollideCallbacks;

    external set JS$_onPhysicsCollideCallbacks(v);

    external get JS$_deltaPosition;

    external set JS$_deltaPosition(v);

    external get JS$_deltaRotation;

    external set JS$_deltaRotation(v);

    external get JS$_deltaRotationConjugated;

    external set JS$_deltaRotationConjugated(v);

    external get JS$_parent;

    external set JS$_parent(v);

    external get JS$_isDisposed;

    external set JS$_isDisposed(v);

    external static get JS$_tmpVecs;

    external static set JS$_tmpVecs(v);

    external static get JS$_tmpQuat;

    external static set JS$_tmpQuat(v);

    external bool get isDisposed;

    external set isDisposed(bool v);

    external num get mass;

    external set mass(num v);

    external num get friction;

    external set friction(num v);

    external num get restitution;

    external set restitution(num v);

    external num get uniqueId;

    external set uniqueId(num v);

    external get JS$_joints;

    external set JS$_joints(v);

    external factory PhysicsImpostor(IPhysicsEnabledObject object, num type, [PhysicsImpostorParameters JS$_options, dynamic/*Scene|dynamic*/ JS$_scene]);

    external void JS$_init();

    external get JS$_getPhysicsParent;

    external set JS$_getPhysicsParent(v);

    external bool isBodyInitRequired();

    external void setScalingUpdated(bool updated);

    external void forceUpdate();

    external dynamic get physicsBody;

    external set physicsBody(dynamic v);

    external PhysicsImpostor/*PhysicsImpostor|Null*/ get parent;

    external set parent(PhysicsImpostor/*PhysicsImpostor|Null*/ v);

    external void resetUpdateFlags();

    external Vector3 getObjectExtendSize();

    external Vector3 getObjectCenter();

    external dynamic getParam(String paramName);

    external void setParam(String paramName, num value);

    external void setMass(num mass);

    external Vector3/*Vector3|Null*/ getLinearVelocity();

    external void setLinearVelocity(Vector3/*Vector3|Null*/ velocity);

    external Vector3/*Vector3|Null*/ getAngularVelocity();

    external void setAngularVelocity(Vector3/*Vector3|Null*/ velocity);

    external void executeNativeFunction(void func(dynamic world, dynamic physicsBody));

    external void registerBeforePhysicsStep(void func(PhysicsImpostor impostor));

    external void unregisterBeforePhysicsStep(void func(PhysicsImpostor impostor));

    external void registerAfterPhysicsStep(void func(PhysicsImpostor impostor));

    external void unregisterAfterPhysicsStep(void func(PhysicsImpostor impostor));

    external void registerOnPhysicsCollide(dynamic/*PhysicsImpostor|List<PhysicsImpostor>*/ collideAgainst, void func(PhysicsImpostor collider, PhysicsImpostor collidedAgainst));

    external void unregisterOnPhysicsCollide(dynamic/*PhysicsImpostor|List<PhysicsImpostor>*/ collideAgainst, void func(PhysicsImpostor collider, dynamic/*PhysicsImpostor|List<PhysicsImpostor>*/ collidedAgainst));

    external get JS$_tmpQuat;

    external set JS$_tmpQuat(v);

    external get JS$_tmpQuat2;

    external set JS$_tmpQuat2(v);

    external Quaternion getParentsRotation();

    external VoidFunc0 get beforeStep;

    external set beforeStep(VoidFunc0 v);

    external VoidFunc0 get afterStep;

    external set afterStep(VoidFunc0 v);

    external VoidFunc2<PhysicsImpostor, PhysicsImpostor>/*VoidFunc2<PhysicsImpostor, PhysicsImpostor>|Null*/ get onCollideEvent;

    external set onCollideEvent(VoidFunc2<PhysicsImpostor, PhysicsImpostor>/*VoidFunc2<PhysicsImpostor, PhysicsImpostor>|Null*/ v);

    external VoidFunc1<dynamic /*{
            body: any;
        }*/> get onCollide;

    external set onCollide(VoidFunc1<dynamic /*{
            body: any;
        }*/> v);

    external PhysicsImpostor applyForce(Vector3 force, Vector3 contactPoint);

    external PhysicsImpostor applyImpulse(Vector3 force, Vector3 contactPoint);

    external PhysicsImpostor createJoint(PhysicsImpostor otherImpostor, num jointType, PhysicsJointData jointData);

    external PhysicsImpostor addJoint(PhysicsImpostor otherImpostor, PhysicsJoint joint);

    external PhysicsImpostor sleep();

    external PhysicsImpostor wakeUp();

    external PhysicsImpostor/*PhysicsImpostor|Null*/ clone(IPhysicsEnabledObject newObject);

    external void dispose();

    external void setDeltaPosition(Vector3 position);

    external void setDeltaRotation(Quaternion rotation);

    external PhysicsImpostor getBoxSizeToRef(Vector3 result);

    external num getRadius();

    external void syncBoneWithImpostor(Bone bone, AbstractMesh boneMesh, Vector3 jointPivot, [num distToJoint, Quaternion adjustRotation]);

    external void syncImpostorWithBone(Bone bone, AbstractMesh boneMesh, Vector3 jointPivot, [num distToJoint, Quaternion adjustRotation, Vector3 boneAxis]);

    external static num get NoImpostor;

    external static set NoImpostor(num v);

    external static num get SphereImpostor;

    external static set SphereImpostor(num v);

    external static num get BoxImpostor;

    external static set BoxImpostor(num v);

    external static num get PlaneImpostor;

    external static set PlaneImpostor(num v);

    external static num get MeshImpostor;

    external static set MeshImpostor(num v);

    external static num get CylinderImpostor;

    external static set CylinderImpostor(num v);

    external static num get ParticleImpostor;

    external static set ParticleImpostor(num v);

    external static num get HeightmapImpostor;

    external static set HeightmapImpostor(num v);
}

@anonymous
@JS()
abstract class PhysicsJointData {
    external Vector3 get mainPivot;

    external set mainPivot(Vector3 v);

    external Vector3 get connectedPivot;

    external set connectedPivot(Vector3 v);

    external Vector3 get mainAxis;

    external set mainAxis(Vector3 v);

    external Vector3 get connectedAxis;

    external set connectedAxis(Vector3 v);

    external bool get collision;

    external set collision(bool v);

    external dynamic get nativeParams;

    external set nativeParams(dynamic v);

    external factory PhysicsJointData({ Vector3 mainPivot, Vector3 connectedPivot, Vector3 mainAxis, Vector3 connectedAxis, bool collision, dynamic nativeParams});
}

@JS("BABYLON.PhysicsJoint")
class PhysicsJoint {
    // @Ignore
    PhysicsJoint .fakeConstructor$();

    external num get type;

    external set type(num v);

    external PhysicsJointData get jointData;

    external set jointData(PhysicsJointData v);

    external get JS$_physicsJoint;

    external set JS$_physicsJoint(v);

    external IPhysicsEnginePlugin get JS$_physicsPlugin;

    external set JS$_physicsPlugin(IPhysicsEnginePlugin v);

    external factory PhysicsJoint(num type, PhysicsJointData jointData);

    external dynamic get physicsJoint;

    external set physicsJoint(dynamic v);

    external IPhysicsEnginePlugin get physicsPlugin;

    external set physicsPlugin(IPhysicsEnginePlugin v);

    external void executeNativeFunction(void func(dynamic world, dynamic physicsJoint));

    external static num get DistanceJoint;

    external static set DistanceJoint(num v);

    external static num get HingeJoint;

    external static set HingeJoint(num v);

    external static num get BallAndSocketJoint;

    external static set BallAndSocketJoint(num v);

    external static num get WheelJoint;

    external static set WheelJoint(num v);

    external static num get SliderJoint;

    external static set SliderJoint(num v);

    external static num get PrismaticJoint;

    external static set PrismaticJoint(num v);

    external static num get UniversalJoint;

    external static set UniversalJoint(num v);

    external static num get Hinge2Joint;

    external static set Hinge2Joint(num v);

    external static num get PointToPointJoint;

    external static set PointToPointJoint(num v);

    external static num get SpringJoint;

    external static set SpringJoint(num v);

    external static num get LockJoint;

    external static set LockJoint(num v);
}

@JS("BABYLON.DistanceJoint")
class DistanceJoint extends PhysicsJoint {
    // @Ignore
    DistanceJoint .fakeConstructor$() : super.fakeConstructor$();

    external factory DistanceJoint(DistanceJointData jointData);

    external void updateDistance(num maxDistance, [num minDistance]);
}

@JS("BABYLON.MotorEnabledJoint")
class MotorEnabledJoint extends PhysicsJoint implements IMotorEnabledJoint {
    // @Ignore
    MotorEnabledJoint .fakeConstructor$() : super.fakeConstructor$();

    external factory MotorEnabledJoint(num type, PhysicsJointData jointData);

    external void setMotor([num force, num maxForce]);

    external void setLimit(num upperLimit, [num lowerLimit]);
}

@JS("BABYLON.HingeJoint")
class HingeJoint extends MotorEnabledJoint {
    // @Ignore
    HingeJoint .fakeConstructor$() : super.fakeConstructor$();

    external factory HingeJoint(PhysicsJointData jointData);

    external void setMotor([num force, num maxForce]);

    external void setLimit(num upperLimit, [num lowerLimit]);
}

@JS("BABYLON.Hinge2Joint")
class Hinge2Joint extends MotorEnabledJoint {
    // @Ignore
    Hinge2Joint .fakeConstructor$() : super.fakeConstructor$();

    external factory Hinge2Joint(PhysicsJointData jointData);

    external void setMotor([num force, num maxForce, num motorIndex]);

    external void setLimit(num upperLimit, [num lowerLimit, num motorIndex]);
}

@anonymous
@JS()
abstract class IMotorEnabledJoint {
    external dynamic get physicsJoint;

    external set physicsJoint(dynamic v);

    external void setMotor([num force, num maxForce, num motorIndex]);

    external void setLimit(num upperLimit, [num lowerLimit, num motorIndex]);
}

@anonymous
@JS()
abstract class DistanceJointData
    implements PhysicsJointData {
    external num get maxDistance;

    external set maxDistance(num v);

    external factory DistanceJointData({ num maxDistance, Vector3 mainPivot, Vector3 connectedPivot, Vector3 mainAxis, Vector3 connectedAxis, bool collision, dynamic nativeParams});
}

@anonymous
@JS()
abstract class SpringJointData
    implements PhysicsJointData {
    external num get length;

    external set length(num v);

    external num get stiffness;

    external set stiffness(num v);

    external num get damping;

    external set damping(num v);

    external VoidFunc0 get forceApplicationCallback;

    external set forceApplicationCallback(VoidFunc0 v);

    external factory SpringJointData({ num length, num stiffness, num damping, VoidFunc0 forceApplicationCallback, Vector3 mainPivot, Vector3 connectedPivot, Vector3 mainAxis, Vector3 connectedAxis, bool collision, dynamic nativeParams});
}

@JS("BABYLON.ReflectionProbe")
class ReflectionProbe {
    // @Ignore
    ReflectionProbe .fakeConstructor$();

    external String get name;

    external set name(String v);

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_renderTargetTexture;

    external set JS$_renderTargetTexture(v);

    external get JS$_projectionMatrix;

    external set JS$_projectionMatrix(v);

    external get JS$_viewMatrix;

    external set JS$_viewMatrix(v);

    external get JS$_target;

    external set JS$_target(v);

    external get JS$_add;

    external set JS$_add(v);

    external get JS$_attachedMesh;

    external set JS$_attachedMesh(v);

    external get JS$_invertYAxis;

    external set JS$_invertYAxis(v);

    external Vector3 get position;

    external set position(Vector3 v);

    external factory ReflectionProbe(String name, num size, Scene scene, [bool generateMipMaps, bool useFloat]);

    external num get samples;

    external set samples(num v);

    external num get refreshRate;

    external set refreshRate(num v);

    external Scene getScene();

    external RenderTargetTexture get cubeTexture;

    external set cubeTexture(RenderTargetTexture v);

    external List<AbstractMesh>/*List<AbstractMesh>|Null*/ get renderList;

    external set renderList(List<AbstractMesh>/*List<AbstractMesh>|Null*/ v);

    external void attachToMesh(AbstractMesh mesh);

    external void setRenderingAutoClearDepthStencil(num renderingGroupId, bool autoClearDepthStencil);

    external void dispose();
}

@JS("BABYLON.BoundingBoxRenderer")
class BoundingBoxRenderer implements ISceneComponent {
    // @Ignore
    BoundingBoxRenderer .fakeConstructor$();

    external String get name;

    external set name(String v);

    external Scene get scene;

    external set scene(Scene v);

    external Color3 get frontColor;

    external set frontColor(Color3 v);

    external Color3 get backColor;

    external set backColor(Color3 v);

    external bool get showBackLines;

    external set showBackLines(bool v);

    external SmartArray<BoundingBox> get renderList;

    external set renderList(SmartArray<BoundingBox> v);

    external get JS$_colorShader;

    external set JS$_colorShader(v);

    external get JS$_vertexBuffers;

    external set JS$_vertexBuffers(v);

    external get JS$_indexBuffer;

    external set JS$_indexBuffer(v);

    external factory BoundingBoxRenderer(Scene scene);

    external void register();

    external get JS$_evaluateSubMesh;

    external set JS$_evaluateSubMesh(v);

    external get JS$_activeMesh;

    external set JS$_activeMesh(v);

    external get JS$_prepareRessources;

    external set JS$_prepareRessources(v);

    external get JS$_createIndexBuffer;

    external set JS$_createIndexBuffer(v);

    external void rebuild();

    external void reset();

    external void render(num renderingGroupId);

    external void renderOcclusionBoundingBox(AbstractMesh mesh);

    external void dispose();
}

@JS("BABYLON.DepthRenderer")
class DepthRenderer {
    // @Ignore
    DepthRenderer .fakeConstructor$();

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_depthMap;

    external set JS$_depthMap(v);

    external get JS$_effect;

    external set JS$_effect(v);

    external get JS$_cachedDefines;

    external set JS$_cachedDefines(v);

    external get JS$_camera;

    external set JS$_camera(v);

    external bool get useOnlyInActiveCamera;

    external set useOnlyInActiveCamera(bool v);

    external factory DepthRenderer(Scene scene, [num type, Camera/*Camera|Null*/ camera]);

    external bool isReady(SubMesh subMesh, bool useInstances);

    external RenderTargetTexture getDepthMap();

    external void dispose();
}

@JS("BABYLON.DepthRendererSceneComponent")
class DepthRendererSceneComponent implements ISceneComponent {
    // @Ignore
    DepthRendererSceneComponent .fakeConstructor$();

    external String get name;

    external set name(String v);

    external Scene get scene;

    external set scene(Scene v);

    external factory DepthRendererSceneComponent(Scene scene);

    external void register();

    external void rebuild();

    external void dispose();

    external get JS$_gatherRenderTargets;

    external set JS$_gatherRenderTargets(v);

    external get JS$_gatherActiveCameraRenderTargets;

    external set JS$_gatherActiveCameraRenderTargets(v);
}

@anonymous
@JS()
abstract class IEdgesRenderer
    implements IDisposable {
    external bool get isEnabled;

    external set isEnabled(bool v);

    external void render();

    external bool isReady();
}

@JS("BABYLON.EdgesRenderer")
class EdgesRenderer implements IEdgesRenderer {
    // @Ignore
    EdgesRenderer .fakeConstructor$();

    external num get edgesWidthScalerForOrthographic;

    external set edgesWidthScalerForOrthographic(num v);

    external num get edgesWidthScalerForPerspective;

    external set edgesWidthScalerForPerspective(num v);

    external AbstractMesh get JS$_source;

    external set JS$_source(AbstractMesh v);

    external List<num> get JS$_linesPositions;

    external set JS$_linesPositions(List<num> v);

    external List<num> get JS$_linesNormals;

    external set JS$_linesNormals(List<num> v);

    external List<num> get JS$_linesIndices;

    external set JS$_linesIndices(List<num> v);

    external num get JS$_epsilon;

    external set JS$_epsilon(num v);

    external num get JS$_indicesCount;

    external set JS$_indicesCount(num v);

    external ShaderMaterial get JS$_lineShader;

    external set JS$_lineShader(ShaderMaterial v);

    external Buffer get JS$_ib;

    external set JS$_ib(Buffer v);

    external dynamic/*JSMap of <String,VertexBuffer|Null>*/ get JS$_buffers;

    external set JS$_buffers(dynamic/*JSMap of <String,VertexBuffer|Null>*/ v);

    external bool get JS$_checkVerticesInsteadOfIndices;

    external set JS$_checkVerticesInsteadOfIndices(bool v);

    external get JS$_meshRebuildObserver;

    external set JS$_meshRebuildObserver(v);

    external get JS$_meshDisposeObserver;

    external set JS$_meshDisposeObserver(v);

    external bool get isEnabled;

    external set isEnabled(bool v);

    external factory EdgesRenderer(AbstractMesh source, [num epsilon, bool checkVerticesInsteadOfIndices, bool generateEdgesLines]);

    external void JS$_prepareRessources();

    external void JS$_rebuild();

    external void dispose();

    external num JS$_processEdgeForAdjacencies(num pa, num pb, num p0, num p1, num p2);

    external num JS$_processEdgeForAdjacenciesWithVertices(Vector3 pa, Vector3 pb, Vector3 p0, Vector3 p1, Vector3 p2);

    external void JS$_checkEdge(num faceIndex, num edge, List<Vector3> faceNormals, Vector3 p0, Vector3 p1);

    external void JS$_generateEdgesLines();

    external bool isReady();

    external void render();
}

@JS("BABYLON.GeometryBufferRenderer")
class GeometryBufferRenderer {
    // @Ignore
    GeometryBufferRenderer .fakeConstructor$();

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_multiRenderTarget;

    external set JS$_multiRenderTarget(v);

    external get JS$_ratio;

    external set JS$_ratio(v);

    external get JS$_enablePosition;

    external set JS$_enablePosition(v);

    external Effect get JS$_effect;

    external set JS$_effect(Effect v);

    external String get JS$_cachedDefines;

    external set JS$_cachedDefines(String v);

    external List<Mesh> get renderList;

    external set renderList(List<Mesh> v);

    external bool get isSupported;

    external set isSupported(bool v);

    external bool get enablePosition;

    external set enablePosition(bool v);

    external Scene get scene;

    external set scene(Scene v);

    external num get ratio;

    external set ratio(num v);

    external factory GeometryBufferRenderer(Scene scene, [num ratio]);

    external bool isReady(SubMesh subMesh, bool useInstances);

    external MultiRenderTarget getGBuffer();

    external num get samples;

    external set samples(num v);

    external void dispose();

    external void JS$_createRenderTargets();
}

@JS("BABYLON.GeometryBufferRendererSceneComponent")
class GeometryBufferRendererSceneComponent implements ISceneComponent {
    // @Ignore
    GeometryBufferRendererSceneComponent .fakeConstructor$();

    external String get name;

    external set name(String v);

    external Scene get scene;

    external set scene(Scene v);

    external factory GeometryBufferRendererSceneComponent(Scene scene);

    external void register();

    external void rebuild();

    external void dispose();

    external get JS$_gatherRenderTargets;

    external set JS$_gatherRenderTargets(v);
}

@JS("BABYLON.LineEdgesRenderer")
class LineEdgesRenderer extends EdgesRenderer {
    // @Ignore
    LineEdgesRenderer .fakeConstructor$() : super.fakeConstructor$();

    external factory LineEdgesRenderer(AbstractMesh source, [num epsilon, bool checkVerticesInsteadOfIndices]);

    external void JS$_checkEdge(num faceIndex, num edge, List<Vector3> faceNormals, Vector3 p0, Vector3 p1);

    external void JS$_generateEdgesLines();
}

@JS("BABYLON.OutlineRenderer")
class OutlineRenderer implements ISceneComponent {
    // @Ignore
    OutlineRenderer .fakeConstructor$();

    external String get name;

    external set name(String v);

    external Scene get scene;

    external set scene(Scene v);

    external num get zOffset;

    external set zOffset(num v);

    external get JS$_engine;

    external set JS$_engine(v);

    external get JS$_effect;

    external set JS$_effect(v);

    external get JS$_cachedDefines;

    external set JS$_cachedDefines(v);

    external get JS$_savedDepthWrite;

    external set JS$_savedDepthWrite(v);

    external factory OutlineRenderer(Scene scene);

    external void register();

    external void rebuild();

    external void dispose();

    external void render(SubMesh subMesh, JS$_InstancesBatch batch, [bool useOverlay]);

    external bool isReady(SubMesh subMesh, bool useInstances);

    external get JS$_beforeRenderingMesh;

    external set JS$_beforeRenderingMesh(v);

    external get JS$_afterRenderingMesh;

    external set JS$_afterRenderingMesh(v);
}

@JS("BABYLON.RenderingGroup")
class RenderingGroup {
    // @Ignore
    RenderingGroup .fakeConstructor$();

    external num get index;

    external set index(num v);

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_opaqueSubMeshes;

    external set JS$_opaqueSubMeshes(v);

    external get JS$_transparentSubMeshes;

    external set JS$_transparentSubMeshes(v);

    external get JS$_alphaTestSubMeshes;

    external set JS$_alphaTestSubMeshes(v);

    external get JS$_depthOnlySubMeshes;

    external set JS$_depthOnlySubMeshes(v);

    external get JS$_particleSystems;

    external set JS$_particleSystems(v);

    external get JS$_spriteManagers;

    external set JS$_spriteManagers(v);

    external get JS$_opaqueSortCompareFn;

    external set JS$_opaqueSortCompareFn(v);

    external get JS$_alphaTestSortCompareFn;

    external set JS$_alphaTestSortCompareFn(v);

    external get JS$_transparentSortCompareFn;

    external set JS$_transparentSortCompareFn(v);

    external get JS$_renderOpaque;

    external set JS$_renderOpaque(v);

    external get JS$_renderAlphaTest;

    external set JS$_renderAlphaTest(v);

    external get JS$_renderTransparent;

    external set JS$_renderTransparent(v);

    external get JS$_edgesRenderers;

    external set JS$_edgesRenderers(v);

    external VoidFunc0 get onBeforeTransparentRendering;

    external set onBeforeTransparentRendering(VoidFunc0 v);

    external Func2<SubMesh, SubMesh, num>/*Func2<SubMesh, SubMesh, num>|Null*/ get opaqueSortCompareFn;

    external set opaqueSortCompareFn(Func2<SubMesh, SubMesh, num>/*Func2<SubMesh, SubMesh, num>|Null*/ v);

    external Func2<SubMesh, SubMesh, num>/*Func2<SubMesh, SubMesh, num>|Null*/ get alphaTestSortCompareFn;

    external set alphaTestSortCompareFn(Func2<SubMesh, SubMesh, num>/*Func2<SubMesh, SubMesh, num>|Null*/ v);

    external Func2<SubMesh, SubMesh, num>/*Func2<SubMesh, SubMesh, num>|Null*/ get transparentSortCompareFn;

    external set transparentSortCompareFn(Func2<SubMesh, SubMesh, num>/*Func2<SubMesh, SubMesh, num>|Null*/ v);

    external factory RenderingGroup(num index, Scene scene, [Func2<SubMesh, SubMesh, num>/*Func2<SubMesh, SubMesh, num>|Null*/ opaqueSortCompareFn, Func2<SubMesh, SubMesh, num>/*Func2<SubMesh, SubMesh, num>|Null*/ alphaTestSortCompareFn, Func2<SubMesh, SubMesh, num>/*Func2<SubMesh, SubMesh, num>|Null*/ transparentSortCompareFn]);

    external void render(VoidFunc4<SmartArray<SubMesh>, SmartArray<SubMesh>, SmartArray<SubMesh>, SmartArray<SubMesh>>/*VoidFunc4<SmartArray<SubMesh>, SmartArray<SubMesh>, SmartArray<SubMesh>, SmartArray<SubMesh>>|Null*/ customRenderFunction, bool renderSprites, bool renderParticles, List<AbstractMesh>/*List<AbstractMesh>|Null*/ activeMeshes);

    external get renderOpaqueSorted;

    external set renderOpaqueSorted(v);

    external get renderAlphaTestSorted;

    external set renderAlphaTestSorted(v);

    external get renderTransparentSorted;

    external set renderTransparentSorted(v);

    external static get renderSorted;

    external static set renderSorted(v);

    external static get renderUnsorted;

    external static set renderUnsorted(v);

    external static num defaultTransparentSortCompare(SubMesh a, SubMesh b);

    external static num backToFrontSortCompare(SubMesh a, SubMesh b);

    external static num frontToBackSortCompare(SubMesh a, SubMesh b);

    external void prepare();

    external void dispose();

    external void dispatch(SubMesh subMesh, [AbstractMesh mesh, Material/*Material|Null*/ material]);

    external void dispatchSprites(ISpriteManager spriteManager);

    external void dispatchParticles(IParticleSystem particleSystem);

    external get JS$_renderParticles;

    external set JS$_renderParticles(v);

    external get JS$_renderSprites;

    external set JS$_renderSprites(v);
}

@anonymous
@JS()
abstract class IRenderingManagerAutoClearSetup {
    external bool get autoClear;

    external set autoClear(bool v);

    external bool get depth;

    external set depth(bool v);

    external bool get stencil;

    external set stencil(bool v);

    external factory IRenderingManagerAutoClearSetup({ bool autoClear, bool depth, bool stencil});
}

@JS("BABYLON.RenderingManager")
class RenderingManager {
    // @Ignore
    RenderingManager .fakeConstructor$();

    external static num get MAX_RENDERINGGROUPS;

    external static set MAX_RENDERINGGROUPS(num v);

    external static num get MIN_RENDERINGGROUPS;

    external static set MIN_RENDERINGGROUPS(num v);

    external static bool get AUTOCLEAR;

    external static set AUTOCLEAR(bool v);

    external bool get JS$_useSceneAutoClearSetup;

    external set JS$_useSceneAutoClearSetup(bool v);

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_renderingGroups;

    external set JS$_renderingGroups(v);

    external get JS$_depthStencilBufferAlreadyCleaned;

    external set JS$_depthStencilBufferAlreadyCleaned(v);

    external get JS$_autoClearDepthStencil;

    external set JS$_autoClearDepthStencil(v);

    external get JS$_customOpaqueSortCompareFn;

    external set JS$_customOpaqueSortCompareFn(v);

    external get JS$_customAlphaTestSortCompareFn;

    external set JS$_customAlphaTestSortCompareFn(v);

    external get JS$_customTransparentSortCompareFn;

    external set JS$_customTransparentSortCompareFn(v);

    external get JS$_renderingGroupInfo;

    external set JS$_renderingGroupInfo(v);

    external factory RenderingManager(Scene scene);

    external get JS$_clearDepthStencilBuffer;

    external set JS$_clearDepthStencilBuffer(v);

    external void render(VoidFunc4<SmartArray<SubMesh>, SmartArray<SubMesh>, SmartArray<SubMesh>, SmartArray<SubMesh>>/*VoidFunc4<SmartArray<SubMesh>, SmartArray<SubMesh>, SmartArray<SubMesh>, SmartArray<SubMesh>>|Null*/ customRenderFunction, List<AbstractMesh>/*List<AbstractMesh>|Null*/ activeMeshes, bool renderParticles, bool renderSprites);

    external void reset();

    external void dispose();

    external void freeRenderingGroups();

    external get JS$_prepareRenderingGroup;

    external set JS$_prepareRenderingGroup(v);

    external void dispatchSprites(ISpriteManager spriteManager);

    external void dispatchParticles(IParticleSystem particleSystem);

    external void dispatch(SubMesh subMesh, [AbstractMesh mesh, Material/*Material|Null*/ material]);

    external void setRenderingOrder(num renderingGroupId, [Func2<SubMesh, SubMesh, num>/*Func2<SubMesh, SubMesh, num>|Null*/ opaqueSortCompareFn, Func2<SubMesh, SubMesh, num>/*Func2<SubMesh, SubMesh, num>|Null*/ alphaTestSortCompareFn, Func2<SubMesh, SubMesh, num>/*Func2<SubMesh, SubMesh, num>|Null*/ transparentSortCompareFn]);

    external void setRenderingAutoClearDepthStencil(num renderingGroupId, bool autoClearDepthStencil, [bool depth, bool stencil]);

    external IRenderingManagerAutoClearSetup getAutoClearDepthStencilSetup(num index);
}

@JS("BABYLON.UtilityLayerRenderer")
class UtilityLayerRenderer implements IDisposable {
    // @Ignore
    UtilityLayerRenderer .fakeConstructor$();

    external Scene get originalScene;

    external set originalScene(Scene v);

    external get JS$_pointerCaptures;

    external set JS$_pointerCaptures(v);

    external get JS$_lastPointerEvents;

    external set JS$_lastPointerEvents(v);

    external static get JS$_DefaultUtilityLayer;

    external static set JS$_DefaultUtilityLayer(v);

    external static get JS$_DefaultKeepDepthUtilityLayer;

    external static set JS$_DefaultKeepDepthUtilityLayer(v);

    external static UtilityLayerRenderer get DefaultUtilityLayer;

    external static set DefaultUtilityLayer(UtilityLayerRenderer v);

    external static UtilityLayerRenderer get DefaultKeepDepthUtilityLayer;

    external static set DefaultKeepDepthUtilityLayer(UtilityLayerRenderer v);

    external Scene get utilityLayerScene;

    external set utilityLayerScene(Scene v);

    external bool get shouldRender;

    external set shouldRender(bool v);

    external bool get onlyCheckPointerDownEvents;

    external set onlyCheckPointerDownEvents(bool v);

    external bool get processAllEvents;

    external set processAllEvents(bool v);

    external Observable<num> get onPointerOutObservable;

    external set onPointerOutObservable(Observable<num> v);

    external Func1<AbstractMesh/*AbstractMesh|Null*/, bool> get mainSceneTrackerPredicate;

    external set mainSceneTrackerPredicate(Func1<AbstractMesh/*AbstractMesh|Null*/, bool> v);

    external get JS$_afterRenderObserver;

    external set JS$_afterRenderObserver(v);

    external get JS$_sceneDisposeObserver;

    external set JS$_sceneDisposeObserver(v);

    external get JS$_originalPointerObserver;

    external set JS$_originalPointerObserver(v);

    external factory UtilityLayerRenderer(Scene originalScene);

    external get JS$_notifyObservers;

    external set JS$_notifyObservers(v);

    external void render();

    external void dispose();

    external get JS$_updateCamera;

    external set JS$_updateCamera(v);
}

@JS("BABYLON.AnaglyphPostProcess")
class AnaglyphPostProcess extends PostProcess {
    // @Ignore
    AnaglyphPostProcess .fakeConstructor$() : super.fakeConstructor$();
    external get JS$_passedProcess;

    external set JS$_passedProcess(v);

    external factory AnaglyphPostProcess(String name, num/*num|PostProcessOptions*/ options, List<Camera> rigCameras, [num samplingMode, Engine engine, bool reusable]);
}

@JS("BABYLON.BlackAndWhitePostProcess")
class BlackAndWhitePostProcess extends PostProcess {
    // @Ignore
    BlackAndWhitePostProcess .fakeConstructor$() : super.fakeConstructor$();
    external num get degree;

    external set degree(num v);

    external factory BlackAndWhitePostProcess(String name, num/*num|PostProcessOptions*/ options, Camera camera, [num samplingMode, Engine engine, bool reusable]);
}

@JS("BABYLON.BloomEffect")
class BloomEffect extends PostProcessRenderEffect {
    // @Ignore
    BloomEffect .fakeConstructor$() : super.fakeConstructor$();
    external get bloomScale;

    external set bloomScale(v);

    external List<PostProcess> get JS$_effects;

    external set JS$_effects(List<PostProcess> v);

    external ExtractHighlightsPostProcess get JS$_downscale;

    external set JS$_downscale(ExtractHighlightsPostProcess v);

    external get JS$_blurX;

    external set JS$_blurX(v);

    external get JS$_blurY;

    external set JS$_blurY(v);

    external get JS$_merge;

    external set JS$_merge(v);

    external num get threshold;

    external set threshold(num v);

    external num get weight;

    external set weight(num v);

    external num get kernel;

    external set kernel(num v);

    external factory BloomEffect(Scene scene, num bloomScale, num bloomWeight, num bloomKernel, [num pipelineTextureType, bool blockCompilation]);

    external void disposeEffects(Camera camera);

    external void JS$_updateEffects();

    external bool JS$_isReady();
}

@JS("BABYLON.BloomMergePostProcess")
class BloomMergePostProcess extends PostProcess {
    // @Ignore
    BloomMergePostProcess .fakeConstructor$() : super.fakeConstructor$();
    external num get weight;

    external set weight(num v);

    external factory BloomMergePostProcess(String name, PostProcess originalFromInput, PostProcess blurred, num weight, num/*num|PostProcessOptions*/ options, Camera/*Camera|Null*/ camera, [num samplingMode, Engine engine, bool reusable, num textureType, bool blockCompilation]);
}

@JS("BABYLON.BlurPostProcess")
class BlurPostProcess extends PostProcess {
    // @Ignore
    BlurPostProcess .fakeConstructor$() : super.fakeConstructor$();
    external Vector2 get direction;

    external set direction(Vector2 v);

    external get blockCompilation;

    external set blockCompilation(v);

    external num get JS$_kernel;

    external set JS$_kernel(num v);

    external num get JS$_idealKernel;

    external set JS$_idealKernel(num v);

    external bool get JS$_packedFloat;

    external set JS$_packedFloat(bool v);

    external get JS$_staticDefines;

    external set JS$_staticDefines(v);

    external num get kernel;

    external set kernel(num v);

    external bool get packedFloat;

    external set packedFloat(bool v);

    external factory BlurPostProcess(String name, Vector2 direction, num kernel, num/*num|PostProcessOptions*/ options, Camera/*Camera|Null*/ camera, [num samplingMode, Engine engine, bool reusable, num textureType, String defines, bool blockCompilation]);

    external void updateEffect([String/*String|Null*/ defines, List<String>/*List<String>|Null*/ uniforms, List<String>/*List<String>|Null*/ samplers, dynamic indexParameters, void onCompiled(Effect effect), void onError(Effect effect, String errors)]);

    external void JS$_updateParameters([void onCompiled(Effect effect), void onError(Effect effect, String errors)]);

    external num JS$_nearestBestKernel(num idealKernel);

    external num JS$_gaussianWeight(num x);

    external String JS$_glslFloat(num x, [num decimalFigures]);
}

@JS("BABYLON.ChromaticAberrationPostProcess")
class ChromaticAberrationPostProcess extends PostProcess {
    // @Ignore
    ChromaticAberrationPostProcess .fakeConstructor$() : super.fakeConstructor$();
    external num get aberrationAmount;

    external set aberrationAmount(num v);

    external num get radialIntensity;

    external set radialIntensity(num v);

    external Vector2 get direction;

    external set direction(Vector2 v);

    external Vector2 get centerPosition;

    external set centerPosition(Vector2 v);

    external factory ChromaticAberrationPostProcess(String name, num screenWidth, num screenHeight, num/*num|PostProcessOptions*/ options, Camera/*Camera|Null*/ camera, [num samplingMode, Engine engine, bool reusable, num textureType, bool blockCompilation]);
}

@JS("BABYLON.CircleOfConfusionPostProcess")
class CircleOfConfusionPostProcess extends PostProcess {
    // @Ignore
    CircleOfConfusionPostProcess .fakeConstructor$() : super.fakeConstructor$();
    external num get lensSize;

    external set lensSize(num v);

    external num get fStop;

    external set fStop(num v);

    external num get focusDistance;

    external set focusDistance(num v);

    external num get focalLength;

    external set focalLength(num v);

    external get JS$_depthTexture;

    external set JS$_depthTexture(v);

    external factory CircleOfConfusionPostProcess(String name, RenderTargetTexture/*RenderTargetTexture|Null*/ depthTexture, num/*num|PostProcessOptions*/ options, Camera/*Camera|Null*/ camera, [num samplingMode, Engine engine, bool reusable, num textureType, bool blockCompilation]);

    external RenderTargetTexture get depthTexture;

    external set depthTexture(RenderTargetTexture v);
}

@JS("BABYLON.ColorCorrectionPostProcess")
class ColorCorrectionPostProcess extends PostProcess {
    // @Ignore
    ColorCorrectionPostProcess .fakeConstructor$() : super.fakeConstructor$();
    external get JS$_colorTableTexture;

    external set JS$_colorTableTexture(v);

    external factory ColorCorrectionPostProcess(String name, String colorTableUrl, num/*num|PostProcessOptions*/ options, Camera camera, [num samplingMode, Engine engine, bool reusable]);
}

@JS("BABYLON.ConvolutionPostProcess")
class ConvolutionPostProcess extends PostProcess {
    // @Ignore
    ConvolutionPostProcess .fakeConstructor$() : super.fakeConstructor$();
    external List<num> get kernel;

    external set kernel(List<num> v);

    external factory ConvolutionPostProcess(String name, List<num> kernel, num/*num|PostProcessOptions*/ options, Camera/*Camera|Null*/ camera, [num samplingMode, Engine engine, bool reusable, num textureType]);

    external static List<num> get EdgeDetect0Kernel;

    external static set EdgeDetect0Kernel(List<num> v);

    external static List<num> get EdgeDetect1Kernel;

    external static set EdgeDetect1Kernel(List<num> v);

    external static List<num> get EdgeDetect2Kernel;

    external static set EdgeDetect2Kernel(List<num> v);

    external static List<num> get SharpenKernel;

    external static set SharpenKernel(List<num> v);

    external static List<num> get EmbossKernel;

    external static set EmbossKernel(List<num> v);

    external static List<num> get GaussianKernel;

    external static set GaussianKernel(List<num> v);
}

@JS("BABYLON.DepthOfFieldBlurPostProcess")
class DepthOfFieldBlurPostProcess extends BlurPostProcess {
    // @Ignore
    DepthOfFieldBlurPostProcess .fakeConstructor$() : super.fakeConstructor$();
    external Vector2 get direction;

    external set direction(Vector2 v);

    external factory DepthOfFieldBlurPostProcess(String name, Scene scene, Vector2 direction, num kernel, num/*num|PostProcessOptions*/ options, Camera/*Camera|Null*/ camera, PostProcess circleOfConfusion, [PostProcess/*PostProcess|Null*/ imageToBlur, num samplingMode, Engine engine, bool reusable, num textureType, bool blockCompilation]);
}

@JS("BABYLON.DepthOfFieldEffectBlurLevel")
class DepthOfFieldEffectBlurLevel {
    external static num get Low;

    external static num get Medium;

    external static num get High;
}

@JS("BABYLON.DepthOfFieldEffect")
class DepthOfFieldEffect extends PostProcessRenderEffect {
    // @Ignore
    DepthOfFieldEffect .fakeConstructor$() : super.fakeConstructor$();
    external get JS$_circleOfConfusion;

    external set JS$_circleOfConfusion(v);

    external List<DepthOfFieldBlurPostProcess> get JS$_depthOfFieldBlurX;

    external set JS$_depthOfFieldBlurX(List<DepthOfFieldBlurPostProcess> v);

    external get JS$_depthOfFieldBlurY;

    external set JS$_depthOfFieldBlurY(v);

    external get JS$_dofMerge;

    external set JS$_dofMerge(v);

    external List<PostProcess> get JS$_effects;

    external set JS$_effects(List<PostProcess> v);

    external num get focalLength;

    external set focalLength(num v);

    external num get fStop;

    external set fStop(num v);

    external num get focusDistance;

    external set focusDistance(num v);

    external num get lensSize;

    external set lensSize(num v);

    external factory DepthOfFieldEffect(Scene scene, RenderTargetTexture/*RenderTargetTexture|Null*/ depthTexture, [num/*enum DepthOfFieldEffectBlurLevel*/ blurLevel, num pipelineTextureType, bool blockCompilation]);

    external RenderTargetTexture get depthTexture;

    external set depthTexture(RenderTargetTexture v);

    external void disposeEffects(Camera camera);

    external void JS$_updateEffects();

    external bool JS$_isReady();
}

@JS("BABYLON.DepthOfFieldMergePostProcessOptions")
class DepthOfFieldMergePostProcessOptions {
    // @Ignore
    DepthOfFieldMergePostProcessOptions .fakeConstructor$();

    external PostProcess get originalFromInput;

    external set originalFromInput(PostProcess v);

    external dynamic/*{
            circleOfConfusion: PostProcess;
            blurSteps: Array<PostProcess>;
        }*/ get depthOfField;

    external set depthOfField(dynamic/*{
            circleOfConfusion: PostProcess;
            blurSteps: Array<PostProcess>;
        }*/
    v);

    external dynamic/*{
            blurred: PostProcess;
            weight: number;
        }*/ get bloom;

    external set bloom(dynamic/*{
            blurred: PostProcess;
            weight: number;
        }*/
    v);
}

@JS("BABYLON.DepthOfFieldMergePostProcess")
class DepthOfFieldMergePostProcess extends PostProcess {
    // @Ignore
    DepthOfFieldMergePostProcess .fakeConstructor$() : super.fakeConstructor$();
    external get blurSteps;

    external set blurSteps(v);

    external factory DepthOfFieldMergePostProcess(String name, PostProcess originalFromInput, PostProcess circleOfConfusion, List<PostProcess> blurSteps, num/*num|PostProcessOptions*/ options, Camera/*Camera|Null*/ camera, [num samplingMode, Engine engine, bool reusable, num textureType, bool blockCompilation]);

    external void updateEffect([String/*String|Null*/ defines, List<String>/*List<String>|Null*/ uniforms, List<String>/*List<String>|Null*/ samplers, dynamic indexParameters, void onCompiled(Effect effect), void onError(Effect effect, String errors)]);
}

@JS("BABYLON.DisplayPassPostProcess")
class DisplayPassPostProcess extends PostProcess {
    // @Ignore
    DisplayPassPostProcess .fakeConstructor$() : super.fakeConstructor$();

    external factory DisplayPassPostProcess(String name, num/*num|PostProcessOptions*/ options, Camera/*Camera|Null*/ camera, [num samplingMode, Engine engine, bool reusable]);
}

@JS("BABYLON.ExtractHighlightsPostProcess")
class ExtractHighlightsPostProcess extends PostProcess {
    // @Ignore
    ExtractHighlightsPostProcess .fakeConstructor$() : super.fakeConstructor$();
    external num get threshold;

    external set threshold(num v);

    external num get JS$_exposure;

    external set JS$_exposure(num v);

    external PostProcess/*PostProcess|Null*/ get JS$_inputPostProcess;

    external set JS$_inputPostProcess(PostProcess/*PostProcess|Null*/ v);

    external factory ExtractHighlightsPostProcess(String name, num/*num|PostProcessOptions*/ options, Camera/*Camera|Null*/ camera, [num samplingMode, Engine engine, bool reusable, num textureType, bool blockCompilation]);
}

@JS("BABYLON.FilterPostProcess")
class FilterPostProcess extends PostProcess {
    // @Ignore
    FilterPostProcess .fakeConstructor$() : super.fakeConstructor$();
    external Matrix get kernelMatrix;

    external set kernelMatrix(Matrix v);

    external factory FilterPostProcess(String name, Matrix kernelMatrix, num/*num|PostProcessOptions*/ options, Camera/*Camera|Null*/ camera, [num samplingMode, Engine engine, bool reusable]);
}

@JS("BABYLON.FxaaPostProcess")
class FxaaPostProcess extends PostProcess {
    // @Ignore
    FxaaPostProcess .fakeConstructor$() : super.fakeConstructor$();
    external num get texelWidth;

    external set texelWidth(num v);

    external num get texelHeight;

    external set texelHeight(num v);

    external factory FxaaPostProcess(String name, num/*num|PostProcessOptions*/ options, [Camera/*Camera|Null*/ camera, num samplingMode, Engine engine, bool reusable, num textureType]);

    external get JS$_getDefines;

    external set JS$_getDefines(v);
}

@JS("BABYLON.GrainPostProcess")
class GrainPostProcess extends PostProcess {
    // @Ignore
    GrainPostProcess .fakeConstructor$() : super.fakeConstructor$();
    external num get intensity;

    external set intensity(num v);

    external bool get animated;

    external set animated(bool v);

    external factory GrainPostProcess(String name, num/*num|PostProcessOptions*/ options, Camera/*Camera|Null*/ camera, [num samplingMode, Engine engine, bool reusable, num textureType, bool blockCompilation]);
}

@JS("BABYLON.HighlightsPostProcess")
class HighlightsPostProcess extends PostProcess {
    // @Ignore
    HighlightsPostProcess .fakeConstructor$() : super.fakeConstructor$();

    external factory HighlightsPostProcess(String name, num/*num|PostProcessOptions*/ options, Camera/*Camera|Null*/ camera, [num samplingMode, Engine engine, bool reusable, num textureType]);
}

@JS("BABYLON.ImageProcessingPostProcess")
class ImageProcessingPostProcess extends PostProcess {
    // @Ignore
    ImageProcessingPostProcess .fakeConstructor$() : super.fakeConstructor$();
    external ImageProcessingConfiguration get JS$_imageProcessingConfiguration;

    external set JS$_imageProcessingConfiguration(ImageProcessingConfiguration v);

    external ImageProcessingConfiguration get imageProcessingConfiguration;

    external set imageProcessingConfiguration(ImageProcessingConfiguration v);

    external get JS$_imageProcessingObserver;

    external set JS$_imageProcessingObserver(v);

    external void JS$_attachImageProcessingConfiguration(ImageProcessingConfiguration/*ImageProcessingConfiguration|Null*/ configuration, [bool doNotBuild]);

    external ColorCurves/*ColorCurves|Null*/ get colorCurves;

    external set colorCurves(ColorCurves/*ColorCurves|Null*/ v);

    external bool get colorCurvesEnabled;

    external set colorCurvesEnabled(bool v);

    external BaseTexture/*BaseTexture|Null*/ get colorGradingTexture;

    external set colorGradingTexture(BaseTexture/*BaseTexture|Null*/ v);

    external bool get colorGradingEnabled;

    external set colorGradingEnabled(bool v);

    external num get exposure;

    external set exposure(num v);

    external bool get toneMappingEnabled;

    external set toneMappingEnabled(bool v);

    external num get contrast;

    external set contrast(num v);

    external num get vignetteStretch;

    external set vignetteStretch(num v);

    external num get vignetteCentreX;

    external set vignetteCentreX(num v);

    external num get vignetteCentreY;

    external set vignetteCentreY(num v);

    external num get vignetteWeight;

    external set vignetteWeight(num v);

    external Color4 get vignetteColor;

    external set vignetteColor(Color4 v);

    external num get vignetteCameraFov;

    external set vignetteCameraFov(num v);

    external num get vignetteBlendMode;

    external set vignetteBlendMode(num v);

    external bool get vignetteEnabled;

    external set vignetteEnabled(bool v);

    external get JS$_fromLinearSpace;

    external set JS$_fromLinearSpace(v);

    external bool get fromLinearSpace;

    external set fromLinearSpace(bool v);

    external get JS$_defines;

    external set JS$_defines(v);

    external factory ImageProcessingPostProcess(String name, num/*num|PostProcessOptions*/ options, [Camera/*Camera|Null*/ camera, num samplingMode, Engine engine, bool reusable, num textureType, ImageProcessingConfiguration imageProcessingConfiguration]);

    external String getClassName();

    external void JS$_updateParameters();

    external void dispose([Camera camera]);
}

@JS("BABYLON.PassPostProcess")
class PassPostProcess extends PostProcess {
    // @Ignore
    PassPostProcess .fakeConstructor$() : super.fakeConstructor$();

    external factory PassPostProcess(String name, num/*num|PostProcessOptions*/ options, [Camera/*Camera|Null*/ camera, num samplingMode, Engine engine, bool reusable, num textureType, bool blockCompilation]);
}

@anonymous
@JS()
abstract class PostProcessOptions {
    external num get width;

    external set width(num v);

    external num get height;

    external set height(num v);

    external factory PostProcessOptions({ num width, num height});
}

@JS("BABYLON.PostProcess")
class PostProcess {
    // @Ignore
    PostProcess .fakeConstructor$();

    external String get name;

    external set name(String v);

    external num get width;

    external set width(num v);

    external num get height;

    external set height(num v);

    external InternalTexture/*InternalTexture|Null*/ get JS$_outputTexture;

    external set JS$_outputTexture(InternalTexture/*InternalTexture|Null*/ v);

    external num get renderTargetSamplingMode;

    external set renderTargetSamplingMode(num v);

    external Color4 get clearColor;

    external set clearColor(Color4 v);

    external bool get autoClear;

    external set autoClear(bool v);

    external num get alphaMode;

    external set alphaMode(num v);

    external Color4 get alphaConstants;

    external set alphaConstants(Color4 v);

    external List<Animation> get animations;

    external set animations(List<Animation> v);

    external bool get enablePixelPerfectMode;

    external set enablePixelPerfectMode(bool v);

    external bool get forceFullscreenViewport;

    external set forceFullscreenViewport(bool v);

    external num get scaleMode;

    external set scaleMode(num v);

    external bool get alwaysForcePOT;

    external set alwaysForcePOT(bool v);

    external get JS$_samples;

    external set JS$_samples(v);

    external num get samples;

    external set samples(num v);

    external bool get adaptScaleToCurrentViewport;

    external set adaptScaleToCurrentViewport(bool v);

    external get JS$_camera;

    external set JS$_camera(v);

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_engine;

    external set JS$_engine(v);

    external get JS$_options;

    external set JS$_options(v);

    external get JS$_reusable;

    external set JS$_reusable(v);

    external get JS$_textureType;

    external set JS$_textureType(v);

    external SmartArray<InternalTexture> get JS$_textures;

    external set JS$_textures(SmartArray<InternalTexture> v);

    external num get JS$_currentRenderTextureInd;

    external set JS$_currentRenderTextureInd(num v);

    external get JS$_effect;

    external set JS$_effect(v);

    external get JS$_samplers;

    external set JS$_samplers(v);

    external get JS$_fragmentUrl;

    external set JS$_fragmentUrl(v);

    external get JS$_vertexUrl;

    external set JS$_vertexUrl(v);

    external get JS$_parameters;

    external set JS$_parameters(v);

    external get JS$_scaleRatio;

    external set JS$_scaleRatio(v);

    external dynamic get JS$_indexParameters;

    external set JS$_indexParameters(dynamic v);

    external get JS$_shareOutputWithPostProcess;

    external set JS$_shareOutputWithPostProcess(v);

    external get JS$_texelSize;

    external set JS$_texelSize(v);

    external get JS$_forcedOutputTexture;

    external set JS$_forcedOutputTexture(v);

    external Observable<Camera> get onActivateObservable;

    external set onActivateObservable(Observable<Camera> v);

    external get JS$_onActivateObserver;

    external set JS$_onActivateObserver(v);

    external VoidFunc1<Camera>/*VoidFunc1<Camera>|Null*/ get onActivate;

    external set onActivate(VoidFunc1<Camera>/*VoidFunc1<Camera>|Null*/ v);

    external Observable<PostProcess> get onSizeChangedObservable;

    external set onSizeChangedObservable(Observable<PostProcess> v);

    external get JS$_onSizeChangedObserver;

    external set JS$_onSizeChangedObserver(v);

    external VoidFunc1<PostProcess> get onSizeChanged;

    external set onSizeChanged(VoidFunc1<PostProcess> v);

    external Observable<Effect> get onApplyObservable;

    external set onApplyObservable(Observable<Effect> v);

    external get JS$_onApplyObserver;

    external set JS$_onApplyObserver(v);

    external VoidFunc1<Effect> get onApply;

    external set onApply(VoidFunc1<Effect> v);

    external Observable<Effect> get onBeforeRenderObservable;

    external set onBeforeRenderObservable(Observable<Effect> v);

    external get JS$_onBeforeRenderObserver;

    external set JS$_onBeforeRenderObserver(v);

    external VoidFunc1<Effect> get onBeforeRender;

    external set onBeforeRender(VoidFunc1<Effect> v);

    external Observable<Effect> get onAfterRenderObservable;

    external set onAfterRenderObservable(Observable<Effect> v);

    external get JS$_onAfterRenderObserver;

    external set JS$_onAfterRenderObserver(v);

    external VoidFunc1<Effect> get onAfterRender;

    external set onAfterRender(VoidFunc1<Effect> v);

    external InternalTexture get inputTexture;

    external set inputTexture(InternalTexture v);

    external Camera getCamera();

    external Vector2 get texelSize;

    external set texelSize(Vector2 v);

    external factory PostProcess(String name, String fragmentUrl, List<String>/*List<String>|Null*/ parameters, List<String>/*List<String>|Null*/ samplers, num/*num|PostProcessOptions*/ options, Camera/*Camera|Null*/ camera, [num samplingMode, Engine engine, bool reusable, String/*String|Null*/ defines, num textureType, String vertexUrl, dynamic indexParameters, bool blockCompilation]);

    external Engine getEngine();

    external Effect getEffect();

    external PostProcess shareOutputWith(PostProcess postProcess);

    external void useOwnOutput();

    external void updateEffect([String/*String|Null*/ defines, List<String>/*List<String>|Null*/ uniforms, List<String>/*List<String>|Null*/ samplers, dynamic indexParameters, void onCompiled(Effect effect), void onError(Effect effect, String errors)]);

    external bool isReusable();

    external void markTextureDirty();

    external InternalTexture activate(Camera/*Camera|Null*/ camera, [InternalTexture/*InternalTexture|Null*/ sourceTexture, bool forceDepthStencil]);

    external bool get isSupported;

    external set isSupported(bool v);

    external num get aspectRatio;

    external set aspectRatio(num v);

    external bool isReady();

    external Effect/*Effect|Null*/ apply();

    external get JS$_disposeTextures;

    external set JS$_disposeTextures(v);

    external void dispose([Camera camera]);
}

@JS("BABYLON.PostProcessManager")
class PostProcessManager {
    // @Ignore
    PostProcessManager .fakeConstructor$();

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_indexBuffer;

    external set JS$_indexBuffer(v);

    external get JS$_vertexBuffers;

    external set JS$_vertexBuffers(v);

    external factory PostProcessManager(Scene scene);

    external get JS$_prepareBuffers;

    external set JS$_prepareBuffers(v);

    external get JS$_buildIndexBuffer;

    external set JS$_buildIndexBuffer(v);

    external void JS$_rebuild();

    external bool JS$_prepareFrame([InternalTexture/*InternalTexture|Null*/ sourceTexture, List<PostProcess>/*List<PostProcess>|Null*/ postProcesses]);

    external void directRender(List<PostProcess> postProcesses, [InternalTexture/*InternalTexture|Null*/ targetTexture, bool forceFullscreenViewport, num faceIndex, num lodLevel]);

    external void JS$_finalizeFrame([bool doNotPresent, InternalTexture targetTexture, num faceIndex, List<PostProcess> postProcesses, bool forceFullscreenViewport]);

    external void dispose();
}

@JS("BABYLON.RefractionPostProcess")
class RefractionPostProcess extends PostProcess {
    // @Ignore
    RefractionPostProcess .fakeConstructor$() : super.fakeConstructor$();
    external Color3 get color;

    external set color(Color3 v);

    external num get depth;

    external set depth(num v);

    external num get colorLevel;

    external set colorLevel(num v);

    external get JS$_refTexture;

    external set JS$_refTexture(v);

    external get JS$_ownRefractionTexture;

    external set JS$_ownRefractionTexture(v);

    external Texture get refractionTexture;

    external set refractionTexture(Texture v);

    external factory RefractionPostProcess(String name, String refractionTextureUrl, Color3 color, num depth, num colorLevel, num/*num|PostProcessOptions*/ options, Camera camera, [num samplingMode, Engine engine, bool reusable]);

    external void dispose(Camera camera);
}

@JS("BABYLON.SharpenPostProcess")
class SharpenPostProcess extends PostProcess {
    // @Ignore
    SharpenPostProcess .fakeConstructor$() : super.fakeConstructor$();
    external num get colorAmount;

    external set colorAmount(num v);

    external num get edgeAmount;

    external set edgeAmount(num v);

    external factory SharpenPostProcess(String name, num/*num|PostProcessOptions*/ options, Camera/*Camera|Null*/ camera, [num samplingMode, Engine engine, bool reusable, num textureType, bool blockCompilation]);
}

@JS("BABYLON.StereoscopicInterlacePostProcess")
class StereoscopicInterlacePostProcess extends PostProcess {
    // @Ignore
    StereoscopicInterlacePostProcess .fakeConstructor$() : super.fakeConstructor$();
    external get JS$_stepSize;

    external set JS$_stepSize(v);

    external get JS$_passedProcess;

    external set JS$_passedProcess(v);

    external factory StereoscopicInterlacePostProcess(String name, List<Camera> rigCameras, bool isStereoscopicHoriz, [num samplingMode, Engine engine, bool reusable]);
}

@JS("BABYLON.TonemappingOperator")
class TonemappingOperator {
    external static num get Hable;

    external static num get Reinhard;

    external static num get HejiDawson;

    external static num get Photographic;
}

@JS("BABYLON.TonemapPostProcess")
class TonemapPostProcess extends PostProcess {
    // @Ignore
    TonemapPostProcess .fakeConstructor$() : super.fakeConstructor$();
    external get JS$_operator;

    external set JS$_operator(v);

    external num get exposureAdjustment;

    external set exposureAdjustment(num v);

    external factory TonemapPostProcess(String name, num/*enum TonemappingOperator*/ JS$_operator, num exposureAdjustment, Camera camera, [num samplingMode, Engine engine, num textureFormat]);
}

@JS("BABYLON.VolumetricLightScatteringPostProcess")
class VolumetricLightScatteringPostProcess extends PostProcess {
    // @Ignore
    VolumetricLightScatteringPostProcess .fakeConstructor$() : super.fakeConstructor$();
    external get JS$_volumetricLightScatteringPass;

    external set JS$_volumetricLightScatteringPass(v);

    external get JS$_volumetricLightScatteringRTT;

    external set JS$_volumetricLightScatteringRTT(v);

    external get JS$_viewPort;

    external set JS$_viewPort(v);

    external get JS$_screenCoordinates;

    external set JS$_screenCoordinates(v);

    external get JS$_cachedDefines;

    external set JS$_cachedDefines(v);

    external dynamic/*{
            position: Vector3;
        }*/ get attachedNode;

    external set attachedNode(dynamic/*{
            position: Vector3;
        }*/
    v);

    external Vector3 get customMeshPosition;

    external set customMeshPosition(Vector3 v);

    external bool get useCustomMeshPosition;

    external set useCustomMeshPosition(bool v);

    external bool get invert;

    external set invert(bool v);

    external Mesh get mesh;

    external set mesh(Mesh v);

    external bool get useDiffuseColor;

    external set useDiffuseColor(bool v);

    external List<AbstractMesh> get excludedMeshes;

    external set excludedMeshes(List<AbstractMesh> v);

    external num get exposure;

    external set exposure(num v);

    external num get decay;

    external set decay(num v);

    external num get weight;

    external set weight(num v);

    external num get density;

    external set density(num v);

    external factory VolumetricLightScatteringPostProcess(String name, dynamic ratio, Camera camera, [Mesh mesh, num samples, num samplingMode, Engine engine, bool reusable, Scene scene]);

    external String getClassName();

    external get JS$_isReady;

    external set JS$_isReady(v);

    external void setCustomMeshPosition(Vector3 position);

    external Vector3 getCustomMeshPosition();

    external void dispose(Camera camera);

    external RenderTargetTexture getPass();

    external get JS$_meshExcluded;

    external set JS$_meshExcluded(v);

    external get JS$_createPass;

    external set JS$_createPass(v);

    external get JS$_updateMeshScreenCoordinates;

    external set JS$_updateMeshScreenCoordinates(v);

    external static Mesh CreateDefaultMesh(String name, Scene scene);
}

@JS("BABYLON.VRDistortionCorrectionPostProcess")
class VRDistortionCorrectionPostProcess extends PostProcess {
    // @Ignore
    VRDistortionCorrectionPostProcess .fakeConstructor$() : super.fakeConstructor$();
    external get JS$_isRightEye;

    external set JS$_isRightEye(v);

    external get JS$_distortionFactors;

    external set JS$_distortionFactors(v);

    external get JS$_postProcessScaleFactor;

    external set JS$_postProcessScaleFactor(v);

    external get JS$_lensCenterOffset;

    external set JS$_lensCenterOffset(v);

    external get JS$_scaleIn;

    external set JS$_scaleIn(v);

    external get JS$_scaleFactor;

    external set JS$_scaleFactor(v);

    external get JS$_lensCenter;

    external set JS$_lensCenter(v);

    external factory VRDistortionCorrectionPostProcess(String name, Camera camera, bool isRightEye, VRCameraMetrics vrMetrics);
}

@JS("BABYLON.Sprite")
class Sprite {
    // @Ignore
    Sprite .fakeConstructor$();

    external String get name;

    external set name(String v);

    external Vector3 get position;

    external set position(Vector3 v);

    external Color4 get color;

    external set color(Color4 v);

    external num get width;

    external set width(num v);

    external num get height;

    external set height(num v);

    external num get angle;

    external set angle(num v);

    external num get cellIndex;

    external set cellIndex(num v);

    external num get invertU;

    external set invertU(num v);

    external num get invertV;

    external set invertV(num v);

    external bool get disposeWhenFinishedAnimating;

    external set disposeWhenFinishedAnimating(bool v);

    external List<Animation> get animations;

    external set animations(List<Animation> v);

    external bool get isPickable;

    external set isPickable(bool v);

    external ActionManager/*ActionManager|Null*/ get actionManager;

    external set actionManager(ActionManager/*ActionManager|Null*/ v);

    external get JS$_animationStarted;

    external set JS$_animationStarted(v);

    external get JS$_loopAnimation;

    external set JS$_loopAnimation(v);

    external get JS$_fromIndex;

    external set JS$_fromIndex(v);

    external get JS$_toIndex;

    external set JS$_toIndex(v);

    external get JS$_delay;

    external set JS$_delay(v);

    external get JS$_direction;

    external set JS$_direction(v);

    external get JS$_manager;

    external set JS$_manager(v);

    external get JS$_time;

    external set JS$_time(v);

    external get JS$_onAnimationEnd;

    external set JS$_onAnimationEnd(v);

    external bool get isVisible;

    external set isVisible(bool v);

    external num get size;

    external set size(num v);

    external factory Sprite(String name, ISpriteManager manager);

    external void playAnimation(num from, num to, bool loop, num delay, void onAnimationEnd());

    external void stopAnimation();

    external void JS$_animate(num deltaTime);

    external void dispose();
}

@anonymous
@JS()
abstract class ISpriteManager
    implements IDisposable {
    external num get layerMask;

    external set layerMask(num v);

    external bool get isPickable;

    external set isPickable(bool v);

    external num get renderingGroupId;

    external set renderingGroupId(num v);

    external List<Sprite> get sprites;

    external set sprites(List<Sprite> v);

    external PickingInfo/*PickingInfo|Null*/ intersects(Ray ray, Camera camera, [bool predicate(Sprite sprite), bool fastCheck]);

    external void render();
}

@JS("BABYLON.SpriteManager")
class SpriteManager implements ISpriteManager {
    // @Ignore
    SpriteManager .fakeConstructor$();

    external String get name;

    external set name(String v);

    external List<Sprite> get sprites;

    external set sprites(List<Sprite> v);

    external num get renderingGroupId;

    external set renderingGroupId(num v);

    external num get layerMask;

    external set layerMask(num v);

    external bool get fogEnabled;

    external set fogEnabled(bool v);

    external bool get isPickable;

    external set isPickable(bool v);

    external num get cellWidth;

    external set cellWidth(num v);

    external num get cellHeight;

    external set cellHeight(num v);

    external Observable<SpriteManager> get onDisposeObservable;

    external set onDisposeObservable(Observable<SpriteManager> v);

    external get JS$_onDisposeObserver;

    external set JS$_onDisposeObserver(v);

    external VoidFunc0 get onDispose;

    external set onDispose(VoidFunc0 v);

    external get JS$_capacity;

    external set JS$_capacity(v);

    external get JS$_spriteTexture;

    external set JS$_spriteTexture(v);

    external get JS$_epsilon;

    external set JS$_epsilon(v);

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_vertexData;

    external set JS$_vertexData(v);

    external get JS$_buffer;

    external set JS$_buffer(v);

    external get JS$_vertexBuffers;

    external set JS$_vertexBuffers(v);

    external get JS$_indexBuffer;

    external set JS$_indexBuffer(v);

    external get JS$_effectBase;

    external set JS$_effectBase(v);

    external get JS$_effectFog;

    external set JS$_effectFog(v);

    external Texture get texture;

    external set texture(Texture v);

    external factory SpriteManager(String name, String imgUrl, num capacity, dynamic cellSize, Scene scene, [num epsilon, num samplingMode]);

    external get JS$_appendSpriteVertex;

    external set JS$_appendSpriteVertex(v);

    external PickingInfo/*PickingInfo|Null*/ intersects(Ray ray, Camera camera, [bool predicate(Sprite sprite), bool fastCheck]);

    external void render();

    external void dispose();
}

@JS("BABYLON.SpriteSceneComponent")
class SpriteSceneComponent implements ISceneComponent {
    // @Ignore
    SpriteSceneComponent .fakeConstructor$();

    external String get name;

    external set name(String v);

    external Scene get scene;

    external set scene(Scene v);

    external get JS$_spritePredicate;

    external set JS$_spritePredicate(v);

    external factory SpriteSceneComponent(Scene scene);

    external void register();

    external void rebuild();

    external void dispose();

    external get JS$_pickSpriteButKeepRay;

    external set JS$_pickSpriteButKeepRay(v);

    external get JS$_pointerMove;

    external set JS$_pointerMove(v);

    external get JS$_pointerDown;

    external set JS$_pointerDown(v);

    external get JS$_pointerUp;

    external set JS$_pointerUp(v);
}

@JS("BABYLON._AlphaState")
class JS$_AlphaState {
    // @Ignore
    JS$_AlphaState .fakeConstructor$();

    external get JS$_isAlphaBlendDirty;

    external set JS$_isAlphaBlendDirty(v);

    external get JS$_isBlendFunctionParametersDirty;

    external set JS$_isBlendFunctionParametersDirty(v);

    external get JS$_isBlendEquationParametersDirty;

    external set JS$_isBlendEquationParametersDirty(v);

    external get JS$_isBlendConstantsDirty;

    external set JS$_isBlendConstantsDirty(v);

    external get JS$_alphaBlend;

    external set JS$_alphaBlend(v);

    external get JS$_blendFunctionParameters;

    external set JS$_blendFunctionParameters(v);

    external get JS$_blendEquationParameters;

    external set JS$_blendEquationParameters(v);

    external get JS$_blendConstants;

    external set JS$_blendConstants(v);

    external factory JS$_AlphaState();

    external bool get isDirty;

    external set isDirty(bool v);

    external bool get alphaBlend;

    external set alphaBlend(bool v);

    external void setAlphaBlendConstants(num r, num g, num b, num a);

    external void setAlphaBlendFunctionParameters(num value0, num value1, num value2, num value3);

    external void setAlphaEquationParameters(num rgb, num alpha);

    external void reset();

    external void apply(RenderingContext gl);
}

@JS("BABYLON._DepthCullingState")
class JS$_DepthCullingState {
    // @Ignore
    JS$_DepthCullingState .fakeConstructor$();

    external get JS$_isDepthTestDirty;

    external set JS$_isDepthTestDirty(v);

    external get JS$_isDepthMaskDirty;

    external set JS$_isDepthMaskDirty(v);

    external get JS$_isDepthFuncDirty;

    external set JS$_isDepthFuncDirty(v);

    external get JS$_isCullFaceDirty;

    external set JS$_isCullFaceDirty(v);

    external get JS$_isCullDirty;

    external set JS$_isCullDirty(v);

    external get JS$_isZOffsetDirty;

    external set JS$_isZOffsetDirty(v);

    external get JS$_isFrontFaceDirty;

    external set JS$_isFrontFaceDirty(v);

    external get JS$_depthTest;

    external set JS$_depthTest(v);

    external get JS$_depthMask;

    external set JS$_depthMask(v);

    external get JS$_depthFunc;

    external set JS$_depthFunc(v);

    external get JS$_cull;

    external set JS$_cull(v);

    external get JS$_cullFace;

    external set JS$_cullFace(v);

    external get JS$_zOffset;

    external set JS$_zOffset(v);

    external get JS$_frontFace;

    external set JS$_frontFace(v);

    external factory JS$_DepthCullingState();

    external bool get isDirty;

    external set isDirty(bool v);

    external num get zOffset;

    external set zOffset(num v);

    external num/*num|Null*/ get cullFace;

    external set cullFace(num/*num|Null*/ v);

    external bool/*bool|Null*/ get cull;

    external set cull(bool/*bool|Null*/ v);

    external num/*num|Null*/ get depthFunc;

    external set depthFunc(num/*num|Null*/ v);

    external bool get depthMask;

    external set depthMask(bool v);

    external bool get depthTest;

    external set depthTest(bool v);

    external num/*num|Null*/ get frontFace;

    external set frontFace(num/*num|Null*/ v);

    external void reset();

    external void apply(RenderingContext gl);
}

@JS("BABYLON._StencilState")
class JS$_StencilState {
    // @Ignore
    JS$_StencilState .fakeConstructor$();

    external get JS$_isStencilTestDirty;

    external set JS$_isStencilTestDirty(v);

    external get JS$_isStencilMaskDirty;

    external set JS$_isStencilMaskDirty(v);

    external get JS$_isStencilFuncDirty;

    external set JS$_isStencilFuncDirty(v);

    external get JS$_isStencilOpDirty;

    external set JS$_isStencilOpDirty(v);

    external get JS$_stencilTest;

    external set JS$_stencilTest(v);

    external get JS$_stencilMask;

    external set JS$_stencilMask(v);

    external get JS$_stencilFunc;

    external set JS$_stencilFunc(v);

    external get JS$_stencilFuncRef;

    external set JS$_stencilFuncRef(v);

    external get JS$_stencilFuncMask;

    external set JS$_stencilFuncMask(v);

    external get JS$_stencilOpStencilFail;

    external set JS$_stencilOpStencilFail(v);

    external get JS$_stencilOpDepthFail;

    external set JS$_stencilOpDepthFail(v);

    external get JS$_stencilOpStencilDepthPass;

    external set JS$_stencilOpStencilDepthPass(v);

    external bool get isDirty;

    external set isDirty(bool v);

    external num get stencilFunc;

    external set stencilFunc(num v);

    external num get stencilFuncRef;

    external set stencilFuncRef(num v);

    external num get stencilFuncMask;

    external set stencilFuncMask(num v);

    external num get stencilOpStencilFail;

    external set stencilOpStencilFail(num v);

    external num get stencilOpDepthFail;

    external set stencilOpDepthFail(num v);

    external num get stencilOpStencilDepthPass;

    external set stencilOpStencilDepthPass(num v);

    external num get stencilMask;

    external set stencilMask(num v);

    external bool get stencilTest;

    external set stencilTest(bool v);

    external factory JS$_StencilState();

    external void reset();

    external void apply(RenderingContext gl);
}

@JS("BABYLON.AndOrNotEvaluator")
class AndOrNotEvaluator {
    // @Ignore
    AndOrNotEvaluator .fakeConstructor$();

    external static bool Eval(String query, bool evaluateCallback(dynamic val));

    external static get JS$_HandleParenthesisContent;

    external static set JS$_HandleParenthesisContent(v);

    external static get JS$_SimplifyNegation;

    external static set JS$_SimplifyNegation(v);
}

@JS("BABYLON.AssetTaskState")
class AssetTaskState {
    external static num get INIT;

    external static num get RUNNING;

    external static num get DONE;

    external static num get ERROR;
}

@JS("BABYLON.AbstractAssetTask")
abstract class AbstractAssetTask {
    // @Ignore
    AbstractAssetTask .fakeConstructor$();

    external String get name;

    external set name(String v);

    external VoidFunc1<dynamic> get onSuccess;

    external set onSuccess(VoidFunc1<dynamic> v);

    external Function/*(task: any, message?: string, exception?: any) => void*/ get onError;

    external set onError(Function/*(task: any, message?: string, exception?: any) => void*/ v);

    external factory AbstractAssetTask(String name);

    external get JS$_isCompleted;

    external set JS$_isCompleted(v);

    external get JS$_taskState;

    external set JS$_taskState(v);

    external get JS$_errorObject;

    external set JS$_errorObject(v);

    external bool get isCompleted;

    external set isCompleted(bool v);

    external num/*enum AssetTaskState*/ get taskState;

    external set taskState(num/*enum AssetTaskState*/ v);

    external dynamic/*{
            message?: string;
            exception?: any;
        }*/ get errorObject;

    external set errorObject(dynamic/*{
            message?: string;
            exception?: any;
        }*/
    v);

    external void JS$_setErrorObject([String message, dynamic exception]);

    external void run(Scene scene, void onSuccess(), void onError([String message, dynamic exception]));

    external void runTask(Scene scene, void onSuccess(), void onError([String message, dynamic exception]));

    external void reset();

    external get onErrorCallback;

    external set onErrorCallback(v);

    external get onDoneCallback;

    external set onDoneCallback(v);
}

@anonymous
@JS()
abstract class IAssetsProgressEvent {
    external num get remainingCount;

    external set remainingCount(num v);

    external num get totalCount;

    external set totalCount(num v);

    external AbstractAssetTask get task;

    external set task(AbstractAssetTask v);

    external factory IAssetsProgressEvent({ num remainingCount, num totalCount, AbstractAssetTask task});
}

@JS("BABYLON.AssetsProgressEvent")
class AssetsProgressEvent implements IAssetsProgressEvent {
    // @Ignore
    AssetsProgressEvent .fakeConstructor$();

    external num get remainingCount;

    external set remainingCount(num v);

    external num get totalCount;

    external set totalCount(num v);

    external AbstractAssetTask get task;

    external set task(AbstractAssetTask v);

    external factory AssetsProgressEvent(num remainingCount, num totalCount, AbstractAssetTask task);
}

@JS("BABYLON.MeshAssetTask")
class MeshAssetTask extends AbstractAssetTask {
    // @Ignore
    MeshAssetTask .fakeConstructor$() : super.fakeConstructor$();
    external String get name;

    external set name(String v);

    external dynamic get meshesNames;

    external set meshesNames(dynamic v);

    external String get rootUrl;

    external set rootUrl(String v);

    external String get sceneFilename;

    external set sceneFilename(String v);

    external List<AbstractMesh> get loadedMeshes;

    external set loadedMeshes(List<AbstractMesh> v);

    external List<IParticleSystem> get loadedParticleSystems;

    external set loadedParticleSystems(List<IParticleSystem> v);

    external List<Skeleton> get loadedSkeletons;

    external set loadedSkeletons(List<Skeleton> v);

    external VoidFunc1<MeshAssetTask> get onSuccess;

    external set onSuccess(VoidFunc1<MeshAssetTask> v);

    external Function/*(task: MeshAssetTask, message?: string, exception?: any) => void*/ get onError;

    external set onError(Function/*(task: MeshAssetTask, message?: string, exception?: any) => void*/ v);

    external factory MeshAssetTask(String name, dynamic meshesNames, String rootUrl, String sceneFilename);

    external void runTask(Scene scene, void onSuccess(), void onError([String message, dynamic exception]));
}

@JS("BABYLON.TextFileAssetTask")
class TextFileAssetTask extends AbstractAssetTask {
    // @Ignore
    TextFileAssetTask .fakeConstructor$() : super.fakeConstructor$();
    external String get name;

    external set name(String v);

    external String get url;

    external set url(String v);

    external String get text;

    external set text(String v);

    external VoidFunc1<TextFileAssetTask> get onSuccess;

    external set onSuccess(VoidFunc1<TextFileAssetTask> v);

    external Function/*(task: TextFileAssetTask, message?: string, exception?: any) => void*/ get onError;

    external set onError(Function/*(task: TextFileAssetTask, message?: string, exception?: any) => void*/ v);

    external factory TextFileAssetTask(String name, String url);

    external void runTask(Scene scene, void onSuccess(), void onError([String message, dynamic exception]));
}

@JS("BABYLON.BinaryFileAssetTask")
class BinaryFileAssetTask extends AbstractAssetTask {
    // @Ignore
    BinaryFileAssetTask .fakeConstructor$() : super.fakeConstructor$();
    external String get name;

    external set name(String v);

    external String get url;

    external set url(String v);

    external ByteBuffer get data;

    external set data(ByteBuffer v);

    external VoidFunc1<BinaryFileAssetTask> get onSuccess;

    external set onSuccess(VoidFunc1<BinaryFileAssetTask> v);

    external Function/*(task: BinaryFileAssetTask, message?: string, exception?: any) => void*/ get onError;

    external set onError(Function/*(task: BinaryFileAssetTask, message?: string, exception?: any) => void*/ v);

    external factory BinaryFileAssetTask(String name, String url);

    external void runTask(Scene scene, void onSuccess(), void onError([String message, dynamic exception]));
}

@JS("BABYLON.ImageAssetTask")
class ImageAssetTask extends AbstractAssetTask {
    // @Ignore
    ImageAssetTask .fakeConstructor$() : super.fakeConstructor$();
    external String get name;

    external set name(String v);

    external String get url;

    external set url(String v);

    external ImageElement get image;

    external set image(ImageElement v);

    external VoidFunc1<ImageAssetTask> get onSuccess;

    external set onSuccess(VoidFunc1<ImageAssetTask> v);

    external Function/*(task: ImageAssetTask, message?: string, exception?: any) => void*/ get onError;

    external set onError(Function/*(task: ImageAssetTask, message?: string, exception?: any) => void*/ v);

    external factory ImageAssetTask(String name, String url);

    external void runTask(Scene scene, void onSuccess(), void onError([String message, dynamic exception]));
}

@anonymous
@JS()
abstract class ITextureAssetTask<TEX extends BaseTexture> {
    external TEX get texture;

    external set texture(TEX v);

    external factory ITextureAssetTask({ TEX texture});
}

@JS("BABYLON.TextureAssetTask")
class TextureAssetTask extends AbstractAssetTask implements ITextureAssetTask<Texture> {
    // @Ignore
    TextureAssetTask .fakeConstructor$() : super.fakeConstructor$();
    external String get name;

    external set name(String v);

    external String get url;

    external set url(String v);

    external dynamic/*bool|dynamic*/ get noMipmap;

    external set noMipmap(dynamic/*bool|dynamic*/ v);

    external dynamic/*bool|dynamic*/ get invertY;

    external set invertY(dynamic/*bool|dynamic*/ v);

    external num get samplingMode;

    external set samplingMode(num v);

    external Texture get texture;

    external set texture(Texture v);

    external VoidFunc1<TextureAssetTask> get onSuccess;

    external set onSuccess(VoidFunc1<TextureAssetTask> v);

    external Function/*(task: TextureAssetTask, message?: string, exception?: any) => void*/ get onError;

    external set onError(Function/*(task: TextureAssetTask, message?: string, exception?: any) => void*/ v);

    external factory TextureAssetTask(String name, String url, [dynamic/*bool|dynamic*/ noMipmap, dynamic/*bool|dynamic*/ invertY, num samplingMode]);

    external void runTask(Scene scene, void onSuccess(), void onError([String message, dynamic exception]));
}

@JS("BABYLON.CubeTextureAssetTask")
class CubeTextureAssetTask extends AbstractAssetTask implements ITextureAssetTask<CubeTexture> {
    // @Ignore
    CubeTextureAssetTask .fakeConstructor$() : super.fakeConstructor$();
    external String get name;

    external set name(String v);

    external String get url;

    external set url(String v);

    external dynamic/*List<String>|dynamic*/ get extensions;

    external set extensions(dynamic/*List<String>|dynamic*/ v);

    external dynamic/*bool|dynamic*/ get noMipmap;

    external set noMipmap(dynamic/*bool|dynamic*/ v);

    external dynamic/*List<String>|dynamic*/ get files;

    external set files(dynamic/*List<String>|dynamic*/ v);

    external CubeTexture get texture;

    external set texture(CubeTexture v);

    external VoidFunc1<CubeTextureAssetTask> get onSuccess;

    external set onSuccess(VoidFunc1<CubeTextureAssetTask> v);

    external Function/*(task: CubeTextureAssetTask, message?: string, exception?: any) => void*/ get onError;

    external set onError(Function/*(task: CubeTextureAssetTask, message?: string, exception?: any) => void*/ v);

    external factory CubeTextureAssetTask(String name, String url, [dynamic/*List<String>|dynamic*/ extensions, dynamic/*bool|dynamic*/ noMipmap, dynamic/*List<String>|dynamic*/ files]);

    external void runTask(Scene scene, void onSuccess(), void onError([String message, dynamic exception]));
}

@JS("BABYLON.HDRCubeTextureAssetTask")
class HDRCubeTextureAssetTask extends AbstractAssetTask implements ITextureAssetTask<HDRCubeTexture> {
    // @Ignore
    HDRCubeTextureAssetTask .fakeConstructor$() : super.fakeConstructor$();
    external String get name;

    external set name(String v);

    external String get url;

    external set url(String v);

    external num get size;

    external set size(num v);

    external bool get noMipmap;

    external set noMipmap(bool v);

    external bool get generateHarmonics;

    external set generateHarmonics(bool v);

    external bool get gammaSpace;

    external set gammaSpace(bool v);

    external bool get reserved;

    external set reserved(bool v);

    external HDRCubeTexture get texture;

    external set texture(HDRCubeTexture v);

    external VoidFunc1<HDRCubeTextureAssetTask> get onSuccess;

    external set onSuccess(VoidFunc1<HDRCubeTextureAssetTask> v);

    external Function/*(task: HDRCubeTextureAssetTask, message?: string, exception?: any) => void*/ get onError;

    external set onError(Function/*(task: HDRCubeTextureAssetTask, message?: string, exception?: any) => void*/ v);

    external factory HDRCubeTextureAssetTask(String name, String url, num size, [bool noMipmap, bool generateHarmonics, bool gammaSpace, bool reserved]);

    external void run(Scene scene, void onSuccess(), void onError([String message, dynamic exception]));
}

@JS("BABYLON.AssetsManager")
class AssetsManager {
    // @Ignore
    AssetsManager .fakeConstructor$();

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_isLoading;

    external set JS$_isLoading(v);

    external List<AbstractAssetTask> get JS$_tasks;

    external set JS$_tasks(List<AbstractAssetTask> v);

    external num get JS$_waitingTasksCount;

    external set JS$_waitingTasksCount(num v);

    external num get JS$_totalTasksCount;

    external set JS$_totalTasksCount(num v);

    external VoidFunc1<List<AbstractAssetTask>> get onFinish;

    external set onFinish(VoidFunc1<List<AbstractAssetTask>> v);

    external VoidFunc1<AbstractAssetTask> get onTaskSuccess;

    external set onTaskSuccess(VoidFunc1<AbstractAssetTask> v);

    external VoidFunc1<AbstractAssetTask> get onTaskError;

    external set onTaskError(VoidFunc1<AbstractAssetTask> v);

    external VoidFunc3<num, num, AbstractAssetTask> get onProgress;

    external set onProgress(VoidFunc3<num, num, AbstractAssetTask> v);

    external Observable<AbstractAssetTask> get onTaskSuccessObservable;

    external set onTaskSuccessObservable(Observable<AbstractAssetTask> v);

    external Observable<AbstractAssetTask> get onTaskErrorObservable;

    external set onTaskErrorObservable(Observable<AbstractAssetTask> v);

    external Observable<List<AbstractAssetTask>> get onTasksDoneObservable;

    external set onTasksDoneObservable(Observable<List<AbstractAssetTask>> v);

    external Observable<IAssetsProgressEvent> get onProgressObservable;

    external set onProgressObservable(Observable<IAssetsProgressEvent> v);

    external bool get useDefaultLoadingScreen;

    external set useDefaultLoadingScreen(bool v);

    external factory AssetsManager(Scene scene);

    external MeshAssetTask addMeshTask(String taskName, dynamic meshesNames, String rootUrl, String sceneFilename);

    external TextFileAssetTask addTextFileTask(String taskName, String url);

    external BinaryFileAssetTask addBinaryFileTask(String taskName, String url);

    external ImageAssetTask addImageTask(String taskName, String url);

    external TextureAssetTask addTextureTask(String taskName, String url, [bool noMipmap, bool invertY, num samplingMode]);

    external CubeTextureAssetTask addCubeTextureTask(String taskName, String url, [List<String> extensions, bool noMipmap, List<String> files]);

    external HDRCubeTextureAssetTask addHDRCubeTextureTask(String taskName, String url, num size, [bool noMipmap, bool generateHarmonics, bool gammaSpace, bool reserved]);

    external void removeTask(AbstractAssetTask task);

    external get JS$_decreaseWaitingTasksCount;

    external set JS$_decreaseWaitingTasksCount(v);

    external get JS$_runTask;

    external set JS$_runTask(v);

    external AssetsManager reset();

    external AssetsManager load();
}

@JS("BABYLON.Database")
class Database {
    // @Ignore
    Database .fakeConstructor$();

    external get callbackManifestChecked;

    external set callbackManifestChecked(v);

    external get currentSceneUrl;

    external set currentSceneUrl(v);

    external get db;

    external set db(v);

    external get JS$_enableSceneOffline;

    external set JS$_enableSceneOffline(v);

    external get JS$_enableTexturesOffline;

    external set JS$_enableTexturesOffline(v);

    external get manifestVersionFound;

    external set manifestVersionFound(v);

    external get mustUpdateRessources;

    external set mustUpdateRessources(v);

    external get hasReachedQuota;

    external set hasReachedQuota(v);

    external get isSupported;

    external set isSupported(v);

    external get idbFactory;

    external set idbFactory(v);

    external static bool get IsUASupportingBlobStorage;

    external static set IsUASupportingBlobStorage(bool v);

    external static bool get IDBStorageEnabled;

    external static set IDBStorageEnabled(bool v);

    external bool get enableSceneOffline;

    external set enableSceneOffline(bool v);

    external bool get enableTexturesOffline;

    external set enableTexturesOffline(bool v);

    external factory Database(String urlToScene, dynamic callbackManifestChecked(bool checked), [bool disableManifestCheck]);

    external static get JS$_ParseURL;

    external static set JS$_ParseURL(v);

    external static get JS$_ReturnFullUrlLocation;

    external static set JS$_ReturnFullUrlLocation(v);

    external get JS$_checkManifestFile;

    external set JS$_checkManifestFile(v);

    external void openAsync(void successCallback(), void errorCallback());

    external void loadImageFromDB(String url, ImageElement image);

    external get JS$_loadImageFromDBAsync;

    external set JS$_loadImageFromDBAsync(v);

    external get JS$_saveImageIntoDBAsync;

    external set JS$_saveImageIntoDBAsync(v);

    external get JS$_checkVersionFromDB;

    external set JS$_checkVersionFromDB(v);

    external get JS$_loadVersionFromDBAsync;

    external set JS$_loadVersionFromDBAsync(v);

    external get JS$_saveVersionIntoDBAsync;

    external set JS$_saveVersionIntoDBAsync(v);

    external void loadFileFromDB(String url, void sceneLoaded(dynamic data), [void progressCallBack(dynamic data), void errorCallback(), bool useArrayBuffer]);

    external get JS$_loadFileFromDBAsync;

    external set JS$_loadFileFromDBAsync(v);

    external get JS$_saveFileIntoDBAsync;

    external set JS$_saveFileIntoDBAsync(v);
}

@anonymous
@JS()
abstract class DDSInfo {
    external num get width;

    external set width(num v);

    external num get height;

    external set height(num v);

    external num get mipmapCount;

    external set mipmapCount(num v);

    external bool get isFourCC;

    external set isFourCC(bool v);

    external bool get isRGB;

    external set isRGB(bool v);

    external bool get isLuminance;

    external set isLuminance(bool v);

    external bool get isCube;

    external set isCube(bool v);

    external bool get isCompressed;

    external set isCompressed(bool v);

    external num get dxgiFormat;

    external set dxgiFormat(num v);

    external num get textureType;

    external set textureType(num v);

    external SphericalPolynomial get sphericalPolynomial;

    external set sphericalPolynomial(SphericalPolynomial v);

    external factory DDSInfo({ num width, num height, num mipmapCount, bool isFourCC, bool isRGB, bool isLuminance, bool isCube, bool isCompressed, num dxgiFormat, num textureType, SphericalPolynomial sphericalPolynomial});
}

@JS("BABYLON.DDSTools")
class DDSTools {
    // @Ignore
    DDSTools .fakeConstructor$();

    external static bool get StoreLODInAlphaChannel;

    external static set StoreLODInAlphaChannel(bool v);

    external static DDSInfo GetDDSInfo(dynamic arrayBuffer);

    external static get JS$_FloatView;

    external static set JS$_FloatView(v);

    external static get JS$_Int32View;

    external static set JS$_Int32View(v);

    external static get JS$_ToHalfFloat;

    external static set JS$_ToHalfFloat(v);

    external static get JS$_FromHalfFloat;

    external static set JS$_FromHalfFloat(v);

    external static get JS$_GetHalfFloatAsFloatRGBAArrayBuffer;

    external static set JS$_GetHalfFloatAsFloatRGBAArrayBuffer(v);

    external static get JS$_GetHalfFloatRGBAArrayBuffer;

    external static set JS$_GetHalfFloatRGBAArrayBuffer(v);

    external static get JS$_GetFloatRGBAArrayBuffer;

    external static set JS$_GetFloatRGBAArrayBuffer(v);

    external static get JS$_GetFloatAsUIntRGBAArrayBuffer;

    external static set JS$_GetFloatAsUIntRGBAArrayBuffer(v);

    external static get JS$_GetHalfFloatAsUIntRGBAArrayBuffer;

    external static set JS$_GetHalfFloatAsUIntRGBAArrayBuffer(v);

    external static get JS$_GetRGBAArrayBuffer;

    external static set JS$_GetRGBAArrayBuffer(v);

    external static get JS$_ExtractLongWordOrder;

    external static set JS$_ExtractLongWordOrder(v);

    external static get JS$_GetRGBArrayBuffer;

    external static set JS$_GetRGBArrayBuffer(v);

    external static get JS$_GetLuminanceArrayBuffer;

    external static set JS$_GetLuminanceArrayBuffer(v);

    external static void UploadDDSLevels(Engine engine, InternalTexture texture, dynamic arrayBuffer, DDSInfo info, bool loadMipmaps, num faces, [num lodIndex, num currentFace]);
}

@JS("BABYLON.expandToProperty")
external VoidFunc2<dynamic, String> expandToProperty(String callback, [String/*String|Null*/ targetKey]);

@JS("BABYLON.serialize")
external VoidFunc2<dynamic, dynamic /*String|dynamic*/> serialize([String sourceName]);

@JS("BABYLON.serializeAsTexture")
external VoidFunc2<dynamic, dynamic /*String|dynamic*/> serializeAsTexture([String sourceName]);

@JS("BABYLON.serializeAsColor3")
external VoidFunc2<dynamic, dynamic /*String|dynamic*/> serializeAsColor3([String sourceName]);

@JS("BABYLON.serializeAsFresnelParameters")
external VoidFunc2<dynamic, dynamic /*String|dynamic*/> serializeAsFresnelParameters([String sourceName]);

@JS("BABYLON.serializeAsVector2")
external VoidFunc2<dynamic, dynamic /*String|dynamic*/> serializeAsVector2([String sourceName]);

@JS("BABYLON.serializeAsVector3")
external VoidFunc2<dynamic, dynamic /*String|dynamic*/> serializeAsVector3([String sourceName]);

@JS("BABYLON.serializeAsMeshReference")
external VoidFunc2<dynamic, dynamic /*String|dynamic*/> serializeAsMeshReference([String sourceName]);

@JS("BABYLON.serializeAsColorCurves")
external VoidFunc2<dynamic, dynamic /*String|dynamic*/> serializeAsColorCurves([String sourceName]);

@JS("BABYLON.serializeAsColor4")
external VoidFunc2<dynamic, dynamic /*String|dynamic*/> serializeAsColor4([String sourceName]);

@JS("BABYLON.serializeAsImageProcessingConfiguration")
external VoidFunc2<dynamic, dynamic /*String|dynamic*/> serializeAsImageProcessingConfiguration([String sourceName]);

@JS("BABYLON.serializeAsQuaternion")
external VoidFunc2<dynamic, dynamic /*String|dynamic*/> serializeAsQuaternion([String sourceName]);

@JS("BABYLON.serializeAsCameraReference")
external VoidFunc2<dynamic, dynamic /*String|dynamic*/> serializeAsCameraReference([String sourceName]);

@JS("BABYLON.SerializationHelper")
class SerializationHelper {
    // @Ignore
    SerializationHelper .fakeConstructor$();

    external static dynamic Serialize /*<T>*/(dynamic/*=T*/ entity, [dynamic serializationObject]);

    external static dynamic/*=T*/ Parse /*<T>*/(dynamic/*=T*/ creationFunction(), dynamic source, Scene/*Scene|Null*/ scene, [String/*String|Null*/ rootUrl]);

    external static dynamic/*=T*/ Clone /*<T>*/(dynamic/*=T*/ creationFunction(), dynamic/*=T*/ source);

    external static dynamic/*=T*/ Instanciate /*<T>*/(dynamic/*=T*/ creationFunction(), dynamic/*=T*/ source);
}

@JS("BABYLON.Deferred")
class Deferred<T> {
    // @Ignore
    Deferred .fakeConstructor$();

    external Promise<T> get promise;

    external set promise(Promise<T> v);

    external get JS$_resolve;

    external set JS$_resolve(v);

    external get JS$_reject;

    external set JS$_reject(v);

    external VoidFunc1Opt1<dynamic /*T|PromiseLike<T>|dynamic*/> get resolve;

    external set resolve(VoidFunc1Opt1<dynamic /*T|PromiseLike<T>|dynamic*/> v);

    external VoidFunc1Opt1<dynamic> get reject;

    external set reject(VoidFunc1Opt1<dynamic> v);

    external factory Deferred();
}

@anonymous
@JS()
abstract class EnvironmentTextureInfo {
    external num get version;

    external set version(num v);

    external num get width;

    external set width(num v);

    external dynamic get irradiance;

    external set irradiance(dynamic v);

    external dynamic get specular;

    external set specular(dynamic v);

    external factory EnvironmentTextureInfo({ num version, num width, dynamic irradiance, dynamic specular});
}

@JS("BABYLON.EnvironmentTextureTools")
class EnvironmentTextureTools {
    // @Ignore
    EnvironmentTextureTools .fakeConstructor$();

    external static get JS$_MagicBytes;

    external static set JS$_MagicBytes(v);

    external static EnvironmentTextureInfo/*EnvironmentTextureInfo|Null*/ GetEnvInfo(ByteBuffer data);

    external static Promise<ByteBuffer> CreateEnvTextureAsync(CubeTexture texture);

    external static get JS$_CreateEnvTextureIrradiance;

    external static set JS$_CreateEnvTextureIrradiance(v);

    external static Promise<Null> UploadEnvLevelsAsync(InternalTexture texture, dynamic arrayBuffer, EnvironmentTextureInfo info);

    external static Promise<Null> UploadLevelsAsync(InternalTexture texture, List<List<TypedData>> imageData);

    external static void UploadEnvSpherical(InternalTexture texture, EnvironmentTextureInfo info);
}

@JS("BABYLON.FilesInput")
class FilesInput {
    // @Ignore
    FilesInput .fakeConstructor$();

    external static dynamic/*JSMap of <String,File>*/ get FilesToLoad;

    external static set FilesToLoad(dynamic/*JSMap of <String,File>*/ v);

    external Func3<File,String,String,Null> get onProcessFileCallback;

    external set onProcessFileCallback(Func3<File,String,String,Null> v);

    external get JS$_engine;

    external set JS$_engine(v);

    external get JS$_currentScene;

    external set JS$_currentScene(v);

    external get JS$_sceneLoadedCallback;

    external set JS$_sceneLoadedCallback(v);

    external get JS$_progressCallback;

    external set JS$_progressCallback(v);

    external get JS$_additionalRenderLoopLogicCallback;

    external set JS$_additionalRenderLoopLogicCallback(v);

    external get JS$_textureLoadingCallback;

    external set JS$_textureLoadingCallback(v);

    external get JS$_startingProcessingFilesCallback;

    external set JS$_startingProcessingFilesCallback(v);

    external get JS$_onReloadCallback;

    external set JS$_onReloadCallback(v);

    external get JS$_errorCallback;

    external set JS$_errorCallback(v);

    external get JS$_elementToMonitor;

    external set JS$_elementToMonitor(v);

    external get JS$_sceneFileToLoad;

    external set JS$_sceneFileToLoad(v);

    external get JS$_filesToLoad;

    external set JS$_filesToLoad(v);

    external factory FilesInput(Engine engine, Scene scene, void sceneLoadedCallback(File sceneFile, Scene scene), void progressCallback(SceneLoaderProgressEvent progress), void additionalRenderLoopLogicCallback(), void textureLoadingCallback(num remaining), void startingProcessingFilesCallback([List<File> files]), void onReloadCallback(File sceneFile), void errorCallback(File sceneFile, Scene scene, String message));

    external get JS$_dragEnterHandler;

    external set JS$_dragEnterHandler(v);

    external get JS$_dragOverHandler;

    external set JS$_dragOverHandler(v);

    external get JS$_dropHandler;

    external set JS$_dropHandler(v);

    external void monitorElementForDragNDrop(HtmlElement elementToMonitor);

    external void dispose();

    external get renderFunction;

    external set renderFunction(v);

    external get drag;

    external set drag(v);

    external get drop;

    external set drop(v);

    external get JS$_traverseFolder;

    external set JS$_traverseFolder(v);

    external get JS$_processFiles;

    external set JS$_processFiles(v);

    external void loadFiles(dynamic event);

    external get JS$_processReload;

    external set JS$_processReload(v);

    external void reload();
}

@JS("BABYLON.KhronosTextureContainer")
class KhronosTextureContainer {
    // @Ignore
    KhronosTextureContainer .fakeConstructor$();

    external dynamic get arrayBuffer;

    external set arrayBuffer(dynamic v);

    external static get HEADER_LEN;

    external static set HEADER_LEN(v);

    external static get COMPRESSED_2D;

    external static set COMPRESSED_2D(v);

    external static get COMPRESSED_3D;

    external static set COMPRESSED_3D(v);

    external static get TEX_2D;

    external static set TEX_2D(v);

    external static get TEX_3D;

    external static set TEX_3D(v);

    external num get glType;

    external set glType(num v);

    external num get glTypeSize;

    external set glTypeSize(num v);

    external num get glFormat;

    external set glFormat(num v);

    external num get glInternalFormat;

    external set glInternalFormat(num v);

    external num get glBaseInternalFormat;

    external set glBaseInternalFormat(num v);

    external num get pixelWidth;

    external set pixelWidth(num v);

    external num get pixelHeight;

    external set pixelHeight(num v);

    external num get pixelDepth;

    external set pixelDepth(num v);

    external num get numberOfArrayElements;

    external set numberOfArrayElements(num v);

    external num get numberOfFaces;

    external set numberOfFaces(num v);

    external num get numberOfMipmapLevels;

    external set numberOfMipmapLevels(num v);

    external num get bytesOfKeyValueData;

    external set bytesOfKeyValueData(num v);

    external num get loadType;

    external set loadType(num v);

    external factory KhronosTextureContainer(dynamic arrayBuffer, num facesExpected, [bool threeDExpected, bool textureArrayExpected]);

    external num switchEndianness(num val);

    external void uploadLevels(InternalTexture texture, bool loadMipmaps);

    external get JS$_upload2DCompressedLevels;

    external set JS$_upload2DCompressedLevels(v);
}

@JS("BABYLON.EventState")
class EventState {
    // @Ignore
    EventState .fakeConstructor$();

    external factory EventState(num mask, [bool skipNextObservers, dynamic target, dynamic currentTarget]);

    external EventState initalize(num mask, [bool skipNextObservers, dynamic target, dynamic currentTarget]);

    external bool get skipNextObservers;

    external set skipNextObservers(bool v);

    external num get mask;

    external set mask(num v);

    external dynamic get target;

    external set target(dynamic v);

    external dynamic get currentTarget;

    external set currentTarget(dynamic v);

    external dynamic get lastReturnValue;

    external set lastReturnValue(dynamic v);
}

@JS("BABYLON.Observer")
class Observer<T> {
    // @Ignore
    Observer .fakeConstructor$();

    external VoidFunc2<T, EventState> get callback;

    external set callback(VoidFunc2<T, EventState> v);

    external num get mask;

    external set mask(num v);

    external dynamic get scope;

    external set scope(dynamic v);

    external bool get JS$_willBeUnregistered;

    external set JS$_willBeUnregistered(bool v);

    external bool get unregisterOnNextCall;

    external set unregisterOnNextCall(bool v);

    external factory Observer(void callback(T eventData, EventState eventState), num mask, [dynamic scope]);
}

@JS("BABYLON.MultiObserver")
class MultiObserver<T> {
    // @Ignore
    MultiObserver .fakeConstructor$();

    external get JS$_observers;

    external set JS$_observers(v);

    external get JS$_observables;

    external set JS$_observables(v);

    external void dispose();

    external static MultiObserver<dynamic /*=T*/> Watch /*<T>*/(List<Observable<dynamic /*=T*/>> observables, void callback(dynamic/*=T*/ eventData, EventState eventState), [num mask, dynamic scope]);
}

@JS("BABYLON.Observable")
class Observable<T> {
    // @Ignore
    Observable .fakeConstructor$();

    external get JS$_observers;

    external set JS$_observers(v);

    external get JS$_eventState;

    external set JS$_eventState(v);

    external get JS$_onObserverAdded;

    external set JS$_onObserverAdded(v);

    external factory Observable([void onObserverAdded(Observer<T> observer)]);

    external Observer<T>/*Observer<T>|Null*/ add(void callback(T eventData, EventState eventState), [num mask, bool insertFirst, dynamic scope, bool unregisterOnFirstCall]);

    external Observer<T>/*Observer<T>|Null*/ addOnce(void callback(T eventData, EventState eventState));

    external bool remove(Observer<T>/*Observer<T>|Null*/ observer);

    external bool removeCallback(void callback(T eventData, EventState eventState), [dynamic scope]);

    external get JS$_deferUnregister;

    external set JS$_deferUnregister(v);

    external get JS$_remove;

    external set JS$_remove(v);

    external bool notifyObservers(T eventData, [num mask, dynamic target, dynamic currentTarget]);

    external Promise<T> notifyObserversWithPromise(T eventData, [num mask, dynamic target, dynamic currentTarget]);

    external void notifyObserver(Observer<T> observer, T eventData, [num mask]);

    external bool hasObservers();

    external void clear();

    external Observable<T> clone();

    external bool hasSpecificMask([num mask]);
}

@JS("BABYLON.PerformanceMonitor")
class PerformanceMonitor {
    // @Ignore
    PerformanceMonitor .fakeConstructor$();

    external get JS$_enabled;

    external set JS$_enabled(v);

    external get JS$_rollingFrameTime;

    external set JS$_rollingFrameTime(v);

    external get JS$_lastFrameTimeMs;

    external set JS$_lastFrameTimeMs(v);

    external factory PerformanceMonitor([num frameSampleSize]);

    external void sampleFrame([num timeMs]);

    external num get averageFrameTime;

    external set averageFrameTime(num v);

    external num get averageFrameTimeVariance;

    external set averageFrameTimeVariance(num v);

    external num get instantaneousFrameTime;

    external set instantaneousFrameTime(num v);

    external num get averageFPS;

    external set averageFPS(num v);

    external num get instantaneousFPS;

    external set instantaneousFPS(num v);

    external bool get isSaturated;

    external set isSaturated(bool v);

    external void enable();

    external void disable();

    external bool get isEnabled;

    external set isEnabled(bool v);

    external void reset();
}

@JS("BABYLON.RollingAverage")
class RollingAverage {
    // @Ignore
    RollingAverage .fakeConstructor$();

    external num get average;

    external set average(num v);

    external num get variance;

    external set variance(num v);

    external List<num> get JS$_samples;

    external set JS$_samples(List<num> v);

    external num get JS$_sampleCount;

    external set JS$_sampleCount(num v);

    external num get JS$_pos;

    external set JS$_pos(num v);

    external num get JS$_m2;

    external set JS$_m2(num v);

    external factory RollingAverage(num length);

    external void add(num v);

    external num history(num i);

    external bool isSaturated();

    external void reset();

    external num JS$_wrapPosition(num i);
}

@JS("BABYLON.PromisePolyfill")
class PromisePolyfill {
    // @Ignore
    PromisePolyfill .fakeConstructor$();

    external static void Apply([bool force]);
}

@JS("BABYLON.SceneOptimization")
class SceneOptimization {
    // @Ignore
    SceneOptimization .fakeConstructor$();

    external num get priority;

    external set priority(num v);

    external String getDescription();

    external bool apply(Scene scene, SceneOptimizer optimizer);

    external factory SceneOptimization([num priority]);
}

@JS("BABYLON.TextureOptimization")
class TextureOptimization extends SceneOptimization {
    // @Ignore
    TextureOptimization .fakeConstructor$() : super.fakeConstructor$();
    external num get priority;

    external set priority(num v);

    external num get maximumSize;

    external set maximumSize(num v);

    external num get step;

    external set step(num v);

    external String getDescription();

    external factory TextureOptimization([num priority, num maximumSize, num step]);

    external bool apply(Scene scene, SceneOptimizer optimizer);
}

@JS("BABYLON.HardwareScalingOptimization")
class HardwareScalingOptimization extends SceneOptimization {
    // @Ignore
    HardwareScalingOptimization .fakeConstructor$() : super.fakeConstructor$();
    external num get priority;

    external set priority(num v);

    external num get maximumScale;

    external set maximumScale(num v);

    external num get step;

    external set step(num v);

    external get JS$_currentScale;

    external set JS$_currentScale(v);

    external get JS$_directionOffset;

    external set JS$_directionOffset(v);

    external String getDescription();

    external factory HardwareScalingOptimization([num priority, num maximumScale, num step]);

    external bool apply(Scene scene, SceneOptimizer optimizer);
}

@JS("BABYLON.ShadowsOptimization")
class ShadowsOptimization extends SceneOptimization {
    // @Ignore
    ShadowsOptimization .fakeConstructor$() : super.fakeConstructor$();
    external String getDescription();

    external bool apply(Scene scene, SceneOptimizer optimizer);
}

@JS("BABYLON.PostProcessesOptimization")
class PostProcessesOptimization extends SceneOptimization {
    // @Ignore
    PostProcessesOptimization .fakeConstructor$() : super.fakeConstructor$();
    external String getDescription();

    external bool apply(Scene scene, SceneOptimizer optimizer);
}

@JS("BABYLON.LensFlaresOptimization")
class LensFlaresOptimization extends SceneOptimization {
    // @Ignore
    LensFlaresOptimization .fakeConstructor$() : super.fakeConstructor$();
    external String getDescription();

    external bool apply(Scene scene, SceneOptimizer optimizer);
}

@JS("BABYLON.CustomOptimization")
class CustomOptimization extends SceneOptimization {
    // @Ignore
    CustomOptimization .fakeConstructor$() : super.fakeConstructor$();
    external Func2<Scene, SceneOptimizer, bool> get onApply;

    external set onApply(Func2<Scene, SceneOptimizer, bool> v);

    external Func0<String> get onGetDescription;

    external set onGetDescription(Func0<String> v);

    external String getDescription();

    external bool apply(Scene scene, SceneOptimizer optimizer);
}

@JS("BABYLON.ParticlesOptimization")
class ParticlesOptimization extends SceneOptimization {
    // @Ignore
    ParticlesOptimization .fakeConstructor$() : super.fakeConstructor$();
    external String getDescription();

    external bool apply(Scene scene, SceneOptimizer optimizer);
}

@JS("BABYLON.RenderTargetsOptimization")
class RenderTargetsOptimization extends SceneOptimization {
    // @Ignore
    RenderTargetsOptimization .fakeConstructor$() : super.fakeConstructor$();
    external String getDescription();

    external bool apply(Scene scene, SceneOptimizer optimizer);
}

@JS("BABYLON.MergeMeshesOptimization")
class MergeMeshesOptimization extends SceneOptimization {
    // @Ignore
    MergeMeshesOptimization .fakeConstructor$() : super.fakeConstructor$();
    external static get JS$_UpdateSelectionTree;

    external static set JS$_UpdateSelectionTree(v);

    external static bool get UpdateSelectionTree;

    external static set UpdateSelectionTree(bool v);

    external String getDescription();

    external get JS$_canBeMerged;

    external set JS$_canBeMerged(v);

    external bool apply(Scene scene, SceneOptimizer optimizer, [bool updateSelectionTree]);
}

@JS("BABYLON.SceneOptimizerOptions")
class SceneOptimizerOptions {
    // @Ignore
    SceneOptimizerOptions .fakeConstructor$();

    external num get targetFrameRate;

    external set targetFrameRate(num v);

    external num get trackerDuration;

    external set trackerDuration(num v);

    external List<SceneOptimization> get optimizations;

    external set optimizations(List<SceneOptimization> v);

    external factory SceneOptimizerOptions([num targetFrameRate, num trackerDuration]);

    external SceneOptimizerOptions addOptimization(SceneOptimization optimization);

    external SceneOptimizerOptions addCustomOptimization(bool onApply(Scene scene), String onGetDescription(), [num priority]);

    external static SceneOptimizerOptions LowDegradationAllowed([num targetFrameRate]);

    external static SceneOptimizerOptions ModerateDegradationAllowed([num targetFrameRate]);

    external static SceneOptimizerOptions HighDegradationAllowed([num targetFrameRate]);
}

@JS("BABYLON.SceneOptimizer")
class SceneOptimizer implements IDisposable {
    // @Ignore
    SceneOptimizer .fakeConstructor$();

    external get JS$_isRunning;

    external set JS$_isRunning(v);

    external get JS$_options;

    external set JS$_options(v);

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_currentPriorityLevel;

    external set JS$_currentPriorityLevel(v);

    external get JS$_targetFrameRate;

    external set JS$_targetFrameRate(v);

    external get JS$_trackerDuration;

    external set JS$_trackerDuration(v);

    external get JS$_currentFrameRate;

    external set JS$_currentFrameRate(v);

    external get JS$_sceneDisposeObserver;

    external set JS$_sceneDisposeObserver(v);

    external get JS$_improvementMode;

    external set JS$_improvementMode(v);

    external Observable<SceneOptimizer> get onSuccessObservable;

    external set onSuccessObservable(Observable<SceneOptimizer> v);

    external Observable<SceneOptimization> get onNewOptimizationAppliedObservable;

    external set onNewOptimizationAppliedObservable(Observable<SceneOptimization> v);

    external Observable<SceneOptimizer> get onFailureObservable;

    external set onFailureObservable(Observable<SceneOptimizer> v);

    external bool get isInImprovementMode;

    external set isInImprovementMode(bool v);

    external num get currentPriorityLevel;

    external set currentPriorityLevel(num v);

    external num get currentFrameRate;

    external set currentFrameRate(num v);

    external num get targetFrameRate;

    external set targetFrameRate(num v);

    external num get trackerDuration;

    external set trackerDuration(num v);

    external List<SceneOptimization> get optimizations;

    external set optimizations(List<SceneOptimization> v);

    external factory SceneOptimizer(Scene scene, [SceneOptimizerOptions options, bool autoGeneratePriorities, bool improvementMode]);

    external void stop();

    external void reset();

    external void start();

    external get JS$_checkCurrentState;

    external set JS$_checkCurrentState(v);

    external void dispose();

    external static SceneOptimizer OptimizeAsync(Scene scene, [SceneOptimizerOptions options, void onSuccess(), void onFailure()]);
}

@JS("BABYLON.SceneSerializer")
class SceneSerializer {
    // @Ignore
    SceneSerializer .fakeConstructor$();

    external static void ClearCache();

    external static dynamic Serialize(Scene scene);

    external static dynamic SerializeMesh(dynamic toSerialize, [bool withParents, bool withChildren]);
}

@anonymous
@JS()
abstract class ISmartArrayLike<T> {
    external List<T> get data;

    external set data(List<T> v);

    external num get length;

    external set length(num v);

    external factory ISmartArrayLike({ List<T> data, num length});
}

@JS("BABYLON.SmartArray")
class SmartArray<T> implements ISmartArrayLike<T> {
    // @Ignore
    SmartArray .fakeConstructor$();

    external List<T> get data;

    external set data(List<T> v);

    external num get length;

    external set length(num v);

    external num get JS$_id;

    external set JS$_id(num v);

    external factory SmartArray(num capacity);

    external void push(T value);

    external void forEach(void func(T content));

    external void sort(num compareFn(T a, T b));

    external void reset();

    external void dispose();

    external void concat(dynamic array);

    external num indexOf(T value);

    external bool contains(T value);

    external static get JS$_GlobalId;

    external static set JS$_GlobalId(v);
}

@JS("BABYLON.SmartArrayNoDuplicate")
class SmartArrayNoDuplicate<T> extends SmartArray<T> {
    // @Ignore
    SmartArrayNoDuplicate .fakeConstructor$() : super.fakeConstructor$();
    external get JS$_duplicateId;

    external set JS$_duplicateId(v);

    external void push(T value);

    external bool pushNoDuplicate(T value);

    external void reset();

    external void concatWithNoDuplicate(dynamic array);
}

@JS("BABYLON.StringDictionary")
class StringDictionary<T> {
    // @Ignore
    StringDictionary .fakeConstructor$();

    external void copyFrom(StringDictionary<T> source);

    external dynamic/*T|dynamic*/ JS$get(String key);

    external T getOrAddWithFactory(String key, T JS$factory(String key));

    external T getOrAdd(String key, T val);

    external bool contains(String key);

    external bool add(String key, T value);

    external bool JS$set(String key, T value);

    external T/*T|Null*/ getAndRemove(String key);

    external bool remove(String key);

    external void clear();

    external num get count;

    external set count(num v);

    external void forEach(void callback(String key, T val));

    external dynamic/*TRes|Null*/ first /*<TRes>*/(dynamic/*=TRes*/ callback(String key, T val));

    external get JS$_count;

    external set JS$_count(v);

    external get JS$_data;

    external set JS$_data(v);
}

@JS("BABYLON.Tags")
class Tags {
    // @Ignore
    Tags .fakeConstructor$();

    external static void EnableFor(dynamic obj);

    external static void DisableFor(dynamic obj);

    external static bool HasTags(dynamic obj);

    external static dynamic GetTags(dynamic obj, [bool asString]);

    external static void AddTagsTo(dynamic obj, String tagsString);

    external static void JS$_AddTagTo(dynamic obj, String tag);

    external static void RemoveTagsFrom(dynamic obj, String tagsString);

    external static void JS$_RemoveTagFrom(dynamic obj, String tag);

    external static bool MatchesQuery(dynamic obj, String tagsQuery);
}

@JS("BABYLON.TextureTools")
class TextureTools {
    // @Ignore
    TextureTools .fakeConstructor$();

    external static Texture CreateResizedCopy(Texture texture, num width, num height, [bool useBilinearMode]);

    external static BaseTexture GetEnvironmentBRDFTexture(Scene scene);

    external static get JS$_environmentBRDFBase64Texture;

    external static set JS$_environmentBRDFBase64Texture(v);
}

@JS("BABYLON.TGATools")
class TGATools {
    // @Ignore
    TGATools .fakeConstructor$();

    external static get JS$_TYPE_INDEXED;

    external static set JS$_TYPE_INDEXED(v);

    external static get JS$_TYPE_RGB;

    external static set JS$_TYPE_RGB(v);

    external static get JS$_TYPE_GREY;

    external static set JS$_TYPE_GREY(v);

    external static get JS$_TYPE_RLE_INDEXED;

    external static set JS$_TYPE_RLE_INDEXED(v);

    external static get JS$_TYPE_RLE_RGB;

    external static set JS$_TYPE_RLE_RGB(v);

    external static get JS$_TYPE_RLE_GREY;

    external static set JS$_TYPE_RLE_GREY(v);

    external static get JS$_ORIGIN_MASK;

    external static set JS$_ORIGIN_MASK(v);

    external static get JS$_ORIGIN_SHIFT;

    external static set JS$_ORIGIN_SHIFT(v);

    external static get JS$_ORIGIN_BL;

    external static set JS$_ORIGIN_BL(v);

    external static get JS$_ORIGIN_BR;

    external static set JS$_ORIGIN_BR(v);

    external static get JS$_ORIGIN_UL;

    external static set JS$_ORIGIN_UL(v);

    external static get JS$_ORIGIN_UR;

    external static set JS$_ORIGIN_UR(v);

    external static dynamic GetTGAHeader(Uint8List data);

    external static void UploadContent(InternalTexture texture, Uint8List data);

    external static Uint8List JS$_getImageData8bits(dynamic header, Uint8List palettes, Uint8List pixel_data, num y_start, num y_step, num y_end, num x_start, num x_step, num x_end);

    external static Uint8List JS$_getImageData16bits(dynamic header, Uint8List palettes, Uint8List pixel_data, num y_start, num y_step, num y_end, num x_start, num x_step, num x_end);

    external static Uint8List JS$_getImageData24bits(dynamic header, Uint8List palettes, Uint8List pixel_data, num y_start, num y_step, num y_end, num x_start, num x_step, num x_end);

    external static Uint8List JS$_getImageData32bits(dynamic header, Uint8List palettes, Uint8List pixel_data, num y_start, num y_step, num y_end, num x_start, num x_step, num x_end);

    external static Uint8List JS$_getImageDataGrey8bits(dynamic header, Uint8List palettes, Uint8List pixel_data, num y_start, num y_step, num y_end, num x_start, num x_step, num x_end);

    external static Uint8List JS$_getImageDataGrey16bits(dynamic header, Uint8List palettes, Uint8List pixel_data, num y_start, num y_step, num y_end, num x_start, num x_step, num x_end);
}

@anonymous
@JS()
abstract class IAnimatable {
    external List<Animation> get animations;

    external set animations(List<Animation> v);

    external factory IAnimatable({ List<Animation> animations});
}

@anonymous
@JS()
abstract class IValueGradient {
    external num get gradient;

    external set gradient(num v);

    external factory IValueGradient({ num gradient});
}

@JS("BABYLON.ColorGradient")
class ColorGradient implements IValueGradient {
    // @Ignore
    ColorGradient .fakeConstructor$();

    external num get gradient;

    external set gradient(num v);

    external Color4 get color1;

    external set color1(Color4 v);

    external Color4 get color2;

    external set color2(Color4 v);

    external void getColorToRef(Color4 result);
}

@JS("BABYLON.Color3Gradient")
class Color3Gradient implements IValueGradient {
    // @Ignore
    Color3Gradient .fakeConstructor$();

    external num get gradient;

    external set gradient(num v);

    external Color3 get color;

    external set color(Color3 v);
}

@JS("BABYLON.FactorGradient")
class FactorGradient implements IValueGradient {
    // @Ignore
    FactorGradient .fakeConstructor$();

    external num get gradient;

    external set gradient(num v);

    external num get factor1;

    external set factor1(num v);

    external num get factor2;

    external set factor2(num v);

    external num getFactor();
}

@JS("BABYLON.LoadFileError")
class LoadFileError extends Error {
    // @Ignore
    //LoadFileError .fakeConstructor$() : super.fakeConstructor$();
    external dynamic/*HttpRequest|dynamic*/ get request;

    external set request(dynamic/*HttpRequest|dynamic*/ v);

    external static get JS$_setPrototypeOf;

    external static set JS$_setPrototypeOf(v);

    external factory LoadFileError(String message, [dynamic/*HttpRequest|dynamic*/ request]);
}

@JS("BABYLON.RetryStrategy")
class RetryStrategy {
    // @Ignore
    RetryStrategy .fakeConstructor$();

    external static Func3<String, HttpRequest, num, num> ExponentialBackoff([num maxRetries, num baseInterval]);
}

@anonymous
@JS()
abstract class IFileRequest {
    external Observable<IFileRequest> get onCompleteObservable;

    external set onCompleteObservable(Observable<IFileRequest> v);

    external VoidFunc0 get abort;

    external set abort(VoidFunc0 v);

    external factory IFileRequest({ Observable<IFileRequest> onCompleteObservable, VoidFunc0 abort});
}

@JS("BABYLON.Tools")
class Tools {
    // @Ignore
    Tools .fakeConstructor$();

    external static String get BaseUrl;

    external static set BaseUrl(String v);

    external static Func3<String, HttpRequest, num, num> get DefaultRetryStrategy;

    external static set DefaultRetryStrategy(Func3<String, HttpRequest, num, num> v);

    external static dynamic/*String|Func1<String|List<String>, String>*/ get CorsBehavior;

    external static set CorsBehavior(dynamic/*String|Func1<String|List<String>, String>*/ v);

    external static bool get UseFallbackTexture;

    external static set UseFallbackTexture(bool v);

    external static dynamic/*JSMap of <String,Object>*/ get RegisteredExternalClasses;

    external static set RegisteredExternalClasses(dynamic/*JSMap of <String,Object>*/ v);

    external static String get fallbackTexture;

    external static set fallbackTexture(String v);

    external static void FetchToRef(num u, num v, num width, num height, Uint8List pixels, Color4 color);

    external static num Mix(num a, num b, num alpha);

    external static dynamic Instantiate(String className);

    external static dynamic/*=T*/ Slice /*<T>*/(dynamic/*=T*/ data, [num start, num end]);

    external static void SetImmediate(void action());

    external static bool IsExponentOfTwo(num value);

    external static get JS$_tmpFloatArray;

    external static set JS$_tmpFloatArray(v);

    external static num FloatRound(num value);

    external static num CeilingPOT(num x);

    external static num FloorPOT(num x);

    external static num NearestPOT(num x);

    external static num GetExponentOfTwo(num value, num max, [num mode]);

    external static String GetFilename(String path);

    external static String GetFolderPath(String uri, [bool returnUnchangedIfNoSlash]);

    external static String GetDOMTextContent(HtmlElement element);

    external static num ToDegrees(num angle);

    external static num ToRadians(num angle);

    external static String EncodeArrayBufferTobase64(ByteBuffer buffer);

    external static dynamic/*{
            minimum: Vector3;
            maximum: Vector3;
        }*/
    ExtractMinAndMaxIndexed(dynamic/*List<num>|Float32List*/ positions, dynamic/*List<num>|Int32List|Uint32List|Uint16List*/ indices, num indexStart, num indexCount, [Vector2/*Vector2|Null*/ bias]);

    external static dynamic/*{
            minimum: Vector3;
            maximum: Vector3;
        }*/
    ExtractMinAndMax(dynamic/*List<num>|Float32List*/ positions, num start, num count, [Vector2/*Vector2|Null*/ bias, num stride]);

    external static List<dynamic>/*List<dynamic>|Null*/ MakeArray(dynamic obj, [bool allowsNullUndefined]);

    external static String GetPointerPrefix();

    external static num QueueNewFrame(void func(), [dynamic requester]);

    external static void RequestFullscreen(HtmlElement element);

    external static void ExitFullscreen();

    external static void SetCorsBehavior(dynamic/*String|List<String>*/ url, dynamic/*{
            crossOrigin: string | null;
        }*/
    element);

    external static String CleanUrl(String url);

    external static Func1<String, String> get PreprocessUrl;

    external static set PreprocessUrl(Func1<String, String> v);

    external static ImageElement LoadImage(dynamic/*String|ByteBuffer|Blob*/ input, void onLoad(ImageElement img), void onError([String message, dynamic exception]), Database/*Database|Null*/ database);

    external static IFileRequest LoadFile(String url, void onSuccess(dynamic/*String|ByteBuffer*/ data, [String responseURL]), [void onProgress(dynamic data), Database database, bool useArrayBuffer, void onError([HttpRequest request, dynamic exception])]);

    external static void LoadScript(String scriptUrl, void onSuccess(), [void onError([String message, dynamic exception])]);

    external static IFileRequest ReadFileAsDataURL(Blob fileToLoad, void callback(dynamic data), dynamic progressCallback(ProgressEvent ev));

    external static IFileRequest ReadFile(File fileToLoad, void callback(dynamic data), [dynamic progressCallBack(ProgressEvent ev), bool useArrayBuffer]);

    external static String FileAsURL(String content);

    external static String Format(num value, [num decimals]);

    external static void CheckExtends(Vector3 v, Vector3 min, Vector3 max);

    external static void DeepCopy(dynamic source, dynamic destination, [List<String> doNotCopyList, List<String> mustCopyList]);

    external static bool IsEmpty(dynamic obj);

    external static void RegisterTopRootEvents(List<dynamic /*{
            name: string;
            handler: Nullable<(e: FocusEvent) => any>;
        }*/> events);

    external static void UnregisterTopRootEvents(List<dynamic /*{
            name: string;
            handler: Nullable<(e: FocusEvent) => any>;
        }*/> events);

    external static void DumpFramebuffer(num width, num height, Engine engine, [void successCallback(String data), String mimeType, String fileName]);

    external static void ToBlob(CanvasElement canvas, void successCallback(Blob/*Blob|Null*/ blob), [String mimeType]);

    external static void EncodeScreenshotCanvasData([void successCallback(String data), String mimeType, String fileName]);

    external static void Download(Blob blob, String fileName);

    external static void CreateScreenshot(Engine engine, Camera camera, dynamic size, [void successCallback(String data), String mimeType]);

    external static void CreateScreenshotUsingRenderTarget(Engine engine, Camera camera, dynamic size, [void successCallback(String data), String mimeType, num samples, bool antialiasing, String fileName]);

    external static bool ValidateXHRData(HttpRequest xhr, [num dataType]);

    external static String RandomId();

    external static bool IsBase64(String uri);

    external static ByteBuffer DecodeBase64(String uri);

    external static num get NoneLogLevel;

    external static set NoneLogLevel(num v);

    external static num get MessageLogLevel;

    external static set MessageLogLevel(num v);

    external static num get WarningLogLevel;

    external static set WarningLogLevel(num v);

    external static num get ErrorLogLevel;

    external static set ErrorLogLevel(num v);

    external static num get AllLogLevel;

    external static set AllLogLevel(num v);

    external static get JS$_LogCache;

    external static set JS$_LogCache(v);

    external static num get errorsCount;

    external static set errorsCount(num v);

    external static VoidFunc1<String> get OnNewCacheEntry;

    external static set OnNewCacheEntry(VoidFunc1<String> v);

    external static get JS$_AddLogEntry;

    external static set JS$_AddLogEntry(v);

    external static get JS$_FormatMessage;

    external static set JS$_FormatMessage(v);

    external static get JS$_LogDisabled;

    external static set JS$_LogDisabled(v);

    external static get JS$_LogEnabled;

    external static set JS$_LogEnabled(v);

    external static get JS$_WarnDisabled;

    external static set JS$_WarnDisabled(v);

    external static get JS$_WarnEnabled;

    external static set JS$_WarnEnabled(v);

    external static get JS$_ErrorDisabled;

    external static set JS$_ErrorDisabled(v);

    external static get JS$_ErrorEnabled;

    external static set JS$_ErrorEnabled(v);

    external static VoidFunc1<String> get Log;

    external static set Log(VoidFunc1<String> v);

    external static VoidFunc1<String> get Warn;

    external static set Warn(VoidFunc1<String> v);

    external static VoidFunc1<String> get Error;

    external static set Error(VoidFunc1<String> v);

    external static String get LogCache;

    external static set LogCache(String v);

    external static void ClearLogCache();

    external static num get LogLevels;

    external static set LogLevels(num v);

    external static bool IsFileURL();

    external static bool IsWindowObjectExist();

    external static num get PerformanceNoneLogLevel;

    external static set PerformanceNoneLogLevel(num v);

    external static num get PerformanceUserMarkLogLevel;

    external static set PerformanceUserMarkLogLevel(num v);

    external static num get PerformanceConsoleLogLevel;

    external static set PerformanceConsoleLogLevel(num v);

    external static get JS$_performance;

    external static set JS$_performance(v);

    external static num get PerformanceLogLevel;

    external static set PerformanceLogLevel(num v);

    external static get JS$_StartPerformanceCounterDisabled;

    external static set JS$_StartPerformanceCounterDisabled(v);

    external static get JS$_EndPerformanceCounterDisabled;

    external static set JS$_EndPerformanceCounterDisabled(v);

    external static get JS$_StartUserMark;

    external static set JS$_StartUserMark(v);

    external static get JS$_EndUserMark;

    external static set JS$_EndUserMark(v);

    external static get JS$_StartPerformanceConsole;

    external static set JS$_StartPerformanceConsole(v);

    external static get JS$_EndPerformanceConsole;

    external static set JS$_EndPerformanceConsole(v);

    external static VoidFunc2Opt1<String, bool> get StartPerformanceCounter;

    external static set StartPerformanceCounter(VoidFunc2Opt1<String, bool> v);

    external static VoidFunc2Opt1<String, bool> get EndPerformanceCounter;

    external static set EndPerformanceCounter(VoidFunc2Opt1<String, bool> v);

    external static num get Now;

    external static set Now(num v);

    external static String GetClassName(dynamic object, [bool isType]);

    external static dynamic/*T|Null*/ First /*<T>*/(List<dynamic /*=T*/> array, bool predicate(dynamic/*=T*/ item));

    external static String/*String|Null*/ getFullClassName(dynamic object, [bool isType]);

    external static Promise<Null> DelayAsync(num delay);

    external static void GetCurrentGradient(num ratio, List<IValueGradient> gradients, void updateFunc(IValueGradient current, IValueGradient next, num scale));
}

@JS("BABYLON.PerfCounter")
class PerfCounter {
    // @Ignore
    PerfCounter .fakeConstructor$();

    external static bool get Enabled;

    external static set Enabled(bool v);

    external num get min;

    external set min(num v);

    external num get max;

    external set max(num v);

    external num get average;

    external set average(num v);

    external num get lastSecAverage;

    external set lastSecAverage(num v);

    external num get current;

    external set current(num v);

    external num get total;

    external set total(num v);

    external num get count;

    external set count(num v);

    external factory PerfCounter();

    external void fetchNewFrame();

    external void addCount(num newCount, bool fetchResult);

    external void beginMonitoring();

    external void endMonitoring([bool newFrame]);

    external get JS$_fetchResult;

    external set JS$_fetchResult(v);

    external get JS$_startMonitoringTime;

    external set JS$_startMonitoringTime(v);

    external get JS$_min;

    external set JS$_min(v);

    external get JS$_max;

    external set JS$_max(v);

    external get JS$_average;

    external set JS$_average(v);

    external get JS$_current;

    external set JS$_current(v);

    external get JS$_totalValueCount;

    external set JS$_totalValueCount(v);

    external get JS$_totalAccumulated;

    external set JS$_totalAccumulated(v);

    external get JS$_lastSecAverage;

    external set JS$_lastSecAverage(v);

    external get JS$_lastSecAccumulated;

    external set JS$_lastSecAccumulated(v);

    external get JS$_lastSecTime;

    external set JS$_lastSecTime(v);

    external get JS$_lastSecValueCount;

    external set JS$_lastSecValueCount(v);
}

@JS("BABYLON.className")
external VoidFunc1<Object> className(String name, [String module]);

@JS("BABYLON.AsyncLoop")
class AsyncLoop {
    // @Ignore
    AsyncLoop .fakeConstructor$();

    external num get iterations;

    external set iterations(num v);

    external num get index;

    external set index(num v);

    external get JS$_done;

    external set JS$_done(v);

    external get JS$_fn;

    external set JS$_fn(v);

    external get JS$_successCallback;

    external set JS$_successCallback(v);

    external factory AsyncLoop(num iterations, void func(AsyncLoop asyncLoop), void successCallback(), [num offset]);

    external void executeNext();

    external void breakLoop();

    external static AsyncLoop Run(num iterations, void fn(AsyncLoop asyncLoop), void successCallback(), [num offset]);

    external static AsyncLoop SyncAsyncForLoop(num iterations, num syncedIterations, void fn(num iteration), void callback(), [bool breakFunction(), num timeout]);
}

@anonymous
@JS()
abstract class VideoRecorderOptions {
    external String get mimeType;

    external set mimeType(String v);

    external num get fps;

    external set fps(num v);

    external num get recordChunckSize;

    external set recordChunckSize(num v);

    external factory VideoRecorderOptions({ String mimeType, num fps, num recordChunckSize});
}

@JS("BABYLON.VideoRecorder")
class VideoRecorder {
    // @Ignore
    VideoRecorder .fakeConstructor$();

    external static get JS$_defaultOptions;

    external static set JS$_defaultOptions(v);

    external static bool IsSupported(Engine engine);

    external get JS$_options;

    external set JS$_options(v);

    external get JS$_canvas;

    external set JS$_canvas(v);

    external get JS$_mediaRecorder;

    external set JS$_mediaRecorder(v);

    external get JS$_recordedChunks;

    external set JS$_recordedChunks(v);

    external get JS$_fileName;

    external set JS$_fileName(v);

    external get JS$_resolve;

    external set JS$_resolve(v);

    external get JS$_reject;

    external set JS$_reject(v);

    external bool get isRecording;

    external set isRecording(bool v);

    external factory VideoRecorder(Engine engine, [VideoRecorderOptions/*VideoRecorderOptions|Null*/ options]);

    external void stopRecording();

    external Promise<Blob> startRecording([String/*String|Null*/ fileName, num maxDuration]);

    external void dispose();

    external get JS$_handleDataAvailable;

    external set JS$_handleDataAvailable(v);

    external get JS$_handleError;

    external set JS$_handleError(v);

    external get JS$_handleStop;

    external set JS$_handleStop(v);
}

@JS("BABYLON.JoystickAxis")
class JoystickAxis {
    external static num get X;

    external static num get Y;

    external static num get Z;
}

@JS("BABYLON.VirtualJoystick")
class VirtualJoystick {
    // @Ignore
    VirtualJoystick .fakeConstructor$();

    external bool get reverseLeftRight;

    external set reverseLeftRight(bool v);

    external bool get reverseUpDown;

    external set reverseUpDown(bool v);

    external Vector3 get deltaPosition;

    external set deltaPosition(Vector3 v);

    external bool get pressed;

    external set pressed(bool v);

    external static get JS$_globalJoystickIndex;

    external static set JS$_globalJoystickIndex(v);

    external static get vjCanvas;

    external static set vjCanvas(v);

    external static get vjCanvasContext;

    external static set vjCanvasContext(v);

    external static get vjCanvasWidth;

    external static set vjCanvasWidth(v);

    external static get vjCanvasHeight;

    external static set vjCanvasHeight(v);

    external static get halfWidth;

    external static set halfWidth(v);

    external get JS$_action;

    external set JS$_action(v);

    external get JS$_axisTargetedByLeftAndRight;

    external set JS$_axisTargetedByLeftAndRight(v);

    external get JS$_axisTargetedByUpAndDown;

    external set JS$_axisTargetedByUpAndDown(v);

    external get JS$_joystickSensibility;

    external set JS$_joystickSensibility(v);

    external get JS$_inversedSensibility;

    external set JS$_inversedSensibility(v);

    external get JS$_joystickPointerID;

    external set JS$_joystickPointerID(v);

    external get JS$_joystickColor;

    external set JS$_joystickColor(v);

    external get JS$_joystickPointerPos;

    external set JS$_joystickPointerPos(v);

    external get JS$_joystickPreviousPointerPos;

    external set JS$_joystickPreviousPointerPos(v);

    external get JS$_joystickPointerStartPos;

    external set JS$_joystickPointerStartPos(v);

    external get JS$_deltaJoystickVector;

    external set JS$_deltaJoystickVector(v);

    external get JS$_leftJoystick;

    external set JS$_leftJoystick(v);

    external get JS$_touches;

    external set JS$_touches(v);

    external get JS$_onPointerDownHandlerRef;

    external set JS$_onPointerDownHandlerRef(v);

    external get JS$_onPointerMoveHandlerRef;

    external set JS$_onPointerMoveHandlerRef(v);

    external get JS$_onPointerUpHandlerRef;

    external set JS$_onPointerUpHandlerRef(v);

    external get JS$_onResize;

    external set JS$_onResize(v);

    external factory VirtualJoystick([bool leftJoystick]);

    external void setJoystickSensibility(num newJoystickSensibility);

    external get JS$_onPointerDown;

    external set JS$_onPointerDown(v);

    external get JS$_onPointerMove;

    external set JS$_onPointerMove(v);

    external get JS$_onPointerUp;

    external set JS$_onPointerUp(v);

    external void setJoystickColor(String newColor);

    external void setActionOnTouch(dynamic action());

    external void setAxisForLeftRight(num/*enum JoystickAxis*/ axis);

    external void setAxisForUpDown(num/*enum JoystickAxis*/ axis);

    external get JS$_drawVirtualJoystick;

    external set JS$_drawVirtualJoystick(v);

    external void releaseCanvas();
}

@JS("BABYLON.WorkerPool")
class WorkerPool implements IDisposable {
    // @Ignore
    WorkerPool .fakeConstructor$();

    external get JS$_workerInfos;

    external set JS$_workerInfos(v);

    external get JS$_pendingActions;

    external set JS$_pendingActions(v);

    external factory WorkerPool(List<Worker> workers);

    external void dispose();

    external void push(void action(Worker worker, void onComplete()));

    external get JS$_execute;

    external set JS$_execute(v);
}

@JS("BABYLON.AutoRotationBehavior")
class AutoRotationBehavior implements Behavior<ArcRotateCamera> {
    // @Ignore
    AutoRotationBehavior .fakeConstructor$();

    external String get name;

    external set name(String v);

    external get JS$_zoomStopsAnimation;

    external set JS$_zoomStopsAnimation(v);

    external get JS$_idleRotationSpeed;

    external set JS$_idleRotationSpeed(v);

    external get JS$_idleRotationWaitTime;

    external set JS$_idleRotationWaitTime(v);

    external get JS$_idleRotationSpinupTime;

    external set JS$_idleRotationSpinupTime(v);

    external bool get zoomStopsAnimation;

    external set zoomStopsAnimation(bool v);

    external num get idleRotationSpeed;

    external set idleRotationSpeed(num v);

    external num get idleRotationWaitTime;

    external set idleRotationWaitTime(num v);

    external num get idleRotationSpinupTime;

    external set idleRotationSpinupTime(num v);

    external bool get rotationInProgress;

    external set rotationInProgress(bool v);

    external get JS$_onPrePointerObservableObserver;

    external set JS$_onPrePointerObservableObserver(v);

    external get JS$_onAfterCheckInputsObserver;

    external set JS$_onAfterCheckInputsObserver(v);

    external get JS$_attachedCamera;

    external set JS$_attachedCamera(v);

    external get JS$_isPointerDown;

    external set JS$_isPointerDown(v);

    external get JS$_lastFrameTime;

    external set JS$_lastFrameTime(v);

    external get JS$_lastInteractionTime;

    external set JS$_lastInteractionTime(v);

    external get JS$_cameraRotationSpeed;

    external set JS$_cameraRotationSpeed(v);

    external void init();

    external void attach(ArcRotateCamera camera);

    external void detach();

    external get JS$_userIsZooming;

    external set JS$_userIsZooming(v);

    external get JS$_lastFrameRadius;

    external set JS$_lastFrameRadius(v);

    external get JS$_shouldAnimationStopForInteraction;

    external set JS$_shouldAnimationStopForInteraction(v);

    external get JS$_applyUserInteraction;

    external set JS$_applyUserInteraction(v);

    external get JS$_userIsMoving;

    external set JS$_userIsMoving(v);
}

@JS("BABYLON.BouncingBehavior")
class BouncingBehavior implements Behavior<ArcRotateCamera> {
    // @Ignore
    BouncingBehavior .fakeConstructor$();

    external String get name;

    external set name(String v);

    external static BackEase get EasingFunction;

    external static set EasingFunction(BackEase v);

    external static num get EasingMode;

    external static set EasingMode(num v);

    external num get transitionDuration;

    external set transitionDuration(num v);

    external num get lowerRadiusTransitionRange;

    external set lowerRadiusTransitionRange(num v);

    external num get upperRadiusTransitionRange;

    external set upperRadiusTransitionRange(num v);

    external get JS$_autoTransitionRange;

    external set JS$_autoTransitionRange(v);

    external bool get autoTransitionRange;

    external set autoTransitionRange(bool v);

    external get JS$_attachedCamera;

    external set JS$_attachedCamera(v);

    external get JS$_onAfterCheckInputsObserver;

    external set JS$_onAfterCheckInputsObserver(v);

    external get JS$_onMeshTargetChangedObserver;

    external set JS$_onMeshTargetChangedObserver(v);

    external void init();

    external void attach(ArcRotateCamera camera);

    external void detach();

    external get JS$_radiusIsAnimating;

    external set JS$_radiusIsAnimating(v);

    external get JS$_radiusBounceTransition;

    external set JS$_radiusBounceTransition(v);

    external get JS$_animatables;

    external set JS$_animatables(v);

    external get JS$_cachedWheelPrecision;

    external set JS$_cachedWheelPrecision(v);

    external get JS$_isRadiusAtLimit;

    external set JS$_isRadiusAtLimit(v);

    external get JS$_applyBoundRadiusAnimation;

    external set JS$_applyBoundRadiusAnimation(v);

    external void JS$_clearAnimationLocks();

    external void stopAllAnimations();
}

@JS("BABYLON.FramingBehavior")
class FramingBehavior implements Behavior<ArcRotateCamera> {
    // @Ignore
    FramingBehavior .fakeConstructor$();

    external String get name;

    external set name(String v);

    external get JS$_mode;

    external set JS$_mode(v);

    external get JS$_radiusScale;

    external set JS$_radiusScale(v);

    external get JS$_positionScale;

    external set JS$_positionScale(v);

    external get JS$_defaultElevation;

    external set JS$_defaultElevation(v);

    external get JS$_elevationReturnTime;

    external set JS$_elevationReturnTime(v);

    external get JS$_elevationReturnWaitTime;

    external set JS$_elevationReturnWaitTime(v);

    external get JS$_zoomStopsAnimation;

    external set JS$_zoomStopsAnimation(v);

    external get JS$_framingTime;

    external set JS$_framingTime(v);

    external static ExponentialEase get EasingFunction;

    external static set EasingFunction(ExponentialEase v);

    external static num get EasingMode;

    external static set EasingMode(num v);

    external num get mode;

    external set mode(num v);

    external num get radiusScale;

    external set radiusScale(num v);

    external num get positionScale;

    external set positionScale(num v);

    external num get defaultElevation;

    external set defaultElevation(num v);

    external num get elevationReturnTime;

    external set elevationReturnTime(num v);

    external num get elevationReturnWaitTime;

    external set elevationReturnWaitTime(num v);

    external bool get zoomStopsAnimation;

    external set zoomStopsAnimation(bool v);

    external num get framingTime;

    external set framingTime(num v);

    external bool get autoCorrectCameraLimitsAndSensibility;

    external set autoCorrectCameraLimitsAndSensibility(bool v);

    external get JS$_onPrePointerObservableObserver;

    external set JS$_onPrePointerObservableObserver(v);

    external get JS$_onAfterCheckInputsObserver;

    external set JS$_onAfterCheckInputsObserver(v);

    external get JS$_onMeshTargetChangedObserver;

    external set JS$_onMeshTargetChangedObserver(v);

    external get JS$_attachedCamera;

    external set JS$_attachedCamera(v);

    external get JS$_isPointerDown;

    external set JS$_isPointerDown(v);

    external get JS$_lastInteractionTime;

    external set JS$_lastInteractionTime(v);

    external void init();

    external void attach(ArcRotateCamera camera);

    external void detach();

    external get JS$_animatables;

    external set JS$_animatables(v);

    external get JS$_betaIsAnimating;

    external set JS$_betaIsAnimating(v);

    external get JS$_betaTransition;

    external set JS$_betaTransition(v);

    external get JS$_radiusTransition;

    external set JS$_radiusTransition(v);

    external get JS$_vectorTransition;

    external set JS$_vectorTransition(v);

    external void zoomOnMesh(AbstractMesh mesh, [bool focusOnOriginXZ, VoidFunc0/*VoidFunc0|Null*/ onAnimationEnd]);

    external void zoomOnMeshHierarchy(AbstractMesh mesh, [bool focusOnOriginXZ, VoidFunc0/*VoidFunc0|Null*/ onAnimationEnd]);

    external void zoomOnMeshesHierarchy(List<AbstractMesh> meshes, [bool focusOnOriginXZ, VoidFunc0/*VoidFunc0|Null*/ onAnimationEnd]);

    external void zoomOnBoundingInfo(Vector3 minimumWorld, Vector3 maximumWorld, [bool focusOnOriginXZ, VoidFunc0/*VoidFunc0|Null*/ onAnimationEnd]);

    external num JS$_calculateLowerRadiusFromModelBoundingSphere(Vector3 minimumWorld, Vector3 maximumWorld);

    external get JS$_maintainCameraAboveGround;

    external set JS$_maintainCameraAboveGround(v);

    external get JS$_getFrustumSlope;

    external set JS$_getFrustumSlope(v);

    external get JS$_clearAnimationLocks;

    external set JS$_clearAnimationLocks(v);

    external get JS$_applyUserInteraction;

    external set JS$_applyUserInteraction(v);

    external void stopAllAnimations();

    external bool get isUserIsMoving;

    external set isUserIsMoving(bool v);

    external static num get IgnoreBoundsSizeMode;

    external static set IgnoreBoundsSizeMode(num v);

    external static num get FitFrustumSidesMode;

    external static set FitFrustumSidesMode(num v);
}

@JS("BABYLON.AttachToBoxBehavior")
class AttachToBoxBehavior implements Behavior<Mesh> {
    // @Ignore
    AttachToBoxBehavior .fakeConstructor$();

    external get ui;

    external set ui(v);

    external String get name;

    external set name(String v);

    external num get distanceAwayFromFace;

    external set distanceAwayFromFace(num v);

    external num get distanceAwayFromBottomOfFace;

    external set distanceAwayFromBottomOfFace(num v);

    external get JS$_faceVectors;

    external set JS$_faceVectors(v);

    external get JS$_target;

    external set JS$_target(v);

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_onRenderObserver;

    external set JS$_onRenderObserver(v);

    external get JS$_tmpMatrix;

    external set JS$_tmpMatrix(v);

    external get JS$_tmpVector;

    external set JS$_tmpVector(v);

    external factory AttachToBoxBehavior(TransformNode ui);

    external void init();

    external get JS$_closestFace;

    external set JS$_closestFace(v);

    external get JS$_zeroVector;

    external set JS$_zeroVector(v);

    external get JS$_lookAtTmpMatrix;

    external set JS$_lookAtTmpMatrix(v);

    external get JS$_lookAtToRef;

    external set JS$_lookAtToRef(v);

    external void attach(Mesh target);

    external void detach();
}

@JS("BABYLON.FadeInOutBehavior")
class FadeInOutBehavior implements Behavior<Mesh> {
    // @Ignore
    FadeInOutBehavior .fakeConstructor$();

    external num get delay;

    external set delay(num v);

    external num get fadeInTime;

    external set fadeInTime(num v);

    external get JS$_millisecondsPerFrame;

    external set JS$_millisecondsPerFrame(v);

    external get JS$_hovered;

    external set JS$_hovered(v);

    external get JS$_hoverValue;

    external set JS$_hoverValue(v);

    external get JS$_ownerNode;

    external set JS$_ownerNode(v);

    external factory FadeInOutBehavior();

    external String get name;

    external set name(String v);

    external void init();

    external void attach(Mesh ownerNode);

    external void detach();

    external void fadeIn(bool value);

    external get JS$_update;

    external set JS$_update(v);

    external get JS$_setAllVisibility;

    external set JS$_setAllVisibility(v);
}

@JS("BABYLON.MultiPointerScaleBehavior")
class MultiPointerScaleBehavior implements Behavior<Mesh> {
    // @Ignore
    MultiPointerScaleBehavior .fakeConstructor$();

    external get JS$_dragBehaviorA;

    external set JS$_dragBehaviorA(v);

    external get JS$_dragBehaviorB;

    external set JS$_dragBehaviorB(v);

    external get JS$_startDistance;

    external set JS$_startDistance(v);

    external get JS$_initialScale;

    external set JS$_initialScale(v);

    external get JS$_targetScale;

    external set JS$_targetScale(v);

    external get JS$_ownerNode;

    external set JS$_ownerNode(v);

    external get JS$_sceneRenderObserver;

    external set JS$_sceneRenderObserver(v);

    external factory MultiPointerScaleBehavior();

    external String get name;

    external set name(String v);

    external void init();

    external get JS$_getCurrentDistance;

    external set JS$_getCurrentDistance(v);

    external void attach(Mesh ownerNode);

    external void detach();
}

@JS("BABYLON.PointerDragBehavior")
class PointerDragBehavior implements Behavior<Mesh> {
    // @Ignore
    PointerDragBehavior .fakeConstructor$();

    external static get JS$_AnyMouseID;

    external static set JS$_AnyMouseID(v);

    external get JS$_attachedNode;

    external set JS$_attachedNode(v);

    external get JS$_dragPlane;

    external set JS$_dragPlane(v);

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_pointerObserver;

    external set JS$_pointerObserver(v);

    external get JS$_beforeRenderObserver;

    external set JS$_beforeRenderObserver(v);

    external static get JS$_planeScene;

    external static set JS$_planeScene(v);

    external num get maxDragAngle;

    external set maxDragAngle(num v);

    external bool get JS$_useAlternatePickedPointAboveMaxDragAngle;

    external set JS$_useAlternatePickedPointAboveMaxDragAngle(bool v);

    external num get currentDraggingPointerID;

    external set currentDraggingPointerID(num v);

    external Vector3 get lastDragPosition;

    external set lastDragPosition(Vector3 v);

    external bool get dragging;

    external set dragging(bool v);

    external num get dragDeltaRatio;

    external set dragDeltaRatio(num v);

    external bool get updateDragPlane;

    external set updateDragPlane(bool v);

    external get JS$_debugMode;

    external set JS$_debugMode(v);

    external get JS$_moving;

    external set JS$_moving(v);

    external Observable<dynamic /*{
            delta: Vector3;
            dragPlanePoint: Vector3;
            dragPlaneNormal: Vector3;
            dragDistance: number;
            pointerId: number;
        }*/> get onDragObservable;

    external set onDragObservable(Observable<dynamic /*{
            delta: Vector3;
            dragPlanePoint: Vector3;
            dragPlaneNormal: Vector3;
            dragDistance: number;
            pointerId: number;
        }*/> v);

    external Observable<dynamic /*{
            dragPlanePoint: Vector3;
            pointerId: number;
        }*/> get onDragStartObservable;

    external set onDragStartObservable(Observable<dynamic /*{
            dragPlanePoint: Vector3;
            pointerId: number;
        }*/> v);

    external Observable<dynamic /*{
            dragPlanePoint: Vector3;
            pointerId: number;
        }*/> get onDragEndObservable;

    external set onDragEndObservable(Observable<dynamic /*{
            dragPlanePoint: Vector3;
            pointerId: number;
        }*/> v);

    external bool get moveAttached;

    external set moveAttached(bool v);

    external bool get enabled;

    external set enabled(bool v);

    external bool get detachCameraControls;

    external set detachCameraControls(bool v);

    external bool get useObjectOrienationForDragging;

    external set useObjectOrienationForDragging(bool v);

    external get JS$_options;

    external set JS$_options(v);

    external factory PointerDragBehavior([dynamic/*{
            dragAxis?: Vector3;
            dragPlaneNormal?: Vector3;
        }*/
    options]);

    external String get name;

    external set name(String v);

    external void init();

    external get JS$_tmpVector;

    external set JS$_tmpVector(v);

    external get JS$_alternatePickedPoint;

    external set JS$_alternatePickedPoint(v);

    external get JS$_worldDragAxis;

    external set JS$_worldDragAxis(v);

    external get JS$_targetPosition;

    external set JS$_targetPosition(v);

    external get JS$_attachedElement;

    external set JS$_attachedElement(v);

    external void attach(Mesh ownerNode);

    external void releaseDrag();

    external get JS$_startDragRay;

    external set JS$_startDragRay(v);

    external get JS$_lastPointerRay;

    external set JS$_lastPointerRay(v);

    external void startDrag([num pointerId, Ray fromRay, Vector3 startPickedPoint]);

    external get JS$_startDrag;

    external set JS$_startDrag(v);

    external get JS$_dragDelta;

    external set JS$_dragDelta(v);

    external get JS$_moveDrag;

    external set JS$_moveDrag(v);

    external get JS$_pickWithRayOnDragPlane;

    external set JS$_pickWithRayOnDragPlane(v);

    external get JS$_pointA;

    external set JS$_pointA(v);

    external get JS$_pointB;

    external set JS$_pointB(v);

    external get JS$_pointC;

    external set JS$_pointC(v);

    external get JS$_lineA;

    external set JS$_lineA(v);

    external get JS$_lineB;

    external set JS$_lineB(v);

    external get JS$_localAxis;

    external set JS$_localAxis(v);

    external get JS$_lookAt;

    external set JS$_lookAt(v);

    external get JS$_updateDragPlanePosition;

    external set JS$_updateDragPlanePosition(v);

    external void detach();
}

@JS("BABYLON.SixDofDragBehavior")
class SixDofDragBehavior implements Behavior<Mesh> {
    // @Ignore
    SixDofDragBehavior .fakeConstructor$();

    external static get JS$_virtualScene;

    external static set JS$_virtualScene(v);

    external get JS$_ownerNode;

    external set JS$_ownerNode(v);

    external get JS$_sceneRenderObserver;

    external set JS$_sceneRenderObserver(v);

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_targetPosition;

    external set JS$_targetPosition(v);

    external get JS$_virtualOriginMesh;

    external set JS$_virtualOriginMesh(v);

    external get JS$_virtualDragMesh;

    external set JS$_virtualDragMesh(v);

    external get JS$_pointerObserver;

    external set JS$_pointerObserver(v);

    external get JS$_moving;

    external set JS$_moving(v);

    external get JS$_startingOrientation;

    external set JS$_startingOrientation(v);

    external get zDragFactor;

    external set zDragFactor(v);

    external bool get dragging;

    external set dragging(bool v);

    external num get dragDeltaRatio;

    external set dragDeltaRatio(num v);

    external num get currentDraggingPointerID;

    external set currentDraggingPointerID(num v);

    external bool get detachCameraControls;

    external set detachCameraControls(bool v);

    external Observable<dynamic /*{}*/> get onDragStartObservable;

    external set onDragStartObservable(Observable<dynamic /*{}*/> v);

    external Observable<dynamic /*{}*/> get onDragEndObservable;

    external set onDragEndObservable(Observable<dynamic /*{}*/> v);

    external factory SixDofDragBehavior();

    external String get name;

    external set name(String v);

    external void init();

    external void attach(Mesh ownerNode);

    external void detach();
}

@JS("BABYLON.ArcRotateCameraGamepadInput")
class ArcRotateCameraGamepadInput implements ICameraInput<ArcRotateCamera> {
    // @Ignore
    ArcRotateCameraGamepadInput .fakeConstructor$();

    external ArcRotateCamera get camera;

    external set camera(ArcRotateCamera v);

    external Gamepad/*Gamepad|Null*/ get gamepad;

    external set gamepad(Gamepad/*Gamepad|Null*/ v);

    external num get gamepadRotationSensibility;

    external set gamepadRotationSensibility(num v);

    external num get gamepadMoveSensibility;

    external set gamepadMoveSensibility(num v);

    external get JS$_onGamepadConnectedObserver;

    external set JS$_onGamepadConnectedObserver(v);

    external get JS$_onGamepadDisconnectedObserver;

    external set JS$_onGamepadDisconnectedObserver(v);

    external void attachControl(HtmlElement element, [bool noPreventDefault]);

    external void detachControl(HtmlElement/*HtmlElement|Null*/ element);

    external void checkInputs();

    external String getClassName();

    external String getSimpleName();
}

@JS("BABYLON.ArcRotateCameraKeyboardMoveInput")
class ArcRotateCameraKeyboardMoveInput implements ICameraInput<ArcRotateCamera> {
    // @Ignore
    ArcRotateCameraKeyboardMoveInput .fakeConstructor$();

    external ArcRotateCamera get camera;

    external set camera(ArcRotateCamera v);

    external List<num> get keysUp;

    external set keysUp(List<num> v);

    external List<num> get keysDown;

    external set keysDown(List<num> v);

    external List<num> get keysLeft;

    external set keysLeft(List<num> v);

    external List<num> get keysRight;

    external set keysRight(List<num> v);

    external List<num> get keysReset;

    external set keysReset(List<num> v);

    external num get panningSensibility;

    external set panningSensibility(num v);

    external num get zoomingSensibility;

    external set zoomingSensibility(num v);

    external bool get useAltToZoom;

    external set useAltToZoom(bool v);

    external num get angularSpeed;

    external set angularSpeed(num v);

    external get JS$_keys;

    external set JS$_keys(v);

    external get JS$_ctrlPressed;

    external set JS$_ctrlPressed(v);

    external get JS$_altPressed;

    external set JS$_altPressed(v);

    external get JS$_onCanvasBlurObserver;

    external set JS$_onCanvasBlurObserver(v);

    external get JS$_onKeyboardObserver;

    external set JS$_onKeyboardObserver(v);

    external get JS$_engine;

    external set JS$_engine(v);

    external get JS$_scene;

    external set JS$_scene(v);

    external void attachControl(HtmlElement element, [bool noPreventDefault]);

    external void detachControl(HtmlElement/*HtmlElement|Null*/ element);

    external void checkInputs();

    external String getClassName();

    external String getSimpleName();
}

@JS("BABYLON.ArcRotateCameraMouseWheelInput")
class ArcRotateCameraMouseWheelInput implements ICameraInput<ArcRotateCamera> {
    // @Ignore
    ArcRotateCameraMouseWheelInput .fakeConstructor$();

    external ArcRotateCamera get camera;

    external set camera(ArcRotateCamera v);

    external num get wheelPrecision;

    external set wheelPrecision(num v);

    external num get wheelDeltaPercentage;

    external set wheelDeltaPercentage(num v);

    external get JS$_wheel;

    external set JS$_wheel(v);

    external get JS$_observer;

    external set JS$_observer(v);

    external void attachControl(HtmlElement element, [bool noPreventDefault]);

    external void detachControl(HtmlElement/*HtmlElement|Null*/ element);

    external String getClassName();

    external String getSimpleName();
}

@JS("BABYLON.ArcRotateCameraPointersInput")
class ArcRotateCameraPointersInput implements ICameraInput<ArcRotateCamera> {
    // @Ignore
    ArcRotateCameraPointersInput .fakeConstructor$();

    external ArcRotateCamera get camera;

    external set camera(ArcRotateCamera v);

    external List<num> get buttons;

    external set buttons(List<num> v);

    external num get angularSensibilityX;

    external set angularSensibilityX(num v);

    external num get angularSensibilityY;

    external set angularSensibilityY(num v);

    external num get pinchPrecision;

    external set pinchPrecision(num v);

    external num get pinchDeltaPercentage;

    external set pinchDeltaPercentage(num v);

    external num get panningSensibility;

    external set panningSensibility(num v);

    external bool get multiTouchPanning;

    external set multiTouchPanning(bool v);

    external bool get multiTouchPanAndZoom;

    external set multiTouchPanAndZoom(bool v);

    external bool get pinchInwards;

    external set pinchInwards(bool v);

    external get JS$_isPanClick;

    external set JS$_isPanClick(v);

    external get JS$_pointerInput;

    external set JS$_pointerInput(v);

    external get JS$_observer;

    external set JS$_observer(v);

    external get JS$_onMouseMove;

    external set JS$_onMouseMove(v);

    external get JS$_onGestureStart;

    external set JS$_onGestureStart(v);

    external get JS$_onGesture;

    external set JS$_onGesture(v);

    external get JS$_MSGestureHandler;

    external set JS$_MSGestureHandler(v);

    external get JS$_onLostFocus;

    external set JS$_onLostFocus(v);

    external get JS$_onContextMenu;

    external set JS$_onContextMenu(v);

    external void attachControl(HtmlElement element, [bool noPreventDefault]);

    external void detachControl(HtmlElement/*HtmlElement|Null*/ element);

    external String getClassName();

    external String getSimpleName();
}

@JS("BABYLON.ArcRotateCameraVRDeviceOrientationInput")
class ArcRotateCameraVRDeviceOrientationInput implements ICameraInput<ArcRotateCamera> {
    // @Ignore
    ArcRotateCameraVRDeviceOrientationInput .fakeConstructor$();

    external ArcRotateCamera get camera;

    external set camera(ArcRotateCamera v);

    external num get alphaCorrection;

    external set alphaCorrection(num v);

    external num get betaCorrection;

    external set betaCorrection(num v);

    external num get gammaCorrection;

    external set gammaCorrection(num v);

    external get JS$_alpha;

    external set JS$_alpha(v);

    external get JS$_gamma;

    external set JS$_gamma(v);

    external get JS$_dirty;

    external set JS$_dirty(v);

    external get JS$_deviceOrientationHandler;

    external set JS$_deviceOrientationHandler(v);

    external factory ArcRotateCameraVRDeviceOrientationInput();

    external void attachControl(HtmlElement element, [bool noPreventDefault]);

    external void JS$_onOrientationEvent(DeviceOrientationEvent evt);

    external void checkInputs();

    external void detachControl(HtmlElement/*HtmlElement|Null*/ element);

    external String getClassName();

    external String getSimpleName();
}

@JS("BABYLON.FreeCameraDeviceOrientationInput")
class FreeCameraDeviceOrientationInput implements ICameraInput<FreeCamera> {
    // @Ignore
    FreeCameraDeviceOrientationInput .fakeConstructor$();

    external get JS$_camera;

    external set JS$_camera(v);

    external get JS$_screenOrientationAngle;

    external set JS$_screenOrientationAngle(v);

    external get JS$_constantTranform;

    external set JS$_constantTranform(v);

    external get JS$_screenQuaternion;

    external set JS$_screenQuaternion(v);

    external get JS$_alpha;

    external set JS$_alpha(v);

    external get JS$_beta;

    external set JS$_beta(v);

    external get JS$_gamma;

    external set JS$_gamma(v);

    external factory FreeCameraDeviceOrientationInput();

    external FreeCamera get camera;

    external set camera(FreeCamera v);

    external void attachControl(HtmlElement element, [bool noPreventDefault]);

    external get JS$_orientationChanged;

    external set JS$_orientationChanged(v);

    external get JS$_deviceOrientation;

    external set JS$_deviceOrientation(v);

    external void detachControl(HtmlElement/*HtmlElement|Null*/ element);

    external void checkInputs();

    external String getClassName();

    external String getSimpleName();
}

@JS("BABYLON.FreeCameraGamepadInput")
class FreeCameraGamepadInput implements ICameraInput<FreeCamera> {
    // @Ignore
    FreeCameraGamepadInput .fakeConstructor$();

    external FreeCamera get camera;

    external set camera(FreeCamera v);

    external Gamepad/*Gamepad|Null*/ get gamepad;

    external set gamepad(Gamepad/*Gamepad|Null*/ v);

    external num get gamepadAngularSensibility;

    external set gamepadAngularSensibility(num v);

    external num get gamepadMoveSensibility;

    external set gamepadMoveSensibility(num v);

    external get JS$_onGamepadConnectedObserver;

    external set JS$_onGamepadConnectedObserver(v);

    external get JS$_onGamepadDisconnectedObserver;

    external set JS$_onGamepadDisconnectedObserver(v);

    external get JS$_cameraTransform;

    external set JS$_cameraTransform(v);

    external get JS$_deltaTransform;

    external set JS$_deltaTransform(v);

    external get JS$_vector3;

    external set JS$_vector3(v);

    external get JS$_vector2;

    external set JS$_vector2(v);

    external void attachControl(HtmlElement element, [bool noPreventDefault]);

    external void detachControl(HtmlElement/*HtmlElement|Null*/ element);

    external void checkInputs();

    external String getClassName();

    external String getSimpleName();
}

@JS("BABYLON.FreeCameraKeyboardMoveInput")
class FreeCameraKeyboardMoveInput implements ICameraInput<FreeCamera> {
    // @Ignore
    FreeCameraKeyboardMoveInput .fakeConstructor$();

    external FreeCamera get camera;

    external set camera(FreeCamera v);

    external List<num> get keysUp;

    external set keysUp(List<num> v);

    external List<num> get keysDown;

    external set keysDown(List<num> v);

    external List<num> get keysLeft;

    external set keysLeft(List<num> v);

    external List<num> get keysRight;

    external set keysRight(List<num> v);

    external get JS$_keys;

    external set JS$_keys(v);

    external get JS$_onCanvasBlurObserver;

    external set JS$_onCanvasBlurObserver(v);

    external get JS$_onKeyboardObserver;

    external set JS$_onKeyboardObserver(v);

    external get JS$_engine;

    external set JS$_engine(v);

    external get JS$_scene;

    external set JS$_scene(v);

    external void attachControl(HtmlElement element, [bool noPreventDefault]);

    external void detachControl(HtmlElement/*HtmlElement|Null*/ element);

    external void checkInputs();

    external String getClassName();

    external void JS$_onLostFocus(FocusEvent e);

    external String getSimpleName();
}

@JS("BABYLON.FreeCameraMouseInput")
class FreeCameraMouseInput implements ICameraInput<FreeCamera> {
    // @Ignore
    FreeCameraMouseInput .fakeConstructor$();

    external bool get touchEnabled;

    external set touchEnabled(bool v);

    external FreeCamera get camera;

    external set camera(FreeCamera v);

    external List<num> get buttons;

    external set buttons(List<num> v);

    external num get angularSensibility;

    external set angularSensibility(num v);

    external get JS$_pointerInput;

    external set JS$_pointerInput(v);

    external get JS$_onMouseMove;

    external set JS$_onMouseMove(v);

    external get JS$_observer;

    external set JS$_observer(v);

    external get previousPosition;

    external set previousPosition(v);

    external factory FreeCameraMouseInput([bool touchEnabled]);

    external void attachControl(HtmlElement element, [bool noPreventDefault]);

    external void detachControl(HtmlElement/*HtmlElement|Null*/ element);

    external String getClassName();

    external String getSimpleName();
}

@JS("BABYLON.FreeCameraTouchInput")
class FreeCameraTouchInput implements ICameraInput<FreeCamera> {
    // @Ignore
    FreeCameraTouchInput .fakeConstructor$();

    external FreeCamera get camera;

    external set camera(FreeCamera v);

    external num get touchAngularSensibility;

    external set touchAngularSensibility(num v);

    external num get touchMoveSensibility;

    external set touchMoveSensibility(num v);

    external get JS$_offsetX;

    external set JS$_offsetX(v);

    external get JS$_offsetY;

    external set JS$_offsetY(v);

    external get JS$_pointerPressed;

    external set JS$_pointerPressed(v);

    external get JS$_pointerInput;

    external set JS$_pointerInput(v);

    external get JS$_observer;

    external set JS$_observer(v);

    external get JS$_onLostFocus;

    external set JS$_onLostFocus(v);

    external void attachControl(HtmlElement element, [bool noPreventDefault]);

    external void detachControl(HtmlElement/*HtmlElement|Null*/ element);

    external void checkInputs();

    external String getClassName();

    external String getSimpleName();
}

@JS("BABYLON.FreeCameraVirtualJoystickInput")
class FreeCameraVirtualJoystickInput implements ICameraInput<FreeCamera> {
    // @Ignore
    FreeCameraVirtualJoystickInput .fakeConstructor$();

    external FreeCamera get camera;

    external set camera(FreeCamera v);

    external get JS$_leftjoystick;

    external set JS$_leftjoystick(v);

    external get JS$_rightjoystick;

    external set JS$_rightjoystick(v);

    external VirtualJoystick getLeftJoystick();

    external VirtualJoystick getRightJoystick();

    external void checkInputs();

    external void attachControl(HtmlElement element, [bool noPreventDefault]);

    external void detachControl(HtmlElement/*HtmlElement|Null*/ element);

    external String getClassName();

    external String getSimpleName();
}

@JS("BABYLON.AnaglyphArcRotateCamera")
class AnaglyphArcRotateCamera extends ArcRotateCamera {
    // @Ignore
    AnaglyphArcRotateCamera .fakeConstructor$() : super.fakeConstructor$();

    external factory AnaglyphArcRotateCamera(String name, num alpha, num beta, num radius, Vector3 target, num interaxialDistance, Scene scene);

    external String getClassName();
}

@JS("BABYLON.AnaglyphFreeCamera")
class AnaglyphFreeCamera extends FreeCamera {
    // @Ignore
    AnaglyphFreeCamera .fakeConstructor$() : super.fakeConstructor$();

    external factory AnaglyphFreeCamera(String name, Vector3 position, num interaxialDistance, Scene scene);

    external String getClassName();
}

@JS("BABYLON.AnaglyphGamepadCamera")
class AnaglyphGamepadCamera extends GamepadCamera {
    // @Ignore
    AnaglyphGamepadCamera .fakeConstructor$() : super.fakeConstructor$();

    external factory AnaglyphGamepadCamera(String name, Vector3 position, num interaxialDistance, Scene scene);

    external String getClassName();
}

@JS("BABYLON.AnaglyphUniversalCamera")
class AnaglyphUniversalCamera extends UniversalCamera {
    // @Ignore
    AnaglyphUniversalCamera .fakeConstructor$() : super.fakeConstructor$();

    external factory AnaglyphUniversalCamera(String name, Vector3 position, num interaxialDistance, Scene scene);

    external String getClassName();
}

@JS("BABYLON.StereoscopicArcRotateCamera")
class StereoscopicArcRotateCamera extends ArcRotateCamera {
    // @Ignore
    StereoscopicArcRotateCamera .fakeConstructor$() : super.fakeConstructor$();

    external factory StereoscopicArcRotateCamera(String name, num alpha, num beta, num radius, Vector3 target, num interaxialDistance, bool isStereoscopicSideBySide, Scene scene);

    external String getClassName();
}

@JS("BABYLON.StereoscopicFreeCamera")
class StereoscopicFreeCamera extends FreeCamera {
    // @Ignore
    StereoscopicFreeCamera .fakeConstructor$() : super.fakeConstructor$();

    external factory StereoscopicFreeCamera(String name, Vector3 position, num interaxialDistance, bool isStereoscopicSideBySide, Scene scene);

    external String getClassName();
}

@JS("BABYLON.StereoscopicGamepadCamera")
class StereoscopicGamepadCamera extends GamepadCamera {
    // @Ignore
    StereoscopicGamepadCamera .fakeConstructor$() : super.fakeConstructor$();

    external factory StereoscopicGamepadCamera(String name, Vector3 position, num interaxialDistance, bool isStereoscopicSideBySide, Scene scene);

    external String getClassName();
}

@JS("BABYLON.StereoscopicUniversalCamera")
class StereoscopicUniversalCamera extends UniversalCamera {
    // @Ignore
    StereoscopicUniversalCamera .fakeConstructor$() : super.fakeConstructor$();

    external factory StereoscopicUniversalCamera(String name, Vector3 position, num interaxialDistance, bool isStereoscopicSideBySide, Scene scene);

    external String getClassName();
}

@JS("BABYLON.VRCameraMetrics")
class VRCameraMetrics {
    // @Ignore
    VRCameraMetrics .fakeConstructor$();

    external num get hResolution;

    external set hResolution(num v);

    external num get vResolution;

    external set vResolution(num v);

    external num get hScreenSize;

    external set hScreenSize(num v);

    external num get vScreenSize;

    external set vScreenSize(num v);

    external num get vScreenCenter;

    external set vScreenCenter(num v);

    external num get eyeToScreenDistance;

    external set eyeToScreenDistance(num v);

    external num get lensSeparationDistance;

    external set lensSeparationDistance(num v);

    external num get interpupillaryDistance;

    external set interpupillaryDistance(num v);

    external List<num> get distortionK;

    external set distortionK(List<num> v);

    external List<num> get chromaAbCorrection;

    external set chromaAbCorrection(List<num> v);

    external num get postProcessScaleFactor;

    external set postProcessScaleFactor(num v);

    external num get lensCenterOffset;

    external set lensCenterOffset(num v);

    external bool get compensateDistortion;

    external set compensateDistortion(bool v);

    external num get aspectRatio;

    external set aspectRatio(num v);

    external num get aspectRatioFov;

    external set aspectRatioFov(num v);

    external Matrix get leftHMatrix;

    external set leftHMatrix(Matrix v);

    external Matrix get rightHMatrix;

    external set rightHMatrix(Matrix v);

    external Matrix get leftPreViewMatrix;

    external set leftPreViewMatrix(Matrix v);

    external Matrix get rightPreViewMatrix;

    external set rightPreViewMatrix(Matrix v);

    external static VRCameraMetrics GetDefault();
}

@JS("BABYLON.VRDeviceOrientationArcRotateCamera")
class VRDeviceOrientationArcRotateCamera extends ArcRotateCamera {
    // @Ignore
    VRDeviceOrientationArcRotateCamera .fakeConstructor$() : super.fakeConstructor$();

    external factory VRDeviceOrientationArcRotateCamera(String name, num alpha, num beta, num radius, Vector3 target, Scene scene, [bool compensateDistortion, VRCameraMetrics vrCameraMetrics]);

    external String getClassName();
}

@JS("BABYLON.VRDeviceOrientationFreeCamera")
class VRDeviceOrientationFreeCamera extends DeviceOrientationCamera {
    // @Ignore
    VRDeviceOrientationFreeCamera .fakeConstructor$() : super.fakeConstructor$();

    external factory VRDeviceOrientationFreeCamera(String name, Vector3 position, Scene scene, [bool compensateDistortion, VRCameraMetrics vrCameraMetrics]);

    external String getClassName();
}

@JS("BABYLON.VRDeviceOrientationGamepadCamera")
class VRDeviceOrientationGamepadCamera extends VRDeviceOrientationFreeCamera {
    // @Ignore
    VRDeviceOrientationGamepadCamera .fakeConstructor$() : super.fakeConstructor$();

    external factory VRDeviceOrientationGamepadCamera(String name, Vector3 position, Scene scene, [bool compensateDistortion, VRCameraMetrics vrCameraMetrics]);

    external String getClassName();
}

@anonymous
@JS()
abstract class VRTeleportationOptions {
    external String get floorMeshName;

    external set floorMeshName(String v);

    external List<Mesh> get floorMeshes;

    external set floorMeshes(List<Mesh> v);

    external factory VRTeleportationOptions({ String floorMeshName, List<Mesh> floorMeshes});
}

@anonymous
@JS()
abstract class VRExperienceHelperOptions
    implements WebVROptions {
    external bool get createDeviceOrientationCamera;

    external set createDeviceOrientationCamera(bool v);

    external bool get createFallbackVRDeviceOrientationFreeCamera;

    external set createFallbackVRDeviceOrientationFreeCamera(bool v);

    external bool get laserToggle;

    external set laserToggle(bool v);

    external List<Mesh> get floorMeshes;

    external set floorMeshes(List<Mesh> v);

    external factory VRExperienceHelperOptions({ bool createDeviceOrientationCamera, bool createFallbackVRDeviceOrientationFreeCamera, bool laserToggle, List<Mesh> floorMeshes, bool trackPosition, num positionScale, String displayName, bool controllerMeshes, bool defaultLightingOnControllers, bool useCustomVRButton, ButtonElement customVRButton, num rayLength, num defaultHeight});
}

@JS("BABYLON.VRExperienceHelper")
class VRExperienceHelper {
    // @Ignore
    VRExperienceHelper .fakeConstructor$();

    external VRExperienceHelperOptions get webVROptions;

    external set webVROptions(VRExperienceHelperOptions v);

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_position;

    external set JS$_position(v);

    external get JS$_btnVR;

    external set JS$_btnVR(v);

    external get JS$_btnVRDisplayed;

    external set JS$_btnVRDisplayed(v);

    external get JS$_webVRsupported;

    external set JS$_webVRsupported(v);

    external get JS$_webVRready;

    external set JS$_webVRready(v);

    external get JS$_webVRrequesting;

    external set JS$_webVRrequesting(v);

    external get JS$_webVRpresenting;

    external set JS$_webVRpresenting(v);

    external get JS$_hasEnteredVR;

    external set JS$_hasEnteredVR(v);

    external get JS$_fullscreenVRpresenting;

    external set JS$_fullscreenVRpresenting(v);

    external get JS$_canvas;

    external set JS$_canvas(v);

    external get JS$_webVRCamera;

    external set JS$_webVRCamera(v);

    external get JS$_vrDeviceOrientationCamera;

    external set JS$_vrDeviceOrientationCamera(v);

    external get JS$_deviceOrientationCamera;

    external set JS$_deviceOrientationCamera(v);

    external get JS$_existingCamera;

    external set JS$_existingCamera(v);

    external get JS$_onKeyDown;

    external set JS$_onKeyDown(v);

    external get JS$_onVrDisplayPresentChange;

    external set JS$_onVrDisplayPresentChange(v);

    external get JS$_onVRDisplayChanged;

    external set JS$_onVRDisplayChanged(v);

    external get JS$_onVRRequestPresentStart;

    external set JS$_onVRRequestPresentStart(v);

    external get JS$_onVRRequestPresentComplete;

    external set JS$_onVRRequestPresentComplete(v);

    external Observable<VRExperienceHelper> get onEnteringVRObservable;

    external set onEnteringVRObservable(Observable<VRExperienceHelper> v);

    external Observable<VRExperienceHelper> get onExitingVRObservable;

    external set onExitingVRObservable(Observable<VRExperienceHelper> v);

    external Observable<WebVRController> get onControllerMeshLoadedObservable;

    external set onControllerMeshLoadedObservable(Observable<WebVRController> v);

    external Observable<VRExperienceHelper> get onEnteringVR;

    external set onEnteringVR(Observable<VRExperienceHelper> v);

    external Observable<VRExperienceHelper> get onExitingVR;

    external set onExitingVR(Observable<VRExperienceHelper> v);

    external Observable<WebVRController> get onControllerMeshLoaded;

    external set onControllerMeshLoaded(Observable<WebVRController> v);

    external get JS$_rayLength;

    external set JS$_rayLength(v);

    external get JS$_useCustomVRButton;

    external set JS$_useCustomVRButton(v);

    external get JS$_teleportationRequested;

    external set JS$_teleportationRequested(v);

    external get JS$_teleportActive;

    external set JS$_teleportActive(v);

    external get JS$_floorMeshName;

    external set JS$_floorMeshName(v);

    external get JS$_floorMeshesCollection;

    external set JS$_floorMeshesCollection(v);

    external get JS$_rotationAllowed;

    external set JS$_rotationAllowed(v);

    external get JS$_teleportBackwardsVector;

    external set JS$_teleportBackwardsVector(v);

    external get JS$_teleportationTarget;

    external set JS$_teleportationTarget(v);

    external get JS$_isDefaultTeleportationTarget;

    external set JS$_isDefaultTeleportationTarget(v);

    external get JS$_postProcessMove;

    external set JS$_postProcessMove(v);

    external get JS$_teleportationFillColor;

    external set JS$_teleportationFillColor(v);

    external get JS$_teleportationBorderColor;

    external set JS$_teleportationBorderColor(v);

    external get JS$_rotationAngle;

    external set JS$_rotationAngle(v);

    external get JS$_haloCenter;

    external set JS$_haloCenter(v);

    external get JS$_cameraGazer;

    external set JS$_cameraGazer(v);

    external get JS$_padSensibilityUp;

    external set JS$_padSensibilityUp(v);

    external get JS$_padSensibilityDown;

    external set JS$_padSensibilityDown(v);

    external get JS$_leftController;

    external set JS$_leftController(v);

    external get JS$_rightController;

    external set JS$_rightController(v);

    external Observable<AbstractMesh> get onNewMeshSelected;

    external set onNewMeshSelected(Observable<AbstractMesh> v);

    external Observable<PickingInfo> get onNewMeshPicked;

    external set onNewMeshPicked(Observable<PickingInfo> v);

    external get JS$_circleEase;

    external set JS$_circleEase(v);

    external Observable<Vector3> get onBeforeCameraTeleport;

    external set onBeforeCameraTeleport(Observable<Vector3> v);

    external Observable<Vector3> get onAfterCameraTeleport;

    external set onAfterCameraTeleport(Observable<Vector3> v);

    external Observable<AbstractMesh> get onSelectedMeshUnselected;

    external set onSelectedMeshUnselected(Observable<AbstractMesh> v);

    external get JS$_raySelectionPredicate;

    external set JS$_raySelectionPredicate(v);

    external Func1<AbstractMesh, bool> get raySelectionPredicate;

    external set raySelectionPredicate(Func1<AbstractMesh, bool> v);

    external Func1<AbstractMesh, bool> get meshSelectionPredicate;

    external set meshSelectionPredicate(Func1<AbstractMesh, bool> v);

    external bool get teleportationEnabled;

    external set teleportationEnabled(bool v);

    external get JS$_defaultHeight;

    external set JS$_defaultHeight(v);

    external get JS$_teleportationInitialized;

    external set JS$_teleportationInitialized(v);

    external get JS$_interactionsEnabled;

    external set JS$_interactionsEnabled(v);

    external get JS$_interactionsRequested;

    external set JS$_interactionsRequested(v);

    external get JS$_displayGaze;

    external set JS$_displayGaze(v);

    external get JS$_displayLaserPointer;

    external set JS$_displayLaserPointer(v);

    external Mesh get teleportationTarget;

    external set teleportationTarget(Mesh v);

    external Mesh get gazeTrackerMesh;

    external set gazeTrackerMesh(Mesh v);

    external bool get updateGazeTrackerScale;

    external set updateGazeTrackerScale(bool v);

    external Mesh/*Mesh|Null*/ get leftControllerGazeTrackerMesh;

    external set leftControllerGazeTrackerMesh(Mesh/*Mesh|Null*/ v);

    external Mesh/*Mesh|Null*/ get rightControllerGazeTrackerMesh;

    external set rightControllerGazeTrackerMesh(Mesh/*Mesh|Null*/ v);

    external bool get displayGaze;

    external set displayGaze(bool v);

    external bool get displayLaserPointer;

    external set displayLaserPointer(bool v);

    external DeviceOrientationCamera/*DeviceOrientationCamera|Null*/ get deviceOrientationCamera;

    external set deviceOrientationCamera(DeviceOrientationCamera/*DeviceOrientationCamera|Null*/ v);

    external Camera/*Camera|Null*/ get currentVRCamera;

    external set currentVRCamera(Camera/*Camera|Null*/ v);

    external WebVRFreeCamera get webVRCamera;

    external set webVRCamera(WebVRFreeCamera v);

    external VRDeviceOrientationFreeCamera/*VRDeviceOrientationFreeCamera|Null*/ get vrDeviceOrientationCamera;

    external set vrDeviceOrientationCamera(VRDeviceOrientationFreeCamera/*VRDeviceOrientationFreeCamera|Null*/ v);

    external get JS$_teleportationRequestInitiated;

    external set JS$_teleportationRequestInitiated(v);

    external factory VRExperienceHelper(Scene scene, [VRExperienceHelperOptions webVROptions]);

    external get JS$_onDefaultMeshLoaded;

    external set JS$_onDefaultMeshLoaded(v);

    external get JS$_onResize;

    external set JS$_onResize(v);

    external get JS$_onFullscreenChange;

    external set JS$_onFullscreenChange(v);

    external bool get isInVRMode;

    external set isInVRMode(bool v);

    external get onVrDisplayPresentChange;

    external set onVrDisplayPresentChange(v);

    external get onVRDisplayChanged;

    external set onVRDisplayChanged(v);

    external get moveButtonToBottomRight;

    external set moveButtonToBottomRight(v);

    external get displayVRButton;

    external set displayVRButton(v);

    external get updateButtonVisibility;

    external set updateButtonVisibility(v);

    external void enterVR();

    external void exitVR();

    external Vector3 get position;

    external set position(Vector3 v);

    external void enableInteractions();

    external get JS$_noControllerIsActive;

    external set JS$_noControllerIsActive(v);

    external get beforeRender;

    external set beforeRender(v);

    external get JS$_isTeleportationFloor;

    external set JS$_isTeleportationFloor(v);

    external void addFloorMesh(Mesh floorMesh);

    external void removeFloorMesh(Mesh floorMesh);

    external void enableTeleportation([VRTeleportationOptions vrTeleportationOptions]);

    external get JS$_onNewGamepadConnected;

    external set JS$_onNewGamepadConnected(v);

    external get JS$_tryEnableInteractionOnController;

    external set JS$_tryEnableInteractionOnController(v);

    external get JS$_onNewGamepadDisconnected;

    external set JS$_onNewGamepadDisconnected(v);

    external get JS$_enableInteractionOnController;

    external set JS$_enableInteractionOnController(v);

    external get JS$_checkTeleportWithRay;

    external set JS$_checkTeleportWithRay(v);

    external get JS$_checkRotate;

    external set JS$_checkRotate(v);

    external get JS$_checkTeleportBackwards;

    external set JS$_checkTeleportBackwards(v);

    external get JS$_enableTeleportationOnController;

    external set JS$_enableTeleportationOnController(v);

    external get JS$_createTeleportationCircles;

    external set JS$_createTeleportationCircles(v);

    external get JS$_displayTeleportationTarget;

    external set JS$_displayTeleportationTarget(v);

    external get JS$_hideTeleportationTarget;

    external set JS$_hideTeleportationTarget(v);

    external get JS$_rotateCamera;

    external set JS$_rotateCamera(v);

    external get JS$_moveTeleportationSelectorTo;

    external set JS$_moveTeleportationSelectorTo(v);

    external get JS$_workingVector;

    external set JS$_workingVector(v);

    external get JS$_workingQuaternion;

    external set JS$_workingQuaternion(v);

    external get JS$_workingMatrix;

    external set JS$_workingMatrix(v);

    external void teleportCamera(Vector3 location);

    external get JS$_convertNormalToDirectionOfRay;

    external set JS$_convertNormalToDirectionOfRay(v);

    external get JS$_castRayAndSelectObject;

    external set JS$_castRayAndSelectObject(v);

    external get JS$_notifySelectedMeshUnselected;

    external set JS$_notifySelectedMeshUnselected(v);

    external void changeLaserColor(Color3 color);

    external void changeGazeColor(Color3 color);

    external void dispose();

    external String getClassName();
}

@anonymous
@JS()
abstract class DevicePose {
    external Float32List/*Float32List|Null*/ get position;

    external set position(Float32List/*Float32List|Null*/ v);

    external Float32List/*Float32List|Null*/ get linearVelocity;

    external set linearVelocity(Float32List/*Float32List|Null*/ v);

    external Float32List/*Float32List|Null*/ get linearAcceleration;

    external set linearAcceleration(Float32List/*Float32List|Null*/ v);

    external Float32List/*Float32List|Null*/ get orientation;

    external set orientation(Float32List/*Float32List|Null*/ v);

    external Float32List/*Float32List|Null*/ get angularVelocity;

    external set angularVelocity(Float32List/*Float32List|Null*/ v);

    external Float32List/*Float32List|Null*/ get angularAcceleration;

    external set angularAcceleration(Float32List/*Float32List|Null*/ v);

    external factory DevicePose({ Float32List/*Float32List|Null*/ position, Float32List/*Float32List|Null*/ linearVelocity, Float32List/*Float32List|Null*/ linearAcceleration, Float32List/*Float32List|Null*/ orientation, Float32List/*Float32List|Null*/ angularVelocity, Float32List/*Float32List|Null*/ angularAcceleration});
}

@anonymous
@JS()
abstract class PoseControlled {
    external Vector3 get position;

    external set position(Vector3 v);

    external Quaternion get rotationQuaternion;

    external set rotationQuaternion(Quaternion v);

    external Vector3 get devicePosition;

    external set devicePosition(Vector3 v);

    external Quaternion get deviceRotationQuaternion;

    external set deviceRotationQuaternion(Quaternion v);

    external DevicePose/*DevicePose|Null*/ get rawPose;

    external set rawPose(DevicePose/*DevicePose|Null*/ v);

    external num get deviceScaleFactor;

    external set deviceScaleFactor(num v);

    external void updateFromDevice(DevicePose poseData);
}

@anonymous
@JS()
abstract class WebVROptions {
    external bool get trackPosition;

    external set trackPosition(bool v);

    external num get positionScale;

    external set positionScale(num v);

    external String get displayName;

    external set displayName(String v);

    external bool get controllerMeshes;

    external set controllerMeshes(bool v);

    external bool get defaultLightingOnControllers;

    external set defaultLightingOnControllers(bool v);

    external bool get useCustomVRButton;

    external set useCustomVRButton(bool v);

    external ButtonElement get customVRButton;

    external set customVRButton(ButtonElement v);

    external num get rayLength;

    external set rayLength(num v);

    external num get defaultHeight;

    external set defaultHeight(num v);

    external factory WebVROptions({ bool trackPosition, num positionScale, String displayName, bool controllerMeshes, bool defaultLightingOnControllers, bool useCustomVRButton, ButtonElement customVRButton, num rayLength, num defaultHeight});
}

@JS("BABYLON.WebVRFreeCamera")
class WebVRFreeCamera extends FreeCamera implements PoseControlled {
    // @Ignore
    WebVRFreeCamera .fakeConstructor$() : super.fakeConstructor$();
    external get webVROptions;

    external set webVROptions(v);

    external dynamic get JS$_vrDevice;

    external set JS$_vrDevice(dynamic v);

    external DevicePose/*DevicePose|Null*/ get rawPose;

    external set rawPose(DevicePose/*DevicePose|Null*/ v);

    external get JS$_onVREnabled;

    external set JS$_onVREnabled(v);

    external get JS$_specsVersion;

    external set JS$_specsVersion(v);

    external get JS$_attached;

    external set JS$_attached(v);

    external get JS$_frameData;

    external set JS$_frameData(v);

    external List<Node> get JS$_descendants;

    external set JS$_descendants(List<Node> v);

    external get JS$_deviceRoomPosition;

    external set JS$_deviceRoomPosition(v);

    external Quaternion get JS$_deviceRoomRotationQuaternion;

    external set JS$_deviceRoomRotationQuaternion(Quaternion v);

    external get JS$_standingMatrix;

    external set JS$_standingMatrix(v);

    external Vector3 get devicePosition;

    external set devicePosition(Vector3 v);

    external Quaternion get deviceRotationQuaternion;

    external set deviceRotationQuaternion(Quaternion v);

    external num get deviceScaleFactor;

    external set deviceScaleFactor(num v);

    external get JS$_deviceToWorld;

    external set JS$_deviceToWorld(v);

    external get JS$_worldToDevice;

    external set JS$_worldToDevice(v);

    external List<WebVRController> get controllers;

    external set controllers(List<WebVRController> v);

    external Observable<List<WebVRController>> get onControllersAttachedObservable;

    external set onControllersAttachedObservable(Observable<List<WebVRController>> v);

    external Observable<WebVRController> get onControllerMeshLoadedObservable;

    external set onControllerMeshLoadedObservable(Observable<WebVRController> v);

    external Observable<dynamic> get onPoseUpdatedFromDeviceObservable;

    external set onPoseUpdatedFromDeviceObservable(Observable<dynamic> v);

    external get JS$_poseSet;

    external set JS$_poseSet(v);

    external bool get rigParenting;

    external set rigParenting(bool v);

    external get JS$_lightOnControllers;

    external set JS$_lightOnControllers(v);

    external get JS$_defaultHeight;

    external set JS$_defaultHeight(v);

    external factory WebVRFreeCamera(String name, Vector3 position, Scene scene, [WebVROptions webVROptions]);

    external num deviceDistanceToRoomGround();

    external void useStandingMatrix([void callback(bool bool)]);

    external Promise<bool> useStandingMatrixAsync();

    external void dispose();

    external WebVRController/*WebVRController|Null*/ getControllerByName(String name);

    external get JS$_leftController;

    external set JS$_leftController(v);

    external WebVRController/*WebVRController|Null*/ get leftController;

    external set leftController(WebVRController/*WebVRController|Null*/ v);

    external get JS$_rightController;

    external set JS$_rightController(v);

    external WebVRController/*WebVRController|Null*/ get rightController;

    external set rightController(WebVRController/*WebVRController|Null*/ v);

    external Ray getForwardRay([num length]);

    external void JS$_checkInputs();

    external void updateFromDevice(DevicePose poseData);

    external get JS$_htmlElementAttached;

    external set JS$_htmlElementAttached(v);

    external get JS$_detachIfAttached;

    external set JS$_detachIfAttached(v);

    external void attachControl(HtmlElement element, [bool noPreventDefault]);

    external void detachControl(HtmlElement element);

    external String getClassName();

    external void resetToCurrentRotation();

    external void JS$_updateRigCameras();

    external get JS$_workingVector;

    external set JS$_workingVector(v);

    external get JS$_oneVector;

    external set JS$_oneVector(v);

    external get JS$_workingMatrix;

    external set JS$_workingMatrix(v);

    external get updateCacheCalled;

    external set updateCacheCalled(v);

    external get JS$_correctPositionIfNotTrackPosition;

    external set JS$_correctPositionIfNotTrackPosition(v);

    external void JS$_updateCache([bool ignoreParentClass]);

    external void JS$_computeDevicePosition();

    external void update();

    external Matrix JS$_getViewMatrix();

    external get JS$_tmpMatrix;

    external set JS$_tmpMatrix(v);

    external Matrix JS$_getWebVRViewMatrix();

    external Matrix JS$_getWebVRProjectionMatrix();

    external get JS$_onGamepadConnectedObserver;

    external set JS$_onGamepadConnectedObserver(v);

    external get JS$_onGamepadDisconnectedObserver;

    external set JS$_onGamepadDisconnectedObserver(v);

    external get JS$_updateCacheWhenTrackingDisabledObserver;

    external set JS$_updateCacheWhenTrackingDisabledObserver(v);

    external void initControllers();
}

@JS("BABYLON._OcclusionDataStorage")
class JS$_OcclusionDataStorage {
    // @Ignore
    JS$_OcclusionDataStorage .fakeConstructor$();

    external num get occlusionInternalRetryCounter;

    external set occlusionInternalRetryCounter(num v);

    external bool get isOcclusionQueryInProgress;

    external set isOcclusionQueryInProgress(bool v);

    external bool get isOccluded;

    external set isOccluded(bool v);

    external num get occlusionRetryCount;

    external set occlusionRetryCount(num v);

    external num get occlusionType;

    external set occlusionType(num v);

    external num get occlusionQueryAlgorithmType;

    external set occlusionQueryAlgorithmType(num v);
}

@anonymous
@JS()
abstract class IOctreeContainer<T> {
    external List<OctreeBlock<T>> get blocks;

    external set blocks(List<OctreeBlock<T>> v);

    external factory IOctreeContainer({ List<OctreeBlock<T>> blocks});
}

@JS("BABYLON.Octree")
class Octree<T> {
    // @Ignore
    Octree .fakeConstructor$();

    external num get maxDepth;

    external set maxDepth(num v);

    external List<OctreeBlock<T>> get blocks;

    external set blocks(List<OctreeBlock<T>> v);

    external List<T> get dynamicContent;

    external set dynamicContent(List<T> v);

    external get JS$_maxBlockCapacity;

    external set JS$_maxBlockCapacity(v);

    external get JS$_selectionContent;

    external set JS$_selectionContent(v);

    external get JS$_creationFunc;

    external set JS$_creationFunc(v);

    external factory Octree(void creationFunc(T entry, OctreeBlock<T> block), [num maxBlockCapacity, num maxDepth]);

    external void update(Vector3 worldMin, Vector3 worldMax, List<T> entries);

    external void addMesh(T entry);

    external SmartArray<T> select(List<Plane> frustumPlanes, [bool allowDuplicate]);

    external SmartArray<T> intersects(Vector3 sphereCenter, num sphereRadius, [bool allowDuplicate]);

    external SmartArray<T> intersectsRay(Ray ray);

    external static void JS$_CreateBlocks /*<T>*/(Vector3 worldMin, Vector3 worldMax, List<dynamic /*=T*/> entries, num maxBlockCapacity, num currentDepth, num maxDepth, IOctreeContainer<dynamic /*=T*/> target, void creationFunc(dynamic/*=T*/ entry, OctreeBlock<dynamic /*=T*/> block));

    external static VoidFunc2<AbstractMesh, OctreeBlock<AbstractMesh>> get CreationFuncForMeshes;

    external static set CreationFuncForMeshes(VoidFunc2<AbstractMesh, OctreeBlock<AbstractMesh>> v);

    external static VoidFunc2<SubMesh, OctreeBlock<SubMesh>> get CreationFuncForSubMeshes;

    external static set CreationFuncForSubMeshes(VoidFunc2<SubMesh, OctreeBlock<SubMesh>> v);
}

@JS("BABYLON.OctreeBlock")
class OctreeBlock<T> {
    // @Ignore
    OctreeBlock .fakeConstructor$();

    external List<T> get entries;

    external set entries(List<T> v);

    external List<OctreeBlock<T>> get blocks;

    external set blocks(List<OctreeBlock<T>> v);

    external get JS$_depth;

    external set JS$_depth(v);

    external get JS$_maxDepth;

    external set JS$_maxDepth(v);

    external get JS$_capacity;

    external set JS$_capacity(v);

    external get JS$_minPoint;

    external set JS$_minPoint(v);

    external get JS$_maxPoint;

    external set JS$_maxPoint(v);

    external get JS$_boundingVectors;

    external set JS$_boundingVectors(v);

    external get JS$_creationFunc;

    external set JS$_creationFunc(v);

    external factory OctreeBlock(Vector3 minPoint, Vector3 maxPoint, num capacity, num depth, num maxDepth, void creationFunc(T entry, OctreeBlock<T> block));

    external num get capacity;

    external set capacity(num v);

    external Vector3 get minPoint;

    external set minPoint(Vector3 v);

    external Vector3 get maxPoint;

    external set maxPoint(Vector3 v);

    external void addEntry(T entry);

    external void addEntries(List<T> entries);

    external void select(List<Plane> frustumPlanes, SmartArrayNoDuplicate<T> selection, [bool allowDuplicate]);

    external void intersects(Vector3 sphereCenter, num sphereRadius, SmartArrayNoDuplicate<T> selection, [bool allowDuplicate]);

    external void intersectsRay(Ray ray, SmartArrayNoDuplicate<T> selection);

    external void createInnerBlocks();
}

@JS("BABYLON.OctreeSceneComponent")
class OctreeSceneComponent {
    // @Ignore
    OctreeSceneComponent .fakeConstructor$();

    external String get name;

    external set name(String v);

    external Scene get scene;

    external set scene(Scene v);

    external bool get checksIsEnabled;

    external set checksIsEnabled(bool v);

    external factory OctreeSceneComponent(Scene scene);

    external void register();

    external ISmartArrayLike<AbstractMesh> getActiveMeshCandidates();

    external ISmartArrayLike<SubMesh> getActiveSubMeshCandidates(AbstractMesh mesh);

    external get JS$_tempRay;

    external set JS$_tempRay(v);

    external ISmartArrayLike<SubMesh> getIntersectingSubMeshCandidates(AbstractMesh mesh, Ray localRay);

    external ISmartArrayLike<SubMesh> getCollidingSubMeshCandidates(AbstractMesh mesh, Collider collider);

    external void rebuild();

    external void dispose();
}

@JS("BABYLON.DaydreamController")
class DaydreamController extends WebVRController {
    // @Ignore
    DaydreamController .fakeConstructor$() : super.fakeConstructor$();
    external static String get MODEL_BASE_URL;

    external static set MODEL_BASE_URL(String v);

    external static String get MODEL_FILENAME;

    external static set MODEL_FILENAME(String v);

    external static String get GAMEPAD_ID_PREFIX;

    external static set GAMEPAD_ID_PREFIX(String v);

    external factory DaydreamController(dynamic vrGamepad);

    external void initControllerMesh(Scene scene, [void meshLoaded(AbstractMesh mesh)]);

    external void JS$_handleButtonChange(num buttonIdx, ExtendedGamepadButton state, GamepadButtonChanges changes);
}

@JS("BABYLON.GearVRController")
class GearVRController extends WebVRController {
    // @Ignore
    GearVRController .fakeConstructor$() : super.fakeConstructor$();
    external static String get MODEL_BASE_URL;

    external static set MODEL_BASE_URL(String v);

    external static String get MODEL_FILENAME;

    external static set MODEL_FILENAME(String v);

    external static String get GAMEPAD_ID_PREFIX;

    external static set GAMEPAD_ID_PREFIX(String v);

    external get JS$_buttonIndexToObservableNameMap;

    external set JS$_buttonIndexToObservableNameMap(v);

    external factory GearVRController(dynamic vrGamepad);

    external void initControllerMesh(Scene scene, [void meshLoaded(AbstractMesh mesh)]);

    external void JS$_handleButtonChange(num buttonIdx, ExtendedGamepadButton state, GamepadButtonChanges changes);
}

@JS("BABYLON.GenericController")
class GenericController extends WebVRController {
    // @Ignore
    GenericController .fakeConstructor$() : super.fakeConstructor$();
    external static String get MODEL_BASE_URL;

    external static set MODEL_BASE_URL(String v);

    external static String get MODEL_FILENAME;

    external static set MODEL_FILENAME(String v);

    external factory GenericController(dynamic vrGamepad);

    external void initControllerMesh(Scene scene, [void meshLoaded(AbstractMesh mesh)]);

    external void JS$_handleButtonChange(num buttonIdx, ExtendedGamepadButton state, GamepadButtonChanges changes);
}

@JS("BABYLON.OculusTouchController")
class OculusTouchController extends WebVRController {
    // @Ignore
    OculusTouchController .fakeConstructor$() : super.fakeConstructor$();
    external static String get MODEL_BASE_URL;

    external static set MODEL_BASE_URL(String v);

    external static String get MODEL_LEFT_FILENAME;

    external static set MODEL_LEFT_FILENAME(String v);

    external static String get MODEL_RIGHT_FILENAME;

    external static set MODEL_RIGHT_FILENAME(String v);

    external Observable<ExtendedGamepadButton> get onSecondaryTriggerStateChangedObservable;

    external set onSecondaryTriggerStateChangedObservable(Observable<ExtendedGamepadButton> v);

    external Observable<ExtendedGamepadButton> get onThumbRestChangedObservable;

    external set onThumbRestChangedObservable(Observable<ExtendedGamepadButton> v);

    external factory OculusTouchController(dynamic vrGamepad);

    external void initControllerMesh(Scene scene, [void meshLoaded(AbstractMesh mesh)]);

    external Observable<ExtendedGamepadButton> get onAButtonStateChangedObservable;

    external set onAButtonStateChangedObservable(Observable<ExtendedGamepadButton> v);

    external Observable<ExtendedGamepadButton> get onBButtonStateChangedObservable;

    external set onBButtonStateChangedObservable(Observable<ExtendedGamepadButton> v);

    external Observable<ExtendedGamepadButton> get onXButtonStateChangedObservable;

    external set onXButtonStateChangedObservable(Observable<ExtendedGamepadButton> v);

    external Observable<ExtendedGamepadButton> get onYButtonStateChangedObservable;

    external set onYButtonStateChangedObservable(Observable<ExtendedGamepadButton> v);

    external void JS$_handleButtonChange(num buttonIdx, ExtendedGamepadButton state, GamepadButtonChanges changes);
}

@JS("BABYLON.PoseEnabledControllerType")
class PoseEnabledControllerType {
    external static num get VIVE;

    external static num get OCULUS;

    external static num get WINDOWS;

    external static num get GEAR_VR;

    external static num get DAYDREAM;

    external static num get GENERIC;
}

@anonymous
@JS()
abstract class MutableGamepadButton {
    external num get value;

    external set value(num v);

    external bool get touched;

    external set touched(bool v);

    external bool get pressed;

    external set pressed(bool v);

    external factory MutableGamepadButton({ num value, bool touched, bool pressed});
}

@anonymous
@JS()
abstract class ExtendedGamepadButton
    implements GamepadButton {
    external bool get pressed;

    external set pressed(bool v);

    external bool get touched;

    external set touched(bool v);

    external num get value;

    external set value(num v);

    external factory ExtendedGamepadButton({ bool pressed, bool touched, num value});
}

@JS("BABYLON.PoseEnabledControllerHelper")
class PoseEnabledControllerHelper {
    // @Ignore
    PoseEnabledControllerHelper .fakeConstructor$();

    external static dynamic/*OculusTouchController|WindowsMotionController|ViveController|GearVRController|DaydreamController|GenericController*/ InitiateController(dynamic vrGamepad);
}

@JS("BABYLON.PoseEnabledController")
class PoseEnabledController extends Gamepad implements PoseControlled {
    // @Ignore
    PoseEnabledController .fakeConstructor$() : super.fakeConstructor$();
    external get JS$_deviceRoomPosition;

    external set JS$_deviceRoomPosition(v);

    external get JS$_deviceRoomRotationQuaternion;

    external set JS$_deviceRoomRotationQuaternion(v);

    external Vector3 get devicePosition;

    external set devicePosition(Vector3 v);

    external Quaternion get deviceRotationQuaternion;

    external set deviceRotationQuaternion(Quaternion v);

    external num get deviceScaleFactor;

    external set deviceScaleFactor(num v);

    external Vector3 get position;

    external set position(Vector3 v);

    external Quaternion get rotationQuaternion;

    external set rotationQuaternion(Quaternion v);

    external num/*enum PoseEnabledControllerType*/ get controllerType;

    external set controllerType(num/*enum PoseEnabledControllerType*/ v);

    external Vector3 get JS$_calculatedPosition;

    external set JS$_calculatedPosition(Vector3 v);

    external get JS$_calculatedRotation;

    external set JS$_calculatedRotation(v);

    external DevicePose get rawPose;

    external set rawPose(DevicePose v);

    external get JS$_trackPosition;

    external set JS$_trackPosition(v);

    external get JS$_maxRotationDistFromHeadset;

    external set JS$_maxRotationDistFromHeadset(v);

    external get JS$_draggedRoomRotation;

    external set JS$_draggedRoomRotation(v);

    external void JS$_disableTrackPosition(Vector3 fixedPosition);

    external AbstractMesh/*AbstractMesh|Null*/ get JS$_mesh;

    external set JS$_mesh(AbstractMesh/*AbstractMesh|Null*/ v);

    external get JS$_poseControlledCamera;

    external set JS$_poseControlledCamera(v);

    external get JS$_leftHandSystemQuaternion;

    external set JS$_leftHandSystemQuaternion(v);

    external Matrix get JS$_deviceToWorld;

    external set JS$_deviceToWorld(Matrix v);

    external AbstractMesh/*AbstractMesh|Null*/ get JS$_pointingPoseNode;

    external set JS$_pointingPoseNode(AbstractMesh/*AbstractMesh|Null*/ v);

    external static String get POINTING_POSE;

    external static set POINTING_POSE(String v);

    external factory PoseEnabledController(dynamic browserGamepad);

    external get JS$_workingMatrix;

    external set JS$_workingMatrix(v);

    external void update();

    external void JS$_updatePoseAndMesh();

    external void updateFromDevice(DevicePose poseData);

    external Observable<AbstractMesh> get JS$_meshAttachedObservable;

    external set JS$_meshAttachedObservable(Observable<AbstractMesh> v);

    external void attachToMesh(AbstractMesh mesh);

    external void attachToPoseControlledCamera(TargetCamera camera);

    external void dispose();

    external AbstractMesh/*AbstractMesh|Null*/ get mesh;

    external set mesh(AbstractMesh/*AbstractMesh|Null*/ v);

    external Ray getForwardRay([num length]);
}

@JS("BABYLON.ViveController")
class ViveController extends WebVRController {
    // @Ignore
    ViveController .fakeConstructor$() : super.fakeConstructor$();
    external static String get MODEL_BASE_URL;

    external static set MODEL_BASE_URL(String v);

    external static String get MODEL_FILENAME;

    external static set MODEL_FILENAME(String v);

    external factory ViveController(dynamic vrGamepad);

    external void initControllerMesh(Scene scene, [void meshLoaded(AbstractMesh mesh)]);

    external Observable<ExtendedGamepadButton> get onLeftButtonStateChangedObservable;

    external set onLeftButtonStateChangedObservable(Observable<ExtendedGamepadButton> v);

    external Observable<ExtendedGamepadButton> get onRightButtonStateChangedObservable;

    external set onRightButtonStateChangedObservable(Observable<ExtendedGamepadButton> v);

    external Observable<ExtendedGamepadButton> get onMenuButtonStateChangedObservable;

    external set onMenuButtonStateChangedObservable(Observable<ExtendedGamepadButton> v);

    external void JS$_handleButtonChange(num buttonIdx, ExtendedGamepadButton state, GamepadButtonChanges changes);
}

@JS("BABYLON.WebVRController")
abstract class WebVRController extends PoseEnabledController {
    // @Ignore
    WebVRController .fakeConstructor$() : super.fakeConstructor$();
    external AbstractMesh get JS$_defaultModel;

    external set JS$_defaultModel(AbstractMesh v);

    external Observable<ExtendedGamepadButton> get onTriggerStateChangedObservable;

    external set onTriggerStateChangedObservable(Observable<ExtendedGamepadButton> v);

    external Observable<ExtendedGamepadButton> get onMainButtonStateChangedObservable;

    external set onMainButtonStateChangedObservable(Observable<ExtendedGamepadButton> v);

    external Observable<ExtendedGamepadButton> get onSecondaryButtonStateChangedObservable;

    external set onSecondaryButtonStateChangedObservable(Observable<ExtendedGamepadButton> v);

    external Observable<ExtendedGamepadButton> get onPadStateChangedObservable;

    external set onPadStateChangedObservable(Observable<ExtendedGamepadButton> v);

    external Observable<StickValues> get onPadValuesChangedObservable;

    external set onPadValuesChangedObservable(Observable<StickValues> v);

    external List<MutableGamepadButton> get JS$_buttons;

    external set JS$_buttons(List<MutableGamepadButton> v);

    external get JS$_onButtonStateChange;

    external set JS$_onButtonStateChange(v);

    external void onButtonStateChange(void callback(num controlledIndex, num buttonIndex, ExtendedGamepadButton state));

    external StickValues get pad;

    external set pad(StickValues v);

    external String get hand;

    external set hand(String v);

    external AbstractMesh get defaultModel;

    external set defaultModel(AbstractMesh v);

    external factory WebVRController(dynamic vrGamepad);

    external void update();

    external void JS$_handleButtonChange(num buttonIdx, ExtendedGamepadButton value, GamepadButtonChanges changes);

    external void initControllerMesh(Scene scene, [void meshLoaded(AbstractMesh mesh)]);

    external get JS$_setButtonValue;

    external set JS$_setButtonValue(v);

    external get JS$_changes;

    external set JS$_changes(v);

    external get JS$_checkChanges;

    external set JS$_checkChanges(v);

    external void dispose();
}

@JS("BABYLON.WindowsMotionController")
class WindowsMotionController extends WebVRController {
    // @Ignore
    WindowsMotionController .fakeConstructor$() : super.fakeConstructor$();
    external static String get MODEL_BASE_URL;

    external static set MODEL_BASE_URL(String v);

    external static String get MODEL_LEFT_FILENAME;

    external static set MODEL_LEFT_FILENAME(String v);

    external static String get MODEL_RIGHT_FILENAME;

    external static set MODEL_RIGHT_FILENAME(String v);

    external static String get GAMEPAD_ID_PREFIX;

    external static set GAMEPAD_ID_PREFIX(String v);

    external static get GAMEPAD_ID_PATTERN;

    external static set GAMEPAD_ID_PATTERN(v);

    external get JS$_loadedMeshInfo;

    external set JS$_loadedMeshInfo(v);

    external get JS$_mapping;

    external set JS$_mapping(v);

    external Observable<ExtendedGamepadButton> get onTrackpadChangedObservable;

    external set onTrackpadChangedObservable(Observable<ExtendedGamepadButton> v);

    external Observable<StickValues> get onTrackpadValuesChangedObservable;

    external set onTrackpadValuesChangedObservable(Observable<StickValues> v);

    external StickValues get trackpad;

    external set trackpad(StickValues v);

    external factory WindowsMotionController(dynamic vrGamepad);

    external Observable<ExtendedGamepadButton> get onTriggerButtonStateChangedObservable;

    external set onTriggerButtonStateChangedObservable(Observable<ExtendedGamepadButton> v);

    external Observable<ExtendedGamepadButton> get onMenuButtonStateChangedObservable;

    external set onMenuButtonStateChangedObservable(Observable<ExtendedGamepadButton> v);

    external Observable<ExtendedGamepadButton> get onGripButtonStateChangedObservable;

    external set onGripButtonStateChangedObservable(Observable<ExtendedGamepadButton> v);

    external Observable<ExtendedGamepadButton> get onThumbstickButtonStateChangedObservable;

    external set onThumbstickButtonStateChangedObservable(Observable<ExtendedGamepadButton> v);

    external Observable<ExtendedGamepadButton> get onTouchpadButtonStateChangedObservable;

    external set onTouchpadButtonStateChangedObservable(Observable<ExtendedGamepadButton> v);

    external Observable<StickValues> get onTouchpadValuesChangedObservable;

    external set onTouchpadValuesChangedObservable(Observable<StickValues> v);

    external get JS$_updateTrackpad;

    external set JS$_updateTrackpad(v);

    external void update();

    external void JS$_handleButtonChange(num buttonIdx, ExtendedGamepadButton state, GamepadButtonChanges changes);

    external void JS$_lerpButtonTransform(String buttonName, num buttonValue);

    external void JS$_lerpAxisTransform(num axis, num axisValue);

    external void initControllerMesh(Scene scene, [void meshLoaded(AbstractMesh mesh), bool forceDefault]);

    external get processModel;

    external set processModel(v);

    external get createMeshInfo;

    external set createMeshInfo(v);

    external Ray getForwardRay([num length]);

    external void dispose();
}

@anonymous
@JS()
abstract class IShadowGenerator {
    external RenderTargetTexture/*RenderTargetTexture|Null*/ getShadowMap();

    external RenderTargetTexture/*RenderTargetTexture|Null*/ getShadowMapForRendering();

    external bool isReady(SubMesh subMesh, bool useInstances);

    external void prepareDefines(MaterialDefines defines, num lightIndex);

    external void bindShadowLight(String lightIndex, Effect effect);

    external Matrix getTransformMatrix();

    external void recreateShadowMap();

    external void forceCompilation([void onCompiled(ShadowGenerator generator), Partial<dynamic /*{
            useInstances: boolean;
        }*/> options]);

    external Promise<Null> forceCompilationAsync([Partial<dynamic /*{
            useInstances: boolean;
        }*/> options]);

    external dynamic serialize();

    external void dispose();
}

@JS("BABYLON.ShadowGenerator")
class ShadowGenerator implements IShadowGenerator {
    // @Ignore
    ShadowGenerator .fakeConstructor$();

    external static num get FILTER_NONE;

    external static set FILTER_NONE(num v);

    external static num get FILTER_EXPONENTIALSHADOWMAP;

    external static set FILTER_EXPONENTIALSHADOWMAP(num v);

    external static num get FILTER_POISSONSAMPLING;

    external static set FILTER_POISSONSAMPLING(num v);

    external static num get FILTER_BLUREXPONENTIALSHADOWMAP;

    external static set FILTER_BLUREXPONENTIALSHADOWMAP(num v);

    external static num get FILTER_CLOSEEXPONENTIALSHADOWMAP;

    external static set FILTER_CLOSEEXPONENTIALSHADOWMAP(num v);

    external static num get FILTER_BLURCLOSEEXPONENTIALSHADOWMAP;

    external static set FILTER_BLURCLOSEEXPONENTIALSHADOWMAP(num v);

    external static num get FILTER_PCF;

    external static set FILTER_PCF(num v);

    external static num get FILTER_PCSS;

    external static set FILTER_PCSS(num v);

    external static num get QUALITY_HIGH;

    external static set QUALITY_HIGH(num v);

    external static num get QUALITY_MEDIUM;

    external static set QUALITY_MEDIUM(num v);

    external static num get QUALITY_LOW;

    external static set QUALITY_LOW(num v);

    external get JS$_bias;

    external set JS$_bias(v);

    external num get bias;

    external set bias(num v);

    external get JS$_normalBias;

    external set JS$_normalBias(v);

    external num get normalBias;

    external set normalBias(num v);

    external get JS$_blurBoxOffset;

    external set JS$_blurBoxOffset(v);

    external num get blurBoxOffset;

    external set blurBoxOffset(num v);

    external get JS$_blurScale;

    external set JS$_blurScale(v);

    external num get blurScale;

    external set blurScale(num v);

    external get JS$_blurKernel;

    external set JS$_blurKernel(v);

    external num get blurKernel;

    external set blurKernel(num v);

    external get JS$_useKernelBlur;

    external set JS$_useKernelBlur(v);

    external bool get useKernelBlur;

    external set useKernelBlur(bool v);

    external get JS$_depthScale;

    external set JS$_depthScale(v);

    external num get depthScale;

    external set depthScale(num v);

    external get JS$_filter;

    external set JS$_filter(v);

    external num get filter;

    external set filter(num v);

    external bool get usePoissonSampling;

    external set usePoissonSampling(bool v);

    external bool get useVarianceShadowMap;

    external set useVarianceShadowMap(bool v);

    external bool get useBlurVarianceShadowMap;

    external set useBlurVarianceShadowMap(bool v);

    external bool get useExponentialShadowMap;

    external set useExponentialShadowMap(bool v);

    external bool get useBlurExponentialShadowMap;

    external set useBlurExponentialShadowMap(bool v);

    external bool get useCloseExponentialShadowMap;

    external set useCloseExponentialShadowMap(bool v);

    external bool get useBlurCloseExponentialShadowMap;

    external set useBlurCloseExponentialShadowMap(bool v);

    external bool get usePercentageCloserFiltering;

    external set usePercentageCloserFiltering(bool v);

    external get JS$_filteringQuality;

    external set JS$_filteringQuality(v);

    external num get filteringQuality;

    external set filteringQuality(num v);

    external bool get useContactHardeningShadow;

    external set useContactHardeningShadow(bool v);

    external get JS$_contactHardeningLightSizeUVRatio;

    external set JS$_contactHardeningLightSizeUVRatio(v);

    external num get contactHardeningLightSizeUVRatio;

    external set contactHardeningLightSizeUVRatio(num v);

    external get JS$_darkness;

    external set JS$_darkness(v);

    external num getDarkness();

    external ShadowGenerator setDarkness(num darkness);

    external get JS$_transparencyShadow;

    external set JS$_transparencyShadow(v);

    external ShadowGenerator setTransparencyShadow(bool transparent);

    external get JS$_shadowMap;

    external set JS$_shadowMap(v);

    external get JS$_shadowMap2;

    external set JS$_shadowMap2(v);

    external RenderTargetTexture/*RenderTargetTexture|Null*/ getShadowMap();

    external RenderTargetTexture/*RenderTargetTexture|Null*/ getShadowMapForRendering();

    external ShadowGenerator addShadowCaster(AbstractMesh mesh, [bool includeDescendants]);

    external ShadowGenerator removeShadowCaster(AbstractMesh mesh, [bool includeDescendants]);

    external num get frustumEdgeFalloff;

    external set frustumEdgeFalloff(num v);

    external get JS$_light;

    external set JS$_light(v);

    external IShadowLight getLight();

    external bool get forceBackFacesOnly;

    external set forceBackFacesOnly(bool v);

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_lightDirection;

    external set JS$_lightDirection(v);

    external get JS$_effect;

    external set JS$_effect(v);

    external get JS$_viewMatrix;

    external set JS$_viewMatrix(v);

    external get JS$_projectionMatrix;

    external set JS$_projectionMatrix(v);

    external get JS$_transformMatrix;

    external set JS$_transformMatrix(v);

    external get JS$_cachedPosition;

    external set JS$_cachedPosition(v);

    external get JS$_cachedDirection;

    external set JS$_cachedDirection(v);

    external get JS$_cachedDefines;

    external set JS$_cachedDefines(v);

    external get JS$_currentRenderID;

    external set JS$_currentRenderID(v);

    external get JS$_boxBlurPostprocess;

    external set JS$_boxBlurPostprocess(v);

    external get JS$_kernelBlurXPostprocess;

    external set JS$_kernelBlurXPostprocess(v);

    external get JS$_kernelBlurYPostprocess;

    external set JS$_kernelBlurYPostprocess(v);

    external get JS$_blurPostProcesses;

    external set JS$_blurPostProcesses(v);

    external get JS$_mapSize;

    external set JS$_mapSize(v);

    external get JS$_currentFaceIndex;

    external set JS$_currentFaceIndex(v);

    external get JS$_currentFaceIndexCache;

    external set JS$_currentFaceIndexCache(v);

    external get JS$_textureType;

    external set JS$_textureType(v);

    external get JS$_defaultTextureMatrix;

    external set JS$_defaultTextureMatrix(v);

    external factory ShadowGenerator(num mapSize, IShadowLight light, [bool useFullFloatFirst]);

    external get JS$_initializeGenerator;

    external set JS$_initializeGenerator(v);

    external get JS$_initializeShadowMap;

    external set JS$_initializeShadowMap(v);

    external get JS$_initializeBlurRTTAndPostProcesses;

    external set JS$_initializeBlurRTTAndPostProcesses(v);

    external get JS$_renderForShadowMap;

    external set JS$_renderForShadowMap(v);

    external get JS$_renderSubMeshForShadowMap;

    external set JS$_renderSubMeshForShadowMap(v);

    external get JS$_applyFilterValues;

    external set JS$_applyFilterValues(v);

    external void forceCompilation([void onCompiled(ShadowGenerator generator), Partial<dynamic /*{
            useInstances: boolean;
        }*/> options]);

    external Promise<Null> forceCompilationAsync([Partial<dynamic /*{
            useInstances: boolean;
        }*/> options]);

    external bool isReady(SubMesh subMesh, bool useInstances);

    external void prepareDefines(dynamic defines, num lightIndex);

    external void bindShadowLight(String lightIndex, Effect effect);

    external Matrix getTransformMatrix();

    external void recreateShadowMap();

    external get JS$_disposeBlurPostProcesses;

    external set JS$_disposeBlurPostProcesses(v);

    external get JS$_disposeRTTandPostProcesses;

    external set JS$_disposeRTTandPostProcesses(v);

    external void dispose();

    external dynamic serialize();

    external static ShadowGenerator Parse(dynamic parsedShadowGenerator, Scene scene);
}

@JS("BABYLON.ShadowGeneratorSceneComponent")
class ShadowGeneratorSceneComponent implements ISceneSerializableComponent {
    // @Ignore
    ShadowGeneratorSceneComponent .fakeConstructor$();

    external String get name;

    external set name(String v);

    external Scene get scene;

    external set scene(Scene v);

    external factory ShadowGeneratorSceneComponent(Scene scene);

    external void register();

    external void rebuild();

    external void serialize(dynamic serializationObject);

    external void addFromContainer(AbstractScene container);

    external void removeFromContainer(AbstractScene container);

    external void dispose();

    external get JS$_gatherRenderTargets;

    external set JS$_gatherRenderTargets(v);
}

@JS("BABYLON.BackgroundMaterial")
class BackgroundMaterial extends PushMaterial {
    // @Ignore
    BackgroundMaterial .fakeConstructor$() : super.fakeConstructor$();
    external static num get StandardReflectance0;

    external static set StandardReflectance0(num v);

    external static num get StandardReflectance90;

    external static set StandardReflectance90(num v);

    external Color3 get JS$_primaryColor;

    external set JS$_primaryColor(Color3 v);

    external Color3 get primaryColor;

    external set primaryColor(Color3 v);

    external Color3/*Color3|Null*/ get JS$___perceptualColor;

    external set JS$___perceptualColor(Color3/*Color3|Null*/ v);

    external Color3/*Color3|Null*/ get JS$_perceptualColor;

    external set JS$_perceptualColor(Color3/*Color3|Null*/ v);

    external num get JS$_primaryColorShadowLevel;

    external set JS$_primaryColorShadowLevel(num v);

    external num get primaryColorShadowLevel;

    external set primaryColorShadowLevel(num v);

    external num get JS$_primaryColorHighlightLevel;

    external set JS$_primaryColorHighlightLevel(num v);

    external num get primaryColorHighlightLevel;

    external set primaryColorHighlightLevel(num v);

    external BaseTexture/*BaseTexture|Null*/ get JS$_reflectionTexture;

    external set JS$_reflectionTexture(BaseTexture/*BaseTexture|Null*/ v);

    external BaseTexture/*BaseTexture|Null*/ get reflectionTexture;

    external set reflectionTexture(BaseTexture/*BaseTexture|Null*/ v);

    external num get JS$_reflectionBlur;

    external set JS$_reflectionBlur(num v);

    external num get reflectionBlur;

    external set reflectionBlur(num v);

    external BaseTexture/*BaseTexture|Null*/ get JS$_diffuseTexture;

    external set JS$_diffuseTexture(BaseTexture/*BaseTexture|Null*/ v);

    external BaseTexture/*BaseTexture|Null*/ get diffuseTexture;

    external set diffuseTexture(BaseTexture/*BaseTexture|Null*/ v);

    external List<IShadowLight>/*List<IShadowLight>|Null*/ get JS$_shadowLights;

    external set JS$_shadowLights(List<IShadowLight>/*List<IShadowLight>|Null*/ v);

    external List<IShadowLight>/*List<IShadowLight>|Null*/ get shadowLights;

    external set shadowLights(List<IShadowLight>/*List<IShadowLight>|Null*/ v);

    external num get JS$_shadowLevel;

    external set JS$_shadowLevel(num v);

    external num get shadowLevel;

    external set shadowLevel(num v);

    external Vector3 get JS$_sceneCenter;

    external set JS$_sceneCenter(Vector3 v);

    external Vector3 get sceneCenter;

    external set sceneCenter(Vector3 v);

    external bool get JS$_opacityFresnel;

    external set JS$_opacityFresnel(bool v);

    external bool get opacityFresnel;

    external set opacityFresnel(bool v);

    external bool get JS$_reflectionFresnel;

    external set JS$_reflectionFresnel(bool v);

    external bool get reflectionFresnel;

    external set reflectionFresnel(bool v);

    external num get JS$_reflectionFalloffDistance;

    external set JS$_reflectionFalloffDistance(num v);

    external num get reflectionFalloffDistance;

    external set reflectionFalloffDistance(num v);

    external num get JS$_reflectionAmount;

    external set JS$_reflectionAmount(num v);

    external num get reflectionAmount;

    external set reflectionAmount(num v);

    external num get JS$_reflectionReflectance0;

    external set JS$_reflectionReflectance0(num v);

    external num get reflectionReflectance0;

    external set reflectionReflectance0(num v);

    external num get JS$_reflectionReflectance90;

    external set JS$_reflectionReflectance90(num v);

    external num get reflectionReflectance90;

    external set reflectionReflectance90(num v);

    external num get reflectionStandardFresnelWeight;

    external set reflectionStandardFresnelWeight(num v);

    external bool get JS$_useRGBColor;

    external set JS$_useRGBColor(bool v);

    external bool get useRGBColor;

    external set useRGBColor(bool v);

    external bool get JS$_enableNoise;

    external set JS$_enableNoise(bool v);

    external bool get enableNoise;

    external set enableNoise(bool v);

    external num get fovMultiplier;

    external set fovMultiplier(num v);

    external get JS$_fovMultiplier;

    external set JS$_fovMultiplier(v);

    external bool get useEquirectangularFOV;

    external set useEquirectangularFOV(bool v);

    external get JS$_maxSimultaneousLights;

    external set JS$_maxSimultaneousLights(v);

    external num get maxSimultaneousLights;

    external set maxSimultaneousLights(num v);

    external ImageProcessingConfiguration get JS$_imageProcessingConfiguration;

    external set JS$_imageProcessingConfiguration(ImageProcessingConfiguration v);

    external get JS$_imageProcessingObserver;

    external set JS$_imageProcessingObserver(v);

    external void JS$_attachImageProcessingConfiguration(ImageProcessingConfiguration/*ImageProcessingConfiguration|Null*/ configuration);

    external ImageProcessingConfiguration/*ImageProcessingConfiguration|Null*/ get imageProcessingConfiguration;

    external set imageProcessingConfiguration(ImageProcessingConfiguration/*ImageProcessingConfiguration|Null*/ v);

    external bool get cameraColorCurvesEnabled;

    external set cameraColorCurvesEnabled(bool v);

    external bool get cameraColorGradingEnabled;

    external set cameraColorGradingEnabled(bool v);

    external bool get cameraToneMappingEnabled;

    external set cameraToneMappingEnabled(bool v);

    external num get cameraExposure;

    external set cameraExposure(num v);

    external num get cameraContrast;

    external set cameraContrast(num v);

    external BaseTexture/*BaseTexture|Null*/ get cameraColorGradingTexture;

    external set cameraColorGradingTexture(BaseTexture/*BaseTexture|Null*/ v);

    external ColorCurves/*ColorCurves|Null*/ get cameraColorCurves;

    external set cameraColorCurves(ColorCurves/*ColorCurves|Null*/ v);

    external bool get switchToBGR;

    external set switchToBGR(bool v);

    external get JS$_renderTargets;

    external set JS$_renderTargets(v);

    external get JS$_reflectionControls;

    external set JS$_reflectionControls(v);

    external get JS$_white;

    external set JS$_white(v);

    external get JS$_primaryShadowColor;

    external set JS$_primaryShadowColor(v);

    external get JS$_primaryHighlightColor;

    external set JS$_primaryHighlightColor(v);

    external factory BackgroundMaterial(String name, Scene scene);

    external bool get hasRenderTargetTextures;

    external set hasRenderTargetTextures(bool v);

    external bool needAlphaTesting();

    external bool needAlphaBlending();

    external bool isReadyForSubMesh(AbstractMesh mesh, SubMesh subMesh, [bool useInstances]);

    external get JS$_computePrimaryColorFromPerceptualColor;

    external set JS$_computePrimaryColorFromPerceptualColor(v);

    external get JS$_computePrimaryColors;

    external set JS$_computePrimaryColors(v);

    external void buildUniformLayout();

    external void unbind();

    external void bindOnlyWorldMatrix(Matrix world);

    external void bindForSubMesh(Matrix world, Mesh mesh, SubMesh subMesh);

    external void dispose([bool forceDisposeEffect, bool forceDisposeTextures]);

    external BackgroundMaterial clone(String name);

    external dynamic serialize();

    external String getClassName();

    external static BackgroundMaterial Parse(dynamic source, Scene scene, String rootUrl);
}

@JS("BABYLON.PBRBaseMaterial")
abstract class PBRBaseMaterial extends PushMaterial {
    // @Ignore
    PBRBaseMaterial .fakeConstructor$() : super.fakeConstructor$();
    external static num get LIGHTFALLOFF_PHYSICAL;

    external static set LIGHTFALLOFF_PHYSICAL(num v);

    external static num get LIGHTFALLOFF_GLTF;

    external static set LIGHTFALLOFF_GLTF(num v);

    external static num get LIGHTFALLOFF_STANDARD;

    external static set LIGHTFALLOFF_STANDARD(num v);

    external num get JS$_directIntensity;

    external set JS$_directIntensity(num v);

    external num get JS$_emissiveIntensity;

    external set JS$_emissiveIntensity(num v);

    external num get JS$_environmentIntensity;

    external set JS$_environmentIntensity(num v);

    external num get JS$_specularIntensity;

    external set JS$_specularIntensity(num v);

    external get JS$_lightingInfos;

    external set JS$_lightingInfos(v);

    external bool get JS$_disableBumpMap;

    external set JS$_disableBumpMap(bool v);

    external BaseTexture get JS$_albedoTexture;

    external set JS$_albedoTexture(BaseTexture v);

    external BaseTexture get JS$_ambientTexture;

    external set JS$_ambientTexture(BaseTexture v);

    external num get JS$_ambientTextureStrength;

    external set JS$_ambientTextureStrength(num v);

    external num get JS$_ambientTextureImpactOnAnalyticalLights;

    external set JS$_ambientTextureImpactOnAnalyticalLights(num v);

    external BaseTexture get JS$_opacityTexture;

    external set JS$_opacityTexture(BaseTexture v);

    external BaseTexture get JS$_reflectionTexture;

    external set JS$_reflectionTexture(BaseTexture v);

    external BaseTexture get JS$_refractionTexture;

    external set JS$_refractionTexture(BaseTexture v);

    external BaseTexture get JS$_emissiveTexture;

    external set JS$_emissiveTexture(BaseTexture v);

    external BaseTexture get JS$_reflectivityTexture;

    external set JS$_reflectivityTexture(BaseTexture v);

    external BaseTexture get JS$_metallicTexture;

    external set JS$_metallicTexture(BaseTexture v);

    external num/*num|Null*/ get JS$_metallic;

    external set JS$_metallic(num/*num|Null*/ v);

    external num/*num|Null*/ get JS$_roughness;

    external set JS$_roughness(num/*num|Null*/ v);

    external BaseTexture get JS$_microSurfaceTexture;

    external set JS$_microSurfaceTexture(BaseTexture v);

    external BaseTexture get JS$_bumpTexture;

    external set JS$_bumpTexture(BaseTexture v);

    external BaseTexture get JS$_lightmapTexture;

    external set JS$_lightmapTexture(BaseTexture v);

    external Color3 get JS$_ambientColor;

    external set JS$_ambientColor(Color3 v);

    external Color3 get JS$_albedoColor;

    external set JS$_albedoColor(Color3 v);

    external Color3 get JS$_reflectivityColor;

    external set JS$_reflectivityColor(Color3 v);

    external Color3 get JS$_reflectionColor;

    external set JS$_reflectionColor(Color3 v);

    external Color3 get JS$_emissiveColor;

    external set JS$_emissiveColor(Color3 v);

    external num get JS$_microSurface;

    external set JS$_microSurface(num v);

    external num get JS$_indexOfRefraction;

    external set JS$_indexOfRefraction(num v);

    external bool get JS$_invertRefractionY;

    external set JS$_invertRefractionY(bool v);

    external bool get JS$_linkRefractionWithTransparency;

    external set JS$_linkRefractionWithTransparency(bool v);

    external bool get JS$_useLightmapAsShadowmap;

    external set JS$_useLightmapAsShadowmap(bool v);

    external bool get JS$_useHorizonOcclusion;

    external set JS$_useHorizonOcclusion(bool v);

    external bool get JS$_useRadianceOcclusion;

    external set JS$_useRadianceOcclusion(bool v);

    external bool get JS$_useAlphaFromAlbedoTexture;

    external set JS$_useAlphaFromAlbedoTexture(bool v);

    external bool get JS$_useSpecularOverAlpha;

    external set JS$_useSpecularOverAlpha(bool v);

    external bool get JS$_useMicroSurfaceFromReflectivityMapAlpha;

    external set JS$_useMicroSurfaceFromReflectivityMapAlpha(bool v);

    external bool get JS$_useRoughnessFromMetallicTextureAlpha;

    external set JS$_useRoughnessFromMetallicTextureAlpha(bool v);

    external bool get JS$_useRoughnessFromMetallicTextureGreen;

    external set JS$_useRoughnessFromMetallicTextureGreen(bool v);

    external bool get JS$_useMetallnessFromMetallicTextureBlue;

    external set JS$_useMetallnessFromMetallicTextureBlue(bool v);

    external bool get JS$_useAmbientOcclusionFromMetallicTextureRed;

    external set JS$_useAmbientOcclusionFromMetallicTextureRed(bool v);

    external bool get JS$_useAmbientInGrayScale;

    external set JS$_useAmbientInGrayScale(bool v);

    external bool get JS$_useAutoMicroSurfaceFromReflectivityMap;

    external set JS$_useAutoMicroSurfaceFromReflectivityMap(bool v);

    external num get JS$_lightFalloff;

    external set JS$_lightFalloff(num v);

    external bool get JS$_useRadianceOverAlpha;

    external set JS$_useRadianceOverAlpha(bool v);

    external bool get JS$_useObjectSpaceNormalMap;

    external set JS$_useObjectSpaceNormalMap(bool v);

    external bool get JS$_useParallax;

    external set JS$_useParallax(bool v);

    external bool get JS$_useParallaxOcclusion;

    external set JS$_useParallaxOcclusion(bool v);

    external num get JS$_parallaxScaleBias;

    external set JS$_parallaxScaleBias(num v);

    external bool get JS$_disableLighting;

    external set JS$_disableLighting(bool v);

    external num get JS$_maxSimultaneousLights;

    external set JS$_maxSimultaneousLights(num v);

    external bool get JS$_invertNormalMapX;

    external set JS$_invertNormalMapX(bool v);

    external bool get JS$_invertNormalMapY;

    external set JS$_invertNormalMapY(bool v);

    external bool get JS$_twoSidedLighting;

    external set JS$_twoSidedLighting(bool v);

    external num get JS$_alphaCutOff;

    external set JS$_alphaCutOff(num v);

    external bool get JS$_forceAlphaTest;

    external set JS$_forceAlphaTest(bool v);

    external bool get JS$_useAlphaFresnel;

    external set JS$_useAlphaFresnel(bool v);

    external bool get JS$_useLinearAlphaFresnel;

    external set JS$_useLinearAlphaFresnel(bool v);

    external num/*num|Null*/ get JS$_transparencyMode;

    external set JS$_transparencyMode(num/*num|Null*/ v);

    external BaseTexture/*BaseTexture|Null*/ get JS$_environmentBRDFTexture;

    external set JS$_environmentBRDFTexture(BaseTexture/*BaseTexture|Null*/ v);

    external bool get JS$_forceIrradianceInFragment;

    external set JS$_forceIrradianceInFragment(bool v);

    external bool get JS$_forceNormalForward;

    external set JS$_forceNormalForward(bool v);

    external bool get JS$_enableSpecularAntiAliasing;

    external set JS$_enableSpecularAntiAliasing(bool v);

    external ImageProcessingConfiguration get JS$_imageProcessingConfiguration;

    external set JS$_imageProcessingConfiguration(ImageProcessingConfiguration v);

    external get JS$_imageProcessingObserver;

    external set JS$_imageProcessingObserver(v);

    external void JS$_attachImageProcessingConfiguration(ImageProcessingConfiguration/*ImageProcessingConfiguration|Null*/ configuration);

    external get JS$_renderTargets;

    external set JS$_renderTargets(v);

    external get JS$_globalAmbientColor;

    external set JS$_globalAmbientColor(v);

    external get JS$_useLogarithmicDepth;

    external set JS$_useLogarithmicDepth(v);

    external get JS$_unlit;

    external set JS$_unlit(v);

    external factory PBRBaseMaterial(String name, Scene scene);

    external bool get hasRenderTargetTextures;

    external set hasRenderTargetTextures(bool v);

    external String getClassName();

    external bool get useLogarithmicDepth;

    external set useLogarithmicDepth(bool v);

    external num/*num|Null*/ get transparencyMode;

    external set transparencyMode(num/*num|Null*/ v);

    external get JS$_disableAlphaBlending;

    external set JS$_disableAlphaBlending(v);

    external bool needAlphaBlending();

    external bool needAlphaBlendingForMesh(AbstractMesh mesh);

    external bool needAlphaTesting();

    external bool JS$_shouldUseAlphaFromAlbedoTexture();

    external BaseTexture getAlphaTestTexture();

    external static get JS$_scaledReflectivity;

    external static set JS$_scaledReflectivity(v);

    external bool isReadyForSubMesh(AbstractMesh mesh, SubMesh subMesh, [bool useInstances]);

    external bool isMetallicWorkflow();

    external get JS$_prepareEffect;

    external set JS$_prepareEffect(v);

    external get JS$_prepareDefines;

    external set JS$_prepareDefines(v);

    external void forceCompilation(AbstractMesh mesh, [void onCompiled(Material material), Partial<dynamic /*{
            clipPlane: boolean;
        }*/> options]);

    external void buildUniformLayout();

    external void unbind();

    external void bindForSubMesh(Matrix world, Mesh mesh, SubMesh subMesh);

    external List<IAnimatable> getAnimatables();

    external get JS$_getReflectionTexture;

    external set JS$_getReflectionTexture(v);

    external get JS$_getRefractionTexture;

    external set JS$_getRefractionTexture(v);

    external void dispose([bool forceDisposeEffect, bool forceDisposeTextures]);
}

@JS("BABYLON.PBRBaseSimpleMaterial")
abstract class PBRBaseSimpleMaterial extends PBRBaseMaterial {
    // @Ignore
    PBRBaseSimpleMaterial .fakeConstructor$() : super.fakeConstructor$();
    external num get maxSimultaneousLights;

    external set maxSimultaneousLights(num v);

    external bool get disableLighting;

    external set disableLighting(bool v);

    external BaseTexture get environmentTexture;

    external set environmentTexture(BaseTexture v);

    external bool get invertNormalMapX;

    external set invertNormalMapX(bool v);

    external bool get invertNormalMapY;

    external set invertNormalMapY(bool v);

    external BaseTexture get normalTexture;

    external set normalTexture(BaseTexture v);

    external Color3 get emissiveColor;

    external set emissiveColor(Color3 v);

    external BaseTexture get emissiveTexture;

    external set emissiveTexture(BaseTexture v);

    external num get occlusionStrength;

    external set occlusionStrength(num v);

    external BaseTexture get occlusionTexture;

    external set occlusionTexture(BaseTexture v);

    external num get alphaCutOff;

    external set alphaCutOff(num v);

    external bool get doubleSided;

    external set doubleSided(bool v);

    external BaseTexture get lightmapTexture;

    external set lightmapTexture(BaseTexture v);

    external bool get useLightmapAsShadowmap;

    external set useLightmapAsShadowmap(bool v);

    external List<BaseTexture> getActiveTextures();

    external bool hasTexture(BaseTexture texture);

    external factory PBRBaseSimpleMaterial(String name, Scene scene);

    external String getClassName();
}

@JS("BABYLON.PBRMaterial")
class PBRMaterial extends PBRBaseMaterial {
    // @Ignore
    PBRMaterial .fakeConstructor$() : super.fakeConstructor$();
    external static num get PBRMATERIAL_OPAQUE;

    external static set PBRMATERIAL_OPAQUE(num v);

    external static num get PBRMATERIAL_ALPHATEST;

    external static set PBRMATERIAL_ALPHATEST(num v);

    external static num get PBRMATERIAL_ALPHABLEND;

    external static set PBRMATERIAL_ALPHABLEND(num v);

    external static num get PBRMATERIAL_ALPHATESTANDBLEND;

    external static set PBRMATERIAL_ALPHATESTANDBLEND(num v);

    external static num get DEFAULT_AO_ON_ANALYTICAL_LIGHTS;

    external static set DEFAULT_AO_ON_ANALYTICAL_LIGHTS(num v);

    external num get directIntensity;

    external set directIntensity(num v);

    external num get emissiveIntensity;

    external set emissiveIntensity(num v);

    external num get environmentIntensity;

    external set environmentIntensity(num v);

    external num get specularIntensity;

    external set specularIntensity(num v);

    external bool get disableBumpMap;

    external set disableBumpMap(bool v);

    external BaseTexture get albedoTexture;

    external set albedoTexture(BaseTexture v);

    external BaseTexture get ambientTexture;

    external set ambientTexture(BaseTexture v);

    external num get ambientTextureStrength;

    external set ambientTextureStrength(num v);

    external num get ambientTextureImpactOnAnalyticalLights;

    external set ambientTextureImpactOnAnalyticalLights(num v);

    external BaseTexture get opacityTexture;

    external set opacityTexture(BaseTexture v);

    external BaseTexture/*BaseTexture|Null*/ get reflectionTexture;

    external set reflectionTexture(BaseTexture/*BaseTexture|Null*/ v);

    external BaseTexture get emissiveTexture;

    external set emissiveTexture(BaseTexture v);

    external BaseTexture get reflectivityTexture;

    external set reflectivityTexture(BaseTexture v);

    external BaseTexture get metallicTexture;

    external set metallicTexture(BaseTexture v);

    external num/*num|Null*/ get metallic;

    external set metallic(num/*num|Null*/ v);

    external num/*num|Null*/ get roughness;

    external set roughness(num/*num|Null*/ v);

    external BaseTexture get microSurfaceTexture;

    external set microSurfaceTexture(BaseTexture v);

    external BaseTexture get bumpTexture;

    external set bumpTexture(BaseTexture v);

    external BaseTexture get lightmapTexture;

    external set lightmapTexture(BaseTexture v);

    external BaseTexture get refractionTexture;

    external set refractionTexture(BaseTexture v);

    external Color3 get ambientColor;

    external set ambientColor(Color3 v);

    external Color3 get albedoColor;

    external set albedoColor(Color3 v);

    external Color3 get reflectivityColor;

    external set reflectivityColor(Color3 v);

    external Color3 get reflectionColor;

    external set reflectionColor(Color3 v);

    external Color3 get emissiveColor;

    external set emissiveColor(Color3 v);

    external num get microSurface;

    external set microSurface(num v);

    external num get indexOfRefraction;

    external set indexOfRefraction(num v);

    external bool get invertRefractionY;

    external set invertRefractionY(bool v);

    external bool get linkRefractionWithTransparency;

    external set linkRefractionWithTransparency(bool v);

    external bool get useLightmapAsShadowmap;

    external set useLightmapAsShadowmap(bool v);

    external bool get useAlphaFromAlbedoTexture;

    external set useAlphaFromAlbedoTexture(bool v);

    external bool get forceAlphaTest;

    external set forceAlphaTest(bool v);

    external num get alphaCutOff;

    external set alphaCutOff(num v);

    external bool get useSpecularOverAlpha;

    external set useSpecularOverAlpha(bool v);

    external bool get useMicroSurfaceFromReflectivityMapAlpha;

    external set useMicroSurfaceFromReflectivityMapAlpha(bool v);

    external bool get useRoughnessFromMetallicTextureAlpha;

    external set useRoughnessFromMetallicTextureAlpha(bool v);

    external bool get useRoughnessFromMetallicTextureGreen;

    external set useRoughnessFromMetallicTextureGreen(bool v);

    external bool get useMetallnessFromMetallicTextureBlue;

    external set useMetallnessFromMetallicTextureBlue(bool v);

    external bool get useAmbientOcclusionFromMetallicTextureRed;

    external set useAmbientOcclusionFromMetallicTextureRed(bool v);

    external bool get useAmbientInGrayScale;

    external set useAmbientInGrayScale(bool v);

    external bool get useAutoMicroSurfaceFromReflectivityMap;

    external set useAutoMicroSurfaceFromReflectivityMap(bool v);

    external bool get usePhysicalLightFalloff;

    external set usePhysicalLightFalloff(bool v);

    external bool get useGLTFLightFalloff;

    external set useGLTFLightFalloff(bool v);

    external bool get useRadianceOverAlpha;

    external set useRadianceOverAlpha(bool v);

    external bool get useObjectSpaceNormalMap;

    external set useObjectSpaceNormalMap(bool v);

    external bool get useParallax;

    external set useParallax(bool v);

    external bool get useParallaxOcclusion;

    external set useParallaxOcclusion(bool v);

    external num get parallaxScaleBias;

    external set parallaxScaleBias(num v);

    external bool get disableLighting;

    external set disableLighting(bool v);

    external bool get forceIrradianceInFragment;

    external set forceIrradianceInFragment(bool v);

    external num get maxSimultaneousLights;

    external set maxSimultaneousLights(num v);

    external bool get invertNormalMapX;

    external set invertNormalMapX(bool v);

    external bool get invertNormalMapY;

    external set invertNormalMapY(bool v);

    external bool get twoSidedLighting;

    external set twoSidedLighting(bool v);

    external bool get useAlphaFresnel;

    external set useAlphaFresnel(bool v);

    external bool get useLinearAlphaFresnel;

    external set useLinearAlphaFresnel(bool v);

    external BaseTexture/*BaseTexture|Null*/ get environmentBRDFTexture;

    external set environmentBRDFTexture(BaseTexture/*BaseTexture|Null*/ v);

    external bool get forceNormalForward;

    external set forceNormalForward(bool v);

    external bool get enableSpecularAntiAliasing;

    external set enableSpecularAntiAliasing(bool v);

    external bool get useHorizonOcclusion;

    external set useHorizonOcclusion(bool v);

    external bool get useRadianceOcclusion;

    external set useRadianceOcclusion(bool v);

    external bool get unlit;

    external set unlit(bool v);

    external ImageProcessingConfiguration get imageProcessingConfiguration;

    external set imageProcessingConfiguration(ImageProcessingConfiguration v);

    external bool get cameraColorCurvesEnabled;

    external set cameraColorCurvesEnabled(bool v);

    external bool get cameraColorGradingEnabled;

    external set cameraColorGradingEnabled(bool v);

    external bool get cameraToneMappingEnabled;

    external set cameraToneMappingEnabled(bool v);

    external num get cameraExposure;

    external set cameraExposure(num v);

    external num get cameraContrast;

    external set cameraContrast(num v);

    external BaseTexture/*BaseTexture|Null*/ get cameraColorGradingTexture;

    external set cameraColorGradingTexture(BaseTexture/*BaseTexture|Null*/ v);

    external ColorCurves/*ColorCurves|Null*/ get cameraColorCurves;

    external set cameraColorCurves(ColorCurves/*ColorCurves|Null*/ v);

    external factory PBRMaterial(String name, Scene scene);

    external String getClassName();

    external List<BaseTexture> getActiveTextures();

    external bool hasTexture(BaseTexture texture);

    external PBRMaterial clone(String name);

    external dynamic serialize();

    external static PBRMaterial Parse(dynamic source, Scene scene, String rootUrl);
}

@JS("BABYLON.PBRMetallicRoughnessMaterial")
class PBRMetallicRoughnessMaterial extends PBRBaseSimpleMaterial {
    // @Ignore
    PBRMetallicRoughnessMaterial .fakeConstructor$() : super.fakeConstructor$();
    external Color3 get baseColor;

    external set baseColor(Color3 v);

    external BaseTexture get baseTexture;

    external set baseTexture(BaseTexture v);

    external num get metallic;

    external set metallic(num v);

    external num get roughness;

    external set roughness(num v);

    external BaseTexture get metallicRoughnessTexture;

    external set metallicRoughnessTexture(BaseTexture v);

    external factory PBRMetallicRoughnessMaterial(String name, Scene scene);

    external String getClassName();

    external List<BaseTexture> getActiveTextures();

    external bool hasTexture(BaseTexture texture);

    external PBRMetallicRoughnessMaterial clone(String name);

    external dynamic serialize();

    external static PBRMetallicRoughnessMaterial Parse(dynamic source, Scene scene, String rootUrl);
}

@JS("BABYLON.PBRSpecularGlossinessMaterial")
class PBRSpecularGlossinessMaterial extends PBRBaseSimpleMaterial {
    // @Ignore
    PBRSpecularGlossinessMaterial .fakeConstructor$() : super.fakeConstructor$();
    external Color3 get diffuseColor;

    external set diffuseColor(Color3 v);

    external BaseTexture get diffuseTexture;

    external set diffuseTexture(BaseTexture v);

    external Color3 get specularColor;

    external set specularColor(Color3 v);

    external num get glossiness;

    external set glossiness(num v);

    external BaseTexture get specularGlossinessTexture;

    external set specularGlossinessTexture(BaseTexture v);

    external factory PBRSpecularGlossinessMaterial(String name, Scene scene);

    external String getClassName();

    external List<BaseTexture> getActiveTextures();

    external bool hasTexture(BaseTexture texture);

    external PBRSpecularGlossinessMaterial clone(String name);

    external dynamic serialize();

    external static PBRSpecularGlossinessMaterial Parse(dynamic source, Scene scene, String rootUrl);
}

@JS("BABYLON.BaseTexture")
class BaseTexture {
    // @Ignore
    BaseTexture .fakeConstructor$();

    external static num get DEFAULT_ANISOTROPIC_FILTERING_LEVEL;

    external static set DEFAULT_ANISOTROPIC_FILTERING_LEVEL(num v);

    external String get name;

    external set name(String v);

    external get JS$_hasAlpha;

    external set JS$_hasAlpha(v);

    external bool get hasAlpha;

    external set hasAlpha(bool v);

    external bool get getAlphaFromRGB;

    external set getAlphaFromRGB(bool v);

    external num get level;

    external set level(num v);

    external num get coordinatesIndex;

    external set coordinatesIndex(num v);

    external get JS$_coordinatesMode;

    external set JS$_coordinatesMode(v);

    external num get coordinatesMode;

    external set coordinatesMode(num v);

    external num get wrapU;

    external set wrapU(num v);

    external num get wrapV;

    external set wrapV(num v);

    external num get wrapR;

    external set wrapR(num v);

    external num get anisotropicFilteringLevel;

    external set anisotropicFilteringLevel(num v);

    external bool get isCube;

    external set isCube(bool v);

    external bool get is3D;

    external set is3D(bool v);

    external bool get gammaSpace;

    external set gammaSpace(bool v);

    external bool get isRGBD;

    external set isRGBD(bool v);

    external bool get invertZ;

    external set invertZ(bool v);

    external bool get lodLevelInAlpha;

    external set lodLevelInAlpha(bool v);

    external num get lodGenerationOffset;

    external set lodGenerationOffset(num v);

    external num get lodGenerationScale;

    external set lodGenerationScale(num v);

    external bool get isRenderTarget;

    external set isRenderTarget(bool v);

    external String get uid;

    external set uid(String v);

    external String toString();

    external String getClassName();

    external List<Animation> get animations;

    external set animations(List<Animation> v);

    external Observable<BaseTexture> get onDisposeObservable;

    external set onDisposeObservable(Observable<BaseTexture> v);

    external get JS$_onDisposeObserver;

    external set JS$_onDisposeObserver(v);

    external VoidFunc0 get onDispose;

    external set onDispose(VoidFunc0 v);

    external num get delayLoadState;

    external set delayLoadState(num v);

    external get JS$_scene;

    external set JS$_scene(v);

    external InternalTexture/*InternalTexture|Null*/ get JS$_texture;

    external set JS$_texture(InternalTexture/*InternalTexture|Null*/ v);

    external get JS$_uid;

    external set JS$_uid(v);

    external bool get isBlocking;

    external set isBlocking(bool v);

    external factory BaseTexture(Scene/*Scene|Null*/ scene);

    external Scene/*Scene|Null*/ getScene();

    external Matrix getTextureMatrix();

    external Matrix getReflectionTextureMatrix();

    external InternalTexture/*InternalTexture|Null*/ getInternalTexture();

    external bool isReadyOrNotBlocking();

    external bool isReady();

    external get JS$_cachedSize;

    external set JS$_cachedSize(v);

    external ISize getSize();

    external ISize getBaseSize();

    external void scale(num ratio);

    external bool get canRescale;

    external set canRescale(bool v);

    external InternalTexture/*InternalTexture|Null*/ JS$_getFromCache(String/*String|Null*/ url, bool noMipmap, [num sampling]);

    external void JS$_rebuild();

    external void delayLoad();

    external BaseTexture/*BaseTexture|Null*/ clone();

    external num get textureType;

    external set textureType(num v);

    external num get textureFormat;

    external set textureFormat(num v);

    external TypedData/*TypedData|Null*/ readPixels([num faceIndex, num level, TypedData/*TypedData|Null*/ buffer]);

    external void releaseInternalTexture();

    external SphericalPolynomial/*SphericalPolynomial|Null*/ get sphericalPolynomial;

    external set sphericalPolynomial(SphericalPolynomial/*SphericalPolynomial|Null*/ v);

    external BaseTexture/*BaseTexture|Null*/ get JS$_lodTextureHigh;

    external set JS$_lodTextureHigh(BaseTexture/*BaseTexture|Null*/ v);

    external BaseTexture/*BaseTexture|Null*/ get JS$_lodTextureMid;

    external set JS$_lodTextureMid(BaseTexture/*BaseTexture|Null*/ v);

    external BaseTexture/*BaseTexture|Null*/ get JS$_lodTextureLow;

    external set JS$_lodTextureLow(BaseTexture/*BaseTexture|Null*/ v);

    external void dispose();

    external dynamic serialize();

    external static void WhenAllReady(List<BaseTexture> textures, void callback());
}

@JS("BABYLON.ColorGradingTexture")
class ColorGradingTexture extends BaseTexture {
    // @Ignore
    ColorGradingTexture .fakeConstructor$() : super.fakeConstructor$();
    external get JS$_textureMatrix;

    external set JS$_textureMatrix(v);

    external String get url;

    external set url(String v);

    external static get JS$_noneEmptyLineRegex;

    external static set JS$_noneEmptyLineRegex(v);

    external get JS$_engine;

    external set JS$_engine(v);

    external factory ColorGradingTexture(String url, Scene scene);

    external Matrix getTextureMatrix();

    external get load3dlTexture;

    external set load3dlTexture(v);

    external get loadTexture;

    external set loadTexture(v);

    external ColorGradingTexture clone();

    external void delayLoad();

    external static ColorGradingTexture/*ColorGradingTexture|Null*/ Parse(dynamic parsedTexture, Scene scene, String rootUrl);

    external dynamic serialize();
}

@JS("BABYLON.CubeTexture")
class CubeTexture extends BaseTexture {
    // @Ignore
    CubeTexture .fakeConstructor$() : super.fakeConstructor$();
    external String get url;

    external set url(String v);

    external Vector3 get boundingBoxPosition;

    external set boundingBoxPosition(Vector3 v);

    external get JS$_boundingBoxSize;

    external set JS$_boundingBoxSize(v);

    external Vector3 get boundingBoxSize;

    external set boundingBoxSize(Vector3 v);

    external num get JS$_rotationY;

    external set JS$_rotationY(num v);

    external num get rotationY;

    external set rotationY(num v);

    external get JS$_noMipmap;

    external set JS$_noMipmap(v);

    external get JS$_files;

    external set JS$_files(v);

    external get JS$_extensions;

    external set JS$_extensions(v);

    external get JS$_textureMatrix;

    external set JS$_textureMatrix(v);

    external get JS$_format;

    external set JS$_format(v);

    external get JS$_createPolynomials;

    external set JS$_createPolynomials(v);

    external bool get JS$_prefiltered;

    external set JS$_prefiltered(bool v);

    external static CubeTexture CreateFromImages(List<String> files, Scene scene, [bool noMipmap]);

    external static CubeTexture CreateFromPrefilteredData(String url, Scene scene, [dynamic forcedExtension, bool createPolynomials]);

    external factory CubeTexture(String rootUrl, Scene scene, [List<String>/*List<String>|Null*/ extensions, bool noMipmap, List<String>/*List<String>|Null*/ files, VoidFunc0/*VoidFunc0|Null*/ onLoad, Function/*(message?: string, exception?: any) => void|Null*/ onError, num format, bool prefiltered, dynamic forcedExtension, bool createPolynomials, num lodScale, num lodOffset]);

    external void delayLoad();

    external Matrix getReflectionTextureMatrix();

    external void setReflectionTextureMatrix(Matrix value);

    external static CubeTexture Parse(dynamic parsedTexture, Scene scene, String rootUrl);

    external CubeTexture clone();
}

@JS("BABYLON.DynamicTexture")
class DynamicTexture extends Texture {
    // @Ignore
    DynamicTexture .fakeConstructor$() : super.fakeConstructor$();
    external get JS$_generateMipMaps;

    external set JS$_generateMipMaps(v);

    external get JS$_canvas;

    external set JS$_canvas(v);

    external get JS$_context;

    external set JS$_context(v);

    external get JS$_engine;

    external set JS$_engine(v);

    external factory DynamicTexture(String name, dynamic options, dynamic/*Scene|Null|dynamic*/ scene, bool generateMipMaps, [num samplingMode, num format]);

    external bool get canRescale;

    external set canRescale(bool v);

    external get JS$_recreate;

    external set JS$_recreate(v);

    external void scale(num ratio);

    external void scaleTo(num width, num height);

    external CanvasRenderingContext2D getContext();

    external void clear();

    external void update([bool invertY, bool premulAlpha]);

    external void drawText(String text, num x, num y, String font, String color, String clearColor, [bool invertY, bool update]);

    external DynamicTexture clone();

    external dynamic serialize();

    external void JS$_rebuild();
}

@JS("BABYLON.HDRCubeTexture")
class HDRCubeTexture extends BaseTexture {
    // @Ignore
    HDRCubeTexture .fakeConstructor$() : super.fakeConstructor$();
    external static get JS$_facesMapping;

    external static set JS$_facesMapping(v);

    external get JS$_generateHarmonics;

    external set JS$_generateHarmonics(v);

    external get JS$_noMipmap;

    external set JS$_noMipmap(v);

    external get JS$_textureMatrix;

    external set JS$_textureMatrix(v);

    external get JS$_size;

    external set JS$_size(v);

    external get JS$_onLoad;

    external set JS$_onLoad(v);

    external get JS$_onError;

    external set JS$_onError(v);

    external String get url;

    external set url(String v);

    external num get coordinatesMode;

    external set coordinatesMode(num v);

    external bool get JS$_isBlocking;

    external set JS$_isBlocking(bool v);

    external bool get isBlocking;

    external set isBlocking(bool v);

    external num get JS$_rotationY;

    external set JS$_rotationY(num v);

    external num get rotationY;

    external set rotationY(num v);

    external Vector3 get boundingBoxPosition;

    external set boundingBoxPosition(Vector3 v);

    external get JS$_boundingBoxSize;

    external set JS$_boundingBoxSize(v);

    external Vector3 get boundingBoxSize;

    external set boundingBoxSize(Vector3 v);

    external factory HDRCubeTexture(String url, Scene scene, num size, [bool noMipmap, bool generateHarmonics, bool gammaSpace, bool reserved, VoidFunc0/*VoidFunc0|Null*/ onLoad, Function/*(message?: string, exception?: any) => void|Null*/ onError]);

    external get loadTexture;

    external set loadTexture(v);

    external HDRCubeTexture clone();

    external void delayLoad();

    external Matrix getReflectionTextureMatrix();

    external void setReflectionTextureMatrix(Matrix value);

    external static HDRCubeTexture/*HDRCubeTexture|Null*/ Parse(dynamic parsedTexture, Scene scene, String rootUrl);

    external dynamic serialize();
}

@JS("BABYLON.InternalTexture")
class InternalTexture implements IInternalTextureTracker {
    // @Ignore
    InternalTexture .fakeConstructor$();

    external static num get DATASOURCE_UNKNOWN;

    external static set DATASOURCE_UNKNOWN(num v);

    external static num get DATASOURCE_URL;

    external static set DATASOURCE_URL(num v);

    external static num get DATASOURCE_TEMP;

    external static set DATASOURCE_TEMP(num v);

    external static num get DATASOURCE_RAW;

    external static set DATASOURCE_RAW(num v);

    external static num get DATASOURCE_DYNAMIC;

    external static set DATASOURCE_DYNAMIC(num v);

    external static num get DATASOURCE_RENDERTARGET;

    external static set DATASOURCE_RENDERTARGET(num v);

    external static num get DATASOURCE_MULTIRENDERTARGET;

    external static set DATASOURCE_MULTIRENDERTARGET(num v);

    external static num get DATASOURCE_CUBE;

    external static set DATASOURCE_CUBE(num v);

    external static num get DATASOURCE_CUBERAW;

    external static set DATASOURCE_CUBERAW(num v);

    external static num get DATASOURCE_CUBEPREFILTERED;

    external static set DATASOURCE_CUBEPREFILTERED(num v);

    external static num get DATASOURCE_RAW3D;

    external static set DATASOURCE_RAW3D(num v);

    external static num get DATASOURCE_DEPTHTEXTURE;

    external static set DATASOURCE_DEPTHTEXTURE(num v);

    external static num get DATASOURCE_CUBERAW_RGBD;

    external static set DATASOURCE_CUBERAW_RGBD(num v);

    external bool get isReady;

    external set isReady(bool v);

    external bool get isCube;

    external set isCube(bool v);

    external bool get is3D;

    external set is3D(bool v);

    external String get url;

    external set url(String v);

    external num get samplingMode;

    external set samplingMode(num v);

    external bool get generateMipMaps;

    external set generateMipMaps(bool v);

    external num get samples;

    external set samples(num v);

    external num get type;

    external set type(num v);

    external num get format;

    external set format(num v);

    external Observable<InternalTexture> get onLoadedObservable;

    external set onLoadedObservable(Observable<InternalTexture> v);

    external num get width;

    external set width(num v);

    external num get height;

    external set height(num v);

    external num get depth;

    external set depth(num v);

    external num get baseWidth;

    external set baseWidth(num v);

    external num get baseHeight;

    external set baseHeight(num v);

    external num get baseDepth;

    external set baseDepth(num v);

    external bool get invertY;

    external set invertY(bool v);

    external IInternalTextureTracker/*IInternalTextureTracker|Null*/ get previous;

    external set previous(IInternalTextureTracker/*IInternalTextureTracker|Null*/ v);

    external IInternalTextureTracker/*IInternalTextureTracker|Null*/ get next;

    external set next(IInternalTextureTracker/*IInternalTextureTracker|Null*/ v);

    external num get JS$_initialSlot;

    external set JS$_initialSlot(num v);

    external num get JS$_designatedSlot;

    external set JS$_designatedSlot(num v);

    external num get JS$_dataSource;

    external set JS$_dataSource(num v);

    external dynamic/*String|ByteBuffer|ImageElement|Blob|Null*/ get JS$_buffer;

    external set JS$_buffer(dynamic/*String|ByteBuffer|ImageElement|Blob|Null*/ v);

    external TypedData/*TypedData|Null*/ get JS$_bufferView;

    external set JS$_bufferView(TypedData/*TypedData|Null*/ v);

    external List<TypedData>/*List<TypedData>|Null*/ get JS$_bufferViewArray;

    external set JS$_bufferViewArray(List<TypedData>/*List<TypedData>|Null*/ v);

    external List<List<TypedData>>/*List<List<TypedData>>|Null*/ get JS$_bufferViewArrayArray;

    external set JS$_bufferViewArrayArray(List<List<TypedData>>/*List<List<TypedData>>|Null*/ v);

    external num get JS$_size;

    external set JS$_size(num v);

    external String get JS$_extension;

    external set JS$_extension(String v);

    external List<String>/*List<String>|Null*/ get JS$_files;

    external set JS$_files(List<String>/*List<String>|Null*/ v);

    external CanvasElement get JS$_workingCanvas;

    external set JS$_workingCanvas(CanvasElement v);

    external CanvasRenderingContext2D get JS$_workingContext;

    external set JS$_workingContext(CanvasRenderingContext2D v);

    external Framebuffer/*Framebuffer|Null*/ get JS$_framebuffer;

    external set JS$_framebuffer(Framebuffer/*Framebuffer|Null*/ v);

    external Renderbuffer/*Renderbuffer|Null*/ get JS$_depthStencilBuffer;

    external set JS$_depthStencilBuffer(Renderbuffer/*Renderbuffer|Null*/ v);

    external Framebuffer/*Framebuffer|Null*/ get JS$_MSAAFramebuffer;

    external set JS$_MSAAFramebuffer(Framebuffer/*Framebuffer|Null*/ v);

    external Renderbuffer/*Renderbuffer|Null*/ get JS$_MSAARenderBuffer;

    external set JS$_MSAARenderBuffer(Renderbuffer/*Renderbuffer|Null*/ v);

    external List<num>/*List<num>|Null*/ get JS$_attachments;

    external set JS$_attachments(List<num>/*List<num>|Null*/ v);

    external num/*num|Null*/ get JS$_cachedCoordinatesMode;

    external set JS$_cachedCoordinatesMode(num/*num|Null*/ v);

    external num/*num|Null*/ get JS$_cachedWrapU;

    external set JS$_cachedWrapU(num/*num|Null*/ v);

    external num/*num|Null*/ get JS$_cachedWrapV;

    external set JS$_cachedWrapV(num/*num|Null*/ v);

    external num/*num|Null*/ get JS$_cachedWrapR;

    external set JS$_cachedWrapR(num/*num|Null*/ v);

    external num/*num|Null*/ get JS$_cachedAnisotropicFilteringLevel;

    external set JS$_cachedAnisotropicFilteringLevel(num/*num|Null*/ v);

    external bool get JS$_isDisabled;

    external set JS$_isDisabled(bool v);

    external String/*String|Null*/ get JS$_compression;

    external set JS$_compression(String/*String|Null*/ v);

    external bool get JS$_generateStencilBuffer;

    external set JS$_generateStencilBuffer(bool v);

    external bool get JS$_generateDepthBuffer;

    external set JS$_generateDepthBuffer(bool v);

    external num get JS$_comparisonFunction;

    external set JS$_comparisonFunction(num v);

    external SphericalPolynomial/*SphericalPolynomial|Null*/ get JS$_sphericalPolynomial;

    external set JS$_sphericalPolynomial(SphericalPolynomial/*SphericalPolynomial|Null*/ v);

    external num get JS$_lodGenerationScale;

    external set JS$_lodGenerationScale(num v);

    external num get JS$_lodGenerationOffset;

    external set JS$_lodGenerationOffset(num v);

    external BaseTexture get JS$_lodTextureHigh;

    external set JS$_lodTextureHigh(BaseTexture v);

    external BaseTexture get JS$_lodTextureMid;

    external set JS$_lodTextureMid(BaseTexture v);

    external BaseTexture get JS$_lodTextureLow;

    external set JS$_lodTextureLow(BaseTexture v);

    external bool get JS$_isRGBD;

    external set JS$_isRGBD(bool v);

    external Texture/*Texture|Null*/ get JS$_webGLTexture;

    external set JS$_webGLTexture(Texture/*Texture|Null*/ v);

    external num get JS$_references;

    external set JS$_references(num v);

    external get JS$_engine;

    external set JS$_engine(v);

    external Engine getEngine();

    external num get dataSource;

    external set dataSource(num v);

    external factory InternalTexture(Engine engine, num dataSource);

    external void incrementReferences();

    external void updateSize(num width, num height, [num depth]);

    external void JS$_rebuild();

    external void JS$_swapAndDie(InternalTexture target);

    external void dispose();
}

@anonymous
@JS()
abstract class IInternalTextureLoader {
    external bool get supportCascades;

    external set supportCascades(bool v);

    external bool canLoad(String extension, String/*String|Null*/ textureFormatInUse, InternalTexture/*InternalTexture|Null*/ fallback, bool isBase64, bool isBuffer);

    external String transformUrl(String rootUrl, String/*String|Null*/ textureFormatInUse);

    external String/*String|Null*/ getFallbackTextureUrl(String rootUrl, String/*String|Null*/ textureFormatInUse);

    external void loadCubeData(dynamic/*String|ByteBuffer|List<String|ByteBuffer>*/ data, InternalTexture texture, bool createPolynomials, VoidFunc1Opt1<dynamic>/*VoidFunc1Opt1<dynamic>|Null*/ onLoad, Function/*(message?: string, exception?: any) => void|Null*/ onError);

    external void loadData(ByteBuffer data, InternalTexture texture, void callback(num width, num height, bool loadMipmap, bool isCompressed, void done()));
}

@anonymous
@JS()
abstract class IInternalTextureTracker {
    external IInternalTextureTracker/*IInternalTextureTracker|Null*/ get previous;

    external set previous(IInternalTextureTracker/*IInternalTextureTracker|Null*/ v);

    external IInternalTextureTracker/*IInternalTextureTracker|Null*/ get next;

    external set next(IInternalTextureTracker/*IInternalTextureTracker|Null*/ v);

    external factory IInternalTextureTracker({ IInternalTextureTracker/*IInternalTextureTracker|Null*/ previous, IInternalTextureTracker/*IInternalTextureTracker|Null*/ next});
}

@JS("BABYLON.DummyInternalTextureTracker")
class DummyInternalTextureTracker {
    // @Ignore
    DummyInternalTextureTracker .fakeConstructor$();

    external IInternalTextureTracker/*IInternalTextureTracker|Null*/ get previous;

    external set previous(IInternalTextureTracker/*IInternalTextureTracker|Null*/ v);

    external IInternalTextureTracker/*IInternalTextureTracker|Null*/ get next;

    external set next(IInternalTextureTracker/*IInternalTextureTracker|Null*/ v);
}

@JS("BABYLON.MirrorTexture")
class MirrorTexture extends RenderTargetTexture {
    // @Ignore
    MirrorTexture .fakeConstructor$() : super.fakeConstructor$();
    external get scene;

    external set scene(v);

    external Plane get mirrorPlane;

    external set mirrorPlane(Plane v);

    external num get blurRatio;

    external set blurRatio(num v);

    external num get adaptiveBlurKernel;

    external set adaptiveBlurKernel(num v);

    external num get blurKernel;

    external set blurKernel(num v);

    external num get blurKernelX;

    external set blurKernelX(num v);

    external num get blurKernelY;

    external set blurKernelY(num v);

    external get JS$_autoComputeBlurKernel;

    external set JS$_autoComputeBlurKernel(v);

    external void JS$_onRatioRescale();

    external get JS$_updateGammaSpace;

    external set JS$_updateGammaSpace(v);

    external get JS$_imageProcessingConfigChangeObserver;

    external set JS$_imageProcessingConfigChangeObserver(v);

    external get JS$_transformMatrix;

    external set JS$_transformMatrix(v);

    external get JS$_mirrorMatrix;

    external set JS$_mirrorMatrix(v);

    external get JS$_savedViewMatrix;

    external set JS$_savedViewMatrix(v);

    external get JS$_blurX;

    external set JS$_blurX(v);

    external get JS$_blurY;

    external set JS$_blurY(v);

    external get JS$_adaptiveBlurKernel;

    external set JS$_adaptiveBlurKernel(v);

    external get JS$_blurKernelX;

    external set JS$_blurKernelX(v);

    external get JS$_blurKernelY;

    external set JS$_blurKernelY(v);

    external get JS$_blurRatio;

    external set JS$_blurRatio(v);

    external factory MirrorTexture(String name, dynamic/*num|{
            width: number;
            height: number;
        }|{
            ratio: number;
        }*/
    size, Scene scene, [bool generateMipMaps, num type, num samplingMode, bool generateDepthBuffer]);

    external get JS$_preparePostProcesses;

    external set JS$_preparePostProcesses(v);

    external MirrorTexture clone();

    external dynamic serialize();

    external void dispose();
}

@anonymous
@JS()
abstract class IMultiRenderTargetOptions {
    external bool get generateMipMaps;

    external set generateMipMaps(bool v);

    external List<num> get types;

    external set types(List<num> v);

    external List<num> get samplingModes;

    external set samplingModes(List<num> v);

    external bool get generateDepthBuffer;

    external set generateDepthBuffer(bool v);

    external bool get generateStencilBuffer;

    external set generateStencilBuffer(bool v);

    external bool get generateDepthTexture;

    external set generateDepthTexture(bool v);

    external num get textureCount;

    external set textureCount(num v);

    external bool get doNotChangeAspectRatio;

    external set doNotChangeAspectRatio(bool v);

    external num get defaultType;

    external set defaultType(num v);

    external factory IMultiRenderTargetOptions({ bool generateMipMaps, List<num> types, List<num> samplingModes, bool generateDepthBuffer, bool generateStencilBuffer, bool generateDepthTexture, num textureCount, bool doNotChangeAspectRatio, num defaultType});
}

@JS("BABYLON.MultiRenderTarget")
class MultiRenderTarget extends RenderTargetTexture {
    // @Ignore
    MultiRenderTarget .fakeConstructor$() : super.fakeConstructor$();
    external get JS$_internalTextures;

    external set JS$_internalTextures(v);

    external get JS$_textures;

    external set JS$_textures(v);

    external get JS$_multiRenderTargetOptions;

    external set JS$_multiRenderTargetOptions(v);

    external bool get isSupported;

    external set isSupported(bool v);

    external List<Texture> get textures;

    external set textures(List<Texture> v);

    external Texture get depthTexture;

    external set depthTexture(Texture v);

    external num get wrapU;

    external set wrapU(num v);

    external num get wrapV;

    external set wrapV(num v);

    external factory MultiRenderTarget(String name, dynamic size, num count, Scene scene, [IMultiRenderTargetOptions options]);

    external void JS$_rebuild();

    external get JS$_createInternalTextures;

    external set JS$_createInternalTextures(v);

    external get JS$_createTextures;

    external set JS$_createTextures(v);

    external num get samples;

    external set samples(num v);

    external void resize(dynamic size);

    external void unbindFrameBuffer(Engine engine, num faceIndex);

    external void dispose();

    external void releaseInternalTextures();
}

@JS("BABYLON.RawCubeTexture")
class RawCubeTexture extends CubeTexture {
    // @Ignore
    RawCubeTexture .fakeConstructor$() : super.fakeConstructor$();

    external factory RawCubeTexture(Scene scene, List<TypedData>/*List<TypedData>|Null*/ data, num size, [num format, num type, bool generateMipMaps, bool invertY, num samplingMode, String/*String|Null*/ compression]);

    external void update(List<TypedData> data, num format, num type, bool invertY, [String/*String|Null*/ compression, num level]);

    external Promise<Null> updateRGBDAsync(List<List<TypedData>> data, [SphericalPolynomial/*SphericalPolynomial|Null*/ sphericalPolynomial, num lodScale, num lodOffset]);

    external CubeTexture clone();

    external static Promise<Null> JS$_UpdateRGBDAsync(InternalTexture internalTexture, List<List<TypedData>> data, SphericalPolynomial/*SphericalPolynomial|Null*/ sphericalPolynomial, num lodScale, num lodOffset);
}

@JS("BABYLON.RawTexture")
class RawTexture extends Texture {
    // @Ignore
    RawTexture .fakeConstructor$() : super.fakeConstructor$();
    external num get format;

    external set format(num v);

    external get JS$_engine;

    external set JS$_engine(v);

    external factory RawTexture(TypedData data, num width, num height, num format, Scene scene, [bool generateMipMaps, bool invertY, num samplingMode, num type]);

    external void update(TypedData data);

    external static RawTexture CreateLuminanceTexture(TypedData data, num width, num height, Scene scene, [bool generateMipMaps, bool invertY, num samplingMode]);

    external static RawTexture CreateLuminanceAlphaTexture(TypedData data, num width, num height, Scene scene, [bool generateMipMaps, bool invertY, num samplingMode]);

    external static RawTexture CreateAlphaTexture(TypedData data, num width, num height, Scene scene, [bool generateMipMaps, bool invertY, num samplingMode]);

    external static RawTexture CreateRGBTexture(TypedData data, num width, num height, Scene scene, [bool generateMipMaps, bool invertY, num samplingMode, num type]);

    external static RawTexture CreateRGBATexture(TypedData data, num width, num height, Scene scene, [bool generateMipMaps, bool invertY, num samplingMode, num type]);

    external static RawTexture CreateRTexture(TypedData data, num width, num height, Scene scene, [bool generateMipMaps, bool invertY, num samplingMode, num type]);
}

@JS("BABYLON.RawTexture3D")
class RawTexture3D extends Texture {
    // @Ignore
    RawTexture3D .fakeConstructor$() : super.fakeConstructor$();
    external num get format;

    external set format(num v);

    external get JS$_engine;

    external set JS$_engine(v);

    external factory RawTexture3D(TypedData data, num width, num height, num depth, num format, Scene scene, [bool generateMipMaps, bool invertY, num samplingMode, num textureType]);

    external void update(TypedData data);
}

@JS("BABYLON.RefractionTexture")
class RefractionTexture extends RenderTargetTexture {
    // @Ignore
    RefractionTexture .fakeConstructor$() : super.fakeConstructor$();
    external Plane get refractionPlane;

    external set refractionPlane(Plane v);

    external num get depth;

    external set depth(num v);

    external factory RefractionTexture(String name, num size, Scene scene, [bool generateMipMaps]);

    external RefractionTexture clone();

    external dynamic serialize();
}

@JS("BABYLON.RenderTargetTexture")
class RenderTargetTexture extends Texture {
    // @Ignore
    RenderTargetTexture .fakeConstructor$() : super.fakeConstructor$();
    external bool get isCube;

    external set isCube(bool v);

    external static num get REFRESHRATE_RENDER_ONCE;

    external static set REFRESHRATE_RENDER_ONCE(num v);

    external static num get REFRESHRATE_RENDER_ONEVERYFRAME;

    external static set REFRESHRATE_RENDER_ONEVERYFRAME(num v);

    external static num get REFRESHRATE_RENDER_ONEVERYTWOFRAMES;

    external static set REFRESHRATE_RENDER_ONEVERYTWOFRAMES(num v);

    external Func1<AbstractMesh, bool> get renderListPredicate;

    external set renderListPredicate(Func1<AbstractMesh, bool> v);

    external get JS$_renderList;

    external set JS$_renderList(v);

    external List<AbstractMesh>/*List<AbstractMesh>|Null*/ get renderList;

    external set renderList(List<AbstractMesh>/*List<AbstractMesh>|Null*/ v);

    external get JS$_hookArray;

    external set JS$_hookArray(v);

    external bool get renderParticles;

    external set renderParticles(bool v);

    external bool get renderSprites;

    external set renderSprites(bool v);

    external num get coordinatesMode;

    external set coordinatesMode(num v);

    external Camera/*Camera|Null*/ get activeCamera;

    external set activeCamera(Camera/*Camera|Null*/ v);

    external Function/*(opaqueSubMeshes: SmartArray<SubMesh>, alphaTestSubMeshes: SmartArray<SubMesh>, transparentSubMeshes: SmartArray<SubMesh>, depthOnlySubMeshes: SmartArray<SubMesh>, beforeTransparents?: () => void) => void*/ get customRenderFunction;

    external set customRenderFunction(Function/*(opaqueSubMeshes: SmartArray<SubMesh>, alphaTestSubMeshes: SmartArray<SubMesh>, transparentSubMeshes: SmartArray<SubMesh>, depthOnlySubMeshes: SmartArray<SubMesh>, beforeTransparents?: () => void) => void*/ v);

    external bool get useCameraPostProcesses;

    external set useCameraPostProcesses(bool v);

    external bool get ignoreCameraViewport;

    external set ignoreCameraViewport(bool v);

    external get JS$_postProcessManager;

    external set JS$_postProcessManager(v);

    external get JS$_postProcesses;

    external set JS$_postProcesses(v);

    external get JS$_resizeObserver;

    external set JS$_resizeObserver(v);

    external Observable<RenderTargetTexture> get onBeforeBindObservable;

    external set onBeforeBindObservable(Observable<RenderTargetTexture> v);

    external Observable<RenderTargetTexture> get onAfterUnbindObservable;

    external set onAfterUnbindObservable(Observable<RenderTargetTexture> v);

    external get JS$_onAfterUnbindObserver;

    external set JS$_onAfterUnbindObserver(v);

    external VoidFunc0 get onAfterUnbind;

    external set onAfterUnbind(VoidFunc0 v);

    external Observable<num> get onBeforeRenderObservable;

    external set onBeforeRenderObservable(Observable<num> v);

    external get JS$_onBeforeRenderObserver;

    external set JS$_onBeforeRenderObserver(v);

    external VoidFunc1<num> get onBeforeRender;

    external set onBeforeRender(VoidFunc1<num> v);

    external Observable<num> get onAfterRenderObservable;

    external set onAfterRenderObservable(Observable<num> v);

    external get JS$_onAfterRenderObserver;

    external set JS$_onAfterRenderObserver(v);

    external VoidFunc1<num> get onAfterRender;

    external set onAfterRender(VoidFunc1<num> v);

    external Observable<Engine> get onClearObservable;

    external set onClearObservable(Observable<Engine> v);

    external get JS$_onClearObserver;

    external set JS$_onClearObserver(v);

    external VoidFunc1<Engine> get onClear;

    external set onClear(VoidFunc1<Engine> v);

    external Color4 get clearColor;

    external set clearColor(Color4 v);

    external dynamic/*num|{
            width: number;
            height: number;
        }*/ get JS$_size;

    external set JS$_size(dynamic/*num|{
            width: number;
            height: number;
        }*/
    v);

    external dynamic/*num|{
            width: number;
            height: number;
        }|{
            ratio: number;
        }*/ get JS$_initialSizeParameter;

    external set JS$_initialSizeParameter(dynamic/*num|{
            width: number;
            height: number;
        }|{
            ratio: number;
        }*/
    v);

    external num/*num|Null*/ get JS$_sizeRatio;

    external set JS$_sizeRatio(num/*num|Null*/ v);

    external bool get JS$_generateMipMaps;

    external set JS$_generateMipMaps(bool v);

    external RenderingManager get JS$_renderingManager;

    external set JS$_renderingManager(RenderingManager v);

    external List<String> get JS$_waitingRenderList;

    external set JS$_waitingRenderList(List<String> v);

    external bool get JS$_doNotChangeAspectRatio;

    external set JS$_doNotChangeAspectRatio(bool v);

    external num get JS$_currentRefreshId;

    external set JS$_currentRefreshId(num v);

    external num get JS$_refreshRate;

    external set JS$_refreshRate(num v);

    external Matrix get JS$_textureMatrix;

    external set JS$_textureMatrix(Matrix v);

    external num get JS$_samples;

    external set JS$_samples(num v);

    external RenderTargetCreationOptions get JS$_renderTargetOptions;

    external set JS$_renderTargetOptions(RenderTargetCreationOptions v);

    external RenderTargetCreationOptions get renderTargetOptions;

    external set renderTargetOptions(RenderTargetCreationOptions v);

    external Engine get JS$_engine;

    external set JS$_engine(Engine v);

    external void JS$_onRatioRescale();

    external Vector3 get boundingBoxPosition;

    external set boundingBoxPosition(Vector3 v);

    external get JS$_boundingBoxSize;

    external set JS$_boundingBoxSize(v);

    external Vector3 get boundingBoxSize;

    external set boundingBoxSize(Vector3 v);

    external InternalTexture/*InternalTexture|Null*/ get depthStencilTexture;

    external set depthStencilTexture(InternalTexture/*InternalTexture|Null*/ v);

    external factory RenderTargetTexture(String name, dynamic/*num|{
            width: number;
            height: number;
        }|{
            ratio: number;
        }*/
    size, Scene/*Scene|Null*/ scene, [bool generateMipMaps, bool doNotChangeAspectRatio, num type, bool isCube, num samplingMode, bool generateDepthBuffer, bool generateStencilBuffer, bool isMulti, num format]);

    external void createDepthStencilTexture([num comparisonFunction, bool bilinearFiltering, bool generateStencil]);

    external get JS$_processSizeParameter;

    external set JS$_processSizeParameter(v);

    external num get samples;

    external set samples(num v);

    external void resetRefreshCounter();

    external num get refreshRate;

    external set refreshRate(num v);

    external void addPostProcess(PostProcess postProcess);

    external void clearPostProcesses([bool dispose]);

    external void removePostProcess(PostProcess postProcess);

    external bool JS$_shouldRender();

    external num getRenderSize();

    external num getRenderWidth();

    external num getRenderHeight();

    external bool get canRescale;

    external set canRescale(bool v);

    external void scale(num ratio);

    external Matrix getReflectionTextureMatrix();

    external void resize(dynamic/*num|{
            width: number;
            height: number;
        }|{
            ratio: number;
        }*/
    size);

    external void render([bool useCameraPostProcess, bool dumpForDebug]);

    external get JS$_bestReflectionRenderTargetDimension;

    external set JS$_bestReflectionRenderTargetDimension(v);

    external void unbindFrameBuffer(Engine engine, num faceIndex);

    external get renderToTarget;

    external set renderToTarget(v);

    external void setRenderingOrder(num renderingGroupId, [Func2<SubMesh, SubMesh, num>/*Func2<SubMesh, SubMesh, num>|Null*/ opaqueSortCompareFn, Func2<SubMesh, SubMesh, num>/*Func2<SubMesh, SubMesh, num>|Null*/ alphaTestSortCompareFn, Func2<SubMesh, SubMesh, num>/*Func2<SubMesh, SubMesh, num>|Null*/ transparentSortCompareFn]);

    external void setRenderingAutoClearDepthStencil(num renderingGroupId, bool autoClearDepthStencil);

    external RenderTargetTexture clone();

    external dynamic serialize();

    external void disposeFramebufferObjects();

    external void dispose();

    external void JS$_rebuild();

    external void freeRenderingGroups();
}

@JS("BABYLON.Texture")
class Texture extends BaseTexture {
    // @Ignore
    Texture .fakeConstructor$() : super.fakeConstructor$();
    external static num get NEAREST_SAMPLINGMODE;

    external static set NEAREST_SAMPLINGMODE(num v);

    external static num get NEAREST_NEAREST_MIPLINEAR;

    external static set NEAREST_NEAREST_MIPLINEAR(num v);

    external static num get BILINEAR_SAMPLINGMODE;

    external static set BILINEAR_SAMPLINGMODE(num v);

    external static num get LINEAR_LINEAR_MIPNEAREST;

    external static set LINEAR_LINEAR_MIPNEAREST(num v);

    external static num get TRILINEAR_SAMPLINGMODE;

    external static set TRILINEAR_SAMPLINGMODE(num v);

    external static num get LINEAR_LINEAR_MIPLINEAR;

    external static set LINEAR_LINEAR_MIPLINEAR(num v);

    external static num get NEAREST_NEAREST_MIPNEAREST;

    external static set NEAREST_NEAREST_MIPNEAREST(num v);

    external static num get NEAREST_LINEAR_MIPNEAREST;

    external static set NEAREST_LINEAR_MIPNEAREST(num v);

    external static num get NEAREST_LINEAR_MIPLINEAR;

    external static set NEAREST_LINEAR_MIPLINEAR(num v);

    external static num get NEAREST_LINEAR;

    external static set NEAREST_LINEAR(num v);

    external static num get NEAREST_NEAREST;

    external static set NEAREST_NEAREST(num v);

    external static num get LINEAR_NEAREST_MIPNEAREST;

    external static set LINEAR_NEAREST_MIPNEAREST(num v);

    external static num get LINEAR_NEAREST_MIPLINEAR;

    external static set LINEAR_NEAREST_MIPLINEAR(num v);

    external static num get LINEAR_LINEAR;

    external static set LINEAR_LINEAR(num v);

    external static num get LINEAR_NEAREST;

    external static set LINEAR_NEAREST(num v);

    external static num get EXPLICIT_MODE;

    external static set EXPLICIT_MODE(num v);

    external static num get SPHERICAL_MODE;

    external static set SPHERICAL_MODE(num v);

    external static num get PLANAR_MODE;

    external static set PLANAR_MODE(num v);

    external static num get CUBIC_MODE;

    external static set CUBIC_MODE(num v);

    external static num get PROJECTION_MODE;

    external static set PROJECTION_MODE(num v);

    external static num get SKYBOX_MODE;

    external static set SKYBOX_MODE(num v);

    external static num get INVCUBIC_MODE;

    external static set INVCUBIC_MODE(num v);

    external static num get EQUIRECTANGULAR_MODE;

    external static set EQUIRECTANGULAR_MODE(num v);

    external static num get FIXED_EQUIRECTANGULAR_MODE;

    external static set FIXED_EQUIRECTANGULAR_MODE(num v);

    external static num get FIXED_EQUIRECTANGULAR_MIRRORED_MODE;

    external static set FIXED_EQUIRECTANGULAR_MIRRORED_MODE(num v);

    external static num get CLAMP_ADDRESSMODE;

    external static set CLAMP_ADDRESSMODE(num v);

    external static num get WRAP_ADDRESSMODE;

    external static set WRAP_ADDRESSMODE(num v);

    external static num get MIRROR_ADDRESSMODE;

    external static set MIRROR_ADDRESSMODE(num v);

    external static bool get UseSerializedUrlIfAny;

    external static set UseSerializedUrlIfAny(bool v);

    external String/*String|Null*/ get url;

    external set url(String/*String|Null*/ v);

    external num get uOffset;

    external set uOffset(num v);

    external num get vOffset;

    external set vOffset(num v);

    external num get uScale;

    external set uScale(num v);

    external num get vScale;

    external set vScale(num v);

    external num get uAng;

    external set uAng(num v);

    external num get vAng;

    external set vAng(num v);

    external num get wAng;

    external set wAng(num v);

    external num get uRotationCenter;

    external set uRotationCenter(num v);

    external num get vRotationCenter;

    external set vRotationCenter(num v);

    external num get wRotationCenter;

    external set wRotationCenter(num v);

    external bool get noMipmap;

    external set noMipmap(bool v);

    external get JS$_noMipmap;

    external set JS$_noMipmap(v);

    external bool get JS$_invertY;

    external set JS$_invertY(bool v);

    external get JS$_rowGenerationMatrix;

    external set JS$_rowGenerationMatrix(v);

    external get JS$_cachedTextureMatrix;

    external set JS$_cachedTextureMatrix(v);

    external get JS$_projectionModeMatrix;

    external set JS$_projectionModeMatrix(v);

    external get JS$_t0;

    external set JS$_t0(v);

    external get JS$_t1;

    external set JS$_t1(v);

    external get JS$_t2;

    external set JS$_t2(v);

    external get JS$_cachedUOffset;

    external set JS$_cachedUOffset(v);

    external get JS$_cachedVOffset;

    external set JS$_cachedVOffset(v);

    external get JS$_cachedUScale;

    external set JS$_cachedUScale(v);

    external get JS$_cachedVScale;

    external set JS$_cachedVScale(v);

    external get JS$_cachedUAng;

    external set JS$_cachedUAng(v);

    external get JS$_cachedVAng;

    external set JS$_cachedVAng(v);

    external get JS$_cachedWAng;

    external set JS$_cachedWAng(v);

    external get JS$_cachedProjectionMatrixId;

    external set JS$_cachedProjectionMatrixId(v);

    external get JS$_cachedCoordinatesMode;

    external set JS$_cachedCoordinatesMode(v);

    external num get JS$_samplingMode;

    external set JS$_samplingMode(num v);

    external dynamic/*String|ByteBuffer|ImageElement|Blob|Null*/ get JS$_buffer;

    external set JS$_buffer(dynamic/*String|ByteBuffer|ImageElement|Blob|Null*/ v);

    external get JS$_deleteBuffer;

    external set JS$_deleteBuffer(v);

    external num/*num|Null*/ get JS$_format;

    external set JS$_format(num/*num|Null*/ v);

    external get JS$_delayedOnLoad;

    external set JS$_delayedOnLoad(v);

    external get JS$_delayedOnError;

    external set JS$_delayedOnError(v);

    external Observable<Texture> get onLoadObservable;

    external set onLoadObservable(Observable<Texture> v);

    external bool get JS$_isBlocking;

    external set JS$_isBlocking(bool v);

    external bool get isBlocking;

    external set isBlocking(bool v);

    external num get samplingMode;

    external set samplingMode(num v);

    external factory Texture(String/*String|Null*/ url, Scene/*Scene|Null*/ scene, [bool noMipmap, bool invertY, num samplingMode, VoidFunc0/*VoidFunc0|Null*/ onLoad, Function/*(message?: string, exception?: any) => void|Null*/ onError, dynamic/*String|ByteBuffer|ImageElement|Blob|Null*/ buffer, bool deleteBuffer, num format]);

    external void updateURL(String url, [dynamic/*String|ByteBuffer|ImageElement|Blob|Null*/ buffer]);

    external void delayLoad();

    external void updateSamplingMode(num samplingMode);

    external get JS$_prepareRowForTextureGeneration;

    external set JS$_prepareRowForTextureGeneration(v);

    external Matrix getTextureMatrix();

    external Matrix getReflectionTextureMatrix();

    external Texture clone();

    external dynamic serialize();

    external String getClassName();

    external void dispose();

    external static BaseTexture/*BaseTexture|Null*/ Parse(dynamic parsedTexture, Scene scene, String rootUrl);

    external static Texture CreateFromBase64String(String data, String name, Scene scene, [bool noMipmap, bool invertY, num samplingMode, VoidFunc0/*VoidFunc0|Null*/ onLoad, VoidFunc0/*VoidFunc0|Null*/ onError, num format]);

    external static Texture LoadFromDataString(String name, dynamic buffer, Scene scene, [bool deleteBuffer, bool noMipmap, bool invertY, num samplingMode, VoidFunc0/*VoidFunc0|Null*/ onLoad, Function/*(message?: string, exception?: any) => void|Null*/ onError, num format]);
}

@anonymous
@JS()
abstract class VideoTextureSettings {
    external bool get autoPlay;

    external set autoPlay(bool v);

    external bool get loop;

    external set loop(bool v);

    external bool get autoUpdateTexture;

    external set autoUpdateTexture(bool v);

    external String get poster;

    external set poster(String v);

    external factory VideoTextureSettings({ bool autoPlay, bool loop, bool autoUpdateTexture, String poster});
}

@JS("BABYLON.VideoTexture")
class VideoTexture extends Texture {
    // @Ignore
    VideoTexture .fakeConstructor$() : super.fakeConstructor$();
    external bool get autoUpdateTexture;

    external set autoUpdateTexture(bool v);

    external VideoElement get video;

    external set video(VideoElement v);

    external get JS$_onUserActionRequestedObservable;

    external set JS$_onUserActionRequestedObservable(v);

    external Observable<Texture> get onUserActionRequestedObservable;

    external set onUserActionRequestedObservable(Observable<Texture> v);

    external get JS$_generateMipMaps;

    external set JS$_generateMipMaps(v);

    external get JS$_engine;

    external set JS$_engine(v);

    external get JS$_stillImageCaptured;

    external set JS$_stillImageCaptured(v);

    external get JS$_poster;

    external set JS$_poster(v);

    external factory VideoTexture(String/*String|Null*/ name, dynamic/*String|List<String>|VideoElement*/ src, Scene/*Scene|Null*/ scene, [bool generateMipMaps, bool invertY, num samplingMode, VideoTextureSettings settings]);

    external get JS$_getName;

    external set JS$_getName(v);

    external get JS$_getVideo;

    external set JS$_getVideo(v);

    external get JS$_createInternalTexture;

    external set JS$_createInternalTexture(v);

    external get reset;

    external set reset(v);

    external void JS$_rebuild();

    external void update();

    external void updateTexture(bool isVisible);

    external VoidFunc1Opt1<dynamic /*Event|dynamic*/> get JS$_updateInternalTexture;

    external set JS$_updateInternalTexture(VoidFunc1Opt1<dynamic /*Event|dynamic*/> v);

    external void updateURL(String url);

    external void dispose();

    external static void CreateFromWebCam(Scene scene, void onReady(VideoTexture videoTexture), dynamic/*{
            minWidth: number;
            maxWidth: number;
            minHeight: number;
            maxHeight: number;
            deviceId: string;
        }*/
    constraints);
}

@anonymous
@JS()
abstract class IDracoCompressionConfiguration {
    external dynamic/*{
            /**
             * The url to the WebAssembly module.
             */
            wasmUrl?: string;
            /**
             * The url to the WebAssembly binary.
             */
            wasmBinaryUrl?: string;
            /**
             * The url to the fallback JavaScript module.
             */
            fallbackUrl?: string;
        }*/ get decoder;

    external set decoder(dynamic/*{
            /**
             * The url to the WebAssembly module.
             */
            wasmUrl?: string;
            /**
             * The url to the WebAssembly binary.
             */
            wasmBinaryUrl?: string;
            /**
             * The url to the fallback JavaScript module.
             */
            fallbackUrl?: string;
        }*/
    v);

    external factory IDracoCompressionConfiguration({ dynamic/*{
            /**
             * The url to the WebAssembly module.
             */
            wasmUrl?: string;
            /**
             * The url to the WebAssembly binary.
             */
            wasmBinaryUrl?: string;
            /**
             * The url to the fallback JavaScript module.
             */
            fallbackUrl?: string;
        }*/
    decoder});
}

@JS("BABYLON.DracoCompression")
class DracoCompression implements IDisposable {
    // @Ignore
    DracoCompression .fakeConstructor$();

    external static get JS$_DecoderModulePromise;

    external static set JS$_DecoderModulePromise(v);

    external static IDracoCompressionConfiguration get Configuration;

    external static set Configuration(IDracoCompressionConfiguration v);

    external static bool get DecoderAvailable;

    external static set DecoderAvailable(bool v);

    external factory DracoCompression();

    external void dispose();

    external Promise<VertexData> decodeMeshAsync(dynamic/*ByteBuffer|TypedData*/ data, dynamic/*JSMap of <String,num>*/ attributes);

    external static get JS$_GetDecoderModule;

    external static set JS$_GetDecoderModule(v);

    external static get JS$_LoadScriptAsync;

    external static set JS$_LoadScriptAsync(v);

    external static get JS$_LoadFileAsync;

    external static set JS$_LoadFileAsync(v);
}

@JS("BABYLON.BoxParticleEmitter")
class BoxParticleEmitter implements IParticleEmitterType {
    // @Ignore
    BoxParticleEmitter .fakeConstructor$();

    external Vector3 get direction1;

    external set direction1(Vector3 v);

    external Vector3 get direction2;

    external set direction2(Vector3 v);

    external Vector3 get minEmitBox;

    external set minEmitBox(Vector3 v);

    external Vector3 get maxEmitBox;

    external set maxEmitBox(Vector3 v);

    external factory BoxParticleEmitter();

    external void startDirectionFunction(Matrix worldMatrix, Vector3 directionToUpdate, Particle particle);

    external void startPositionFunction(Matrix worldMatrix, Vector3 positionToUpdate, Particle particle);

    external BoxParticleEmitter clone();

    external void applyToShader(Effect effect);

    external String getEffectDefines();

    external String getClassName();

    external dynamic serialize();

    external void parse(dynamic serializationObject);
}

@JS("BABYLON.ConeParticleEmitter")
class ConeParticleEmitter implements IParticleEmitterType {
    // @Ignore
    ConeParticleEmitter .fakeConstructor$();

    external num get directionRandomizer;

    external set directionRandomizer(num v);

    external get JS$_radius;

    external set JS$_radius(v);

    external get JS$_angle;

    external set JS$_angle(v);

    external get JS$_height;

    external set JS$_height(v);

    external num get radiusRange;

    external set radiusRange(num v);

    external num get heightRange;

    external set heightRange(num v);

    external bool get emitFromSpawnPointOnly;

    external set emitFromSpawnPointOnly(bool v);

    external num get radius;

    external set radius(num v);

    external num get angle;

    external set angle(num v);

    external get JS$_buildHeight;

    external set JS$_buildHeight(v);

    external factory ConeParticleEmitter([num radius, num angle, num directionRandomizer]);

    external void startDirectionFunction(Matrix worldMatrix, Vector3 directionToUpdate, Particle particle);

    external void startPositionFunction(Matrix worldMatrix, Vector3 positionToUpdate, Particle particle);

    external ConeParticleEmitter clone();

    external void applyToShader(Effect effect);

    external String getEffectDefines();

    external String getClassName();

    external dynamic serialize();

    external void parse(dynamic serializationObject);
}

@JS("BABYLON.CylinderParticleEmitter")
class CylinderParticleEmitter implements IParticleEmitterType {
    // @Ignore
    CylinderParticleEmitter .fakeConstructor$();

    external num get radius;

    external set radius(num v);

    external num get height;

    external set height(num v);

    external num get radiusRange;

    external set radiusRange(num v);

    external num get directionRandomizer;

    external set directionRandomizer(num v);

    external factory CylinderParticleEmitter([num radius, num height, num radiusRange, num directionRandomizer]);

    external void startDirectionFunction(Matrix worldMatrix, Vector3 directionToUpdate, Particle particle);

    external void startPositionFunction(Matrix worldMatrix, Vector3 positionToUpdate, Particle particle);

    external CylinderParticleEmitter clone();

    external void applyToShader(Effect effect);

    external String getEffectDefines();

    external String getClassName();

    external dynamic serialize();

    external void parse(dynamic serializationObject);
}

@JS("BABYLON.CylinderDirectedParticleEmitter")
class CylinderDirectedParticleEmitter extends CylinderParticleEmitter {
    // @Ignore
    CylinderDirectedParticleEmitter .fakeConstructor$() : super.fakeConstructor$();
    external Vector3 get direction1;

    external set direction1(Vector3 v);

    external Vector3 get direction2;

    external set direction2(Vector3 v);

    external factory CylinderDirectedParticleEmitter([num radius, num height, num radiusRange, Vector3 direction1, Vector3 direction2]);

    external void startDirectionFunction(Matrix worldMatrix, Vector3 directionToUpdate, Particle particle);

    external CylinderDirectedParticleEmitter clone();

    external void applyToShader(Effect effect);

    external String getEffectDefines();

    external String getClassName();

    external dynamic serialize();

    external void parse(dynamic serializationObject);
}

@JS("BABYLON.HemisphericParticleEmitter")
class HemisphericParticleEmitter implements IParticleEmitterType {
    // @Ignore
    HemisphericParticleEmitter .fakeConstructor$();

    external num get radius;

    external set radius(num v);

    external num get radiusRange;

    external set radiusRange(num v);

    external num get directionRandomizer;

    external set directionRandomizer(num v);

    external factory HemisphericParticleEmitter([num radius, num radiusRange, num directionRandomizer]);

    external void startDirectionFunction(Matrix worldMatrix, Vector3 directionToUpdate, Particle particle);

    external void startPositionFunction(Matrix worldMatrix, Vector3 positionToUpdate, Particle particle);

    external HemisphericParticleEmitter clone();

    external void applyToShader(Effect effect);

    external String getEffectDefines();

    external String getClassName();

    external dynamic serialize();

    external void parse(dynamic serializationObject);
}

@anonymous
@JS()
abstract class IParticleEmitterType {
    external void startDirectionFunction(Matrix worldMatrix, Vector3 directionToUpdate, Particle particle);

    external void startPositionFunction(Matrix worldMatrix, Vector3 positionToUpdate, Particle particle);

    external IParticleEmitterType clone();

    external void applyToShader(Effect effect);

    external String getEffectDefines();

    external String getClassName();

    external dynamic serialize();

    external void parse(dynamic serializationObject);
}

@JS("BABYLON.PointParticleEmitter")
class PointParticleEmitter implements IParticleEmitterType {
    // @Ignore
    PointParticleEmitter .fakeConstructor$();

    external Vector3 get direction1;

    external set direction1(Vector3 v);

    external Vector3 get direction2;

    external set direction2(Vector3 v);

    external factory PointParticleEmitter();

    external void startDirectionFunction(Matrix worldMatrix, Vector3 directionToUpdate, Particle particle);

    external void startPositionFunction(Matrix worldMatrix, Vector3 positionToUpdate, Particle particle);

    external PointParticleEmitter clone();

    external void applyToShader(Effect effect);

    external String getEffectDefines();

    external String getClassName();

    external dynamic serialize();

    external void parse(dynamic serializationObject);
}

@JS("BABYLON.SphereParticleEmitter")
class SphereParticleEmitter implements IParticleEmitterType {
    // @Ignore
    SphereParticleEmitter .fakeConstructor$();

    external num get radius;

    external set radius(num v);

    external num get radiusRange;

    external set radiusRange(num v);

    external num get directionRandomizer;

    external set directionRandomizer(num v);

    external factory SphereParticleEmitter([num radius, num radiusRange, num directionRandomizer]);

    external void startDirectionFunction(Matrix worldMatrix, Vector3 directionToUpdate, Particle particle);

    external void startPositionFunction(Matrix worldMatrix, Vector3 positionToUpdate, Particle particle);

    external SphereParticleEmitter clone();

    external void applyToShader(Effect effect);

    external String getEffectDefines();

    external String getClassName();

    external dynamic serialize();

    external void parse(dynamic serializationObject);
}

@JS("BABYLON.SphereDirectedParticleEmitter")
class SphereDirectedParticleEmitter extends SphereParticleEmitter {
    // @Ignore
    SphereDirectedParticleEmitter .fakeConstructor$() : super.fakeConstructor$();
    external Vector3 get direction1;

    external set direction1(Vector3 v);

    external Vector3 get direction2;

    external set direction2(Vector3 v);

    external factory SphereDirectedParticleEmitter([num radius, Vector3 direction1, Vector3 direction2]);

    external void startDirectionFunction(Matrix worldMatrix, Vector3 directionToUpdate, Particle particle);

    external SphereDirectedParticleEmitter clone();

    external void applyToShader(Effect effect);

    external String getEffectDefines();

    external String getClassName();

    external dynamic serialize();

    external void parse(dynamic serializationObject);
}

@JS("BABYLON.CannonJSPlugin")
class CannonJSPlugin implements IPhysicsEnginePlugin {
    // @Ignore
    CannonJSPlugin .fakeConstructor$();

    external get JS$_useDeltaForWorldStep;

    external set JS$_useDeltaForWorldStep(v);

    external dynamic get world;

    external set world(dynamic v);

    external String get name;

    external set name(String v);

    external get JS$_physicsMaterials;

    external set JS$_physicsMaterials(v);

    external get JS$_fixedTimeStep;

    external set JS$_fixedTimeStep(v);

    external dynamic get BJSCANNON;

    external set BJSCANNON(dynamic v);

    external factory CannonJSPlugin([bool JS$_useDeltaForWorldStep, num iterations]);

    external void setGravity(Vector3 gravity);

    external void setTimeStep(num timeStep);

    external num getTimeStep();

    external void executeStep(num delta, List<PhysicsImpostor> impostors);

    external void applyImpulse(PhysicsImpostor impostor, Vector3 force, Vector3 contactPoint);

    external void applyForce(PhysicsImpostor impostor, Vector3 force, Vector3 contactPoint);

    external void generatePhysicsBody(PhysicsImpostor impostor);

    external get JS$_processChildMeshes;

    external set JS$_processChildMeshes(v);

    external void removePhysicsBody(PhysicsImpostor impostor);

    external void generateJoint(PhysicsImpostorJoint impostorJoint);

    external void removeJoint(PhysicsImpostorJoint impostorJoint);

    external get JS$_addMaterial;

    external set JS$_addMaterial(v);

    external get JS$_checkWithEpsilon;

    external set JS$_checkWithEpsilon(v);

    external get JS$_createShape;

    external set JS$_createShape(v);

    external get JS$_createHeightmap;

    external set JS$_createHeightmap(v);

    external get JS$_minus90X;

    external set JS$_minus90X(v);

    external get JS$_plus90X;

    external set JS$_plus90X(v);

    external get JS$_tmpPosition;

    external set JS$_tmpPosition(v);

    external get JS$_tmpDeltaPosition;

    external set JS$_tmpDeltaPosition(v);

    external get JS$_tmpUnityRotation;

    external set JS$_tmpUnityRotation(v);

    external get JS$_updatePhysicsBodyTransformation;

    external set JS$_updatePhysicsBodyTransformation(v);

    external void setTransformationFromPhysicsBody(PhysicsImpostor impostor);

    external void setPhysicsBodyTransformation(PhysicsImpostor impostor, Vector3 newPosition, Quaternion newRotation);

    external bool isSupported();

    external void setLinearVelocity(PhysicsImpostor impostor, Vector3 velocity);

    external void setAngularVelocity(PhysicsImpostor impostor, Vector3 velocity);

    external Vector3/*Vector3|Null*/ getLinearVelocity(PhysicsImpostor impostor);

    external Vector3/*Vector3|Null*/ getAngularVelocity(PhysicsImpostor impostor);

    external void setBodyMass(PhysicsImpostor impostor, num mass);

    external num getBodyMass(PhysicsImpostor impostor);

    external num getBodyFriction(PhysicsImpostor impostor);

    external void setBodyFriction(PhysicsImpostor impostor, num friction);

    external num getBodyRestitution(PhysicsImpostor impostor);

    external void setBodyRestitution(PhysicsImpostor impostor, num restitution);

    external void sleepBody(PhysicsImpostor impostor);

    external void wakeUpBody(PhysicsImpostor impostor);

    external void updateDistanceJoint(PhysicsJoint joint, num maxDistance, [num minDistance]);

    external void setMotor(IMotorEnabledJoint joint, [num speed, num maxForce, num motorIndex]);

    external void setLimit(IMotorEnabledJoint joint, num upperLimit, [num lowerLimit]);

    external void syncMeshWithImpostor(AbstractMesh mesh, PhysicsImpostor impostor);

    external num getRadius(PhysicsImpostor impostor);

    external void getBoxSizeToRef(PhysicsImpostor impostor, Vector3 result);

    external void dispose();

    external get JS$_extendNamespace;

    external set JS$_extendNamespace(v);
}

@JS("BABYLON.OimoJSPlugin")
class OimoJSPlugin implements IPhysicsEnginePlugin {
    // @Ignore
    OimoJSPlugin .fakeConstructor$();

    external dynamic get world;

    external set world(dynamic v);

    external String get name;

    external set name(String v);

    external dynamic get BJSOIMO;

    external set BJSOIMO(dynamic v);

    external factory OimoJSPlugin([num iterations]);

    external void setGravity(Vector3 gravity);

    external void setTimeStep(num timeStep);

    external num getTimeStep();

    external get JS$_tmpImpostorsArray;

    external set JS$_tmpImpostorsArray(v);

    external void executeStep(num delta, List<PhysicsImpostor> impostors);

    external void applyImpulse(PhysicsImpostor impostor, Vector3 force, Vector3 contactPoint);

    external void applyForce(PhysicsImpostor impostor, Vector3 force, Vector3 contactPoint);

    external void generatePhysicsBody(PhysicsImpostor impostor);

    external get JS$_tmpPositionVector;

    external set JS$_tmpPositionVector(v);

    external void removePhysicsBody(PhysicsImpostor impostor);

    external void generateJoint(PhysicsImpostorJoint impostorJoint);

    external void removeJoint(PhysicsImpostorJoint impostorJoint);

    external bool isSupported();

    external void setTransformationFromPhysicsBody(PhysicsImpostor impostor);

    external void setPhysicsBodyTransformation(PhysicsImpostor impostor, Vector3 newPosition, Quaternion newRotation);

    external void setLinearVelocity(PhysicsImpostor impostor, Vector3 velocity);

    external void setAngularVelocity(PhysicsImpostor impostor, Vector3 velocity);

    external Vector3/*Vector3|Null*/ getLinearVelocity(PhysicsImpostor impostor);

    external Vector3/*Vector3|Null*/ getAngularVelocity(PhysicsImpostor impostor);

    external void setBodyMass(PhysicsImpostor impostor, num mass);

    external num getBodyMass(PhysicsImpostor impostor);

    external num getBodyFriction(PhysicsImpostor impostor);

    external void setBodyFriction(PhysicsImpostor impostor, num friction);

    external num getBodyRestitution(PhysicsImpostor impostor);

    external void setBodyRestitution(PhysicsImpostor impostor, num restitution);

    external void sleepBody(PhysicsImpostor impostor);

    external void wakeUpBody(PhysicsImpostor impostor);

    external void updateDistanceJoint(PhysicsJoint joint, num maxDistance, [num minDistance]);

    external void setMotor(IMotorEnabledJoint joint, num speed, [num maxForce, num motorIndex]);

    external void setLimit(IMotorEnabledJoint joint, num upperLimit, [num lowerLimit, num motorIndex]);

    external void syncMeshWithImpostor(AbstractMesh mesh, PhysicsImpostor impostor);

    external num getRadius(PhysicsImpostor impostor);

    external void getBoxSizeToRef(PhysicsImpostor impostor, Vector3 result);

    external void dispose();
}

@JS("BABYLON.PostProcessRenderEffect")
class PostProcessRenderEffect {
    // @Ignore
    PostProcessRenderEffect .fakeConstructor$();

    external get JS$_postProcesses;

    external set JS$_postProcesses(v);

    external get JS$_getPostProcesses;

    external set JS$_getPostProcesses(v);

    external get JS$_singleInstance;

    external set JS$_singleInstance(v);

    external get JS$_cameras;

    external set JS$_cameras(v);

    external get JS$_indicesForCamera;

    external set JS$_indicesForCamera(v);

    external String get JS$_name;

    external set JS$_name(String v);

    external factory PostProcessRenderEffect(Engine engine, String name, dynamic/*PostProcess|List<PostProcess>|Null*/ getPostProcesses(), [bool singleInstance]);

    external bool get isSupported;

    external set isSupported(bool v);

    external void JS$_update();

    /*external void JS$_attachCameras(Camera cameras);*/
    /*external void JS$_attachCameras(List<Camera> cameras);*/
    external void JS$_attachCameras(dynamic/*Camera|List<Camera>*/ cameras);

    /*external void JS$_detachCameras(Camera cameras);*/
    /*external void JS$_detachCameras(List<Camera> cameras);*/
    external void JS$_detachCameras(dynamic/*Camera|List<Camera>*/ cameras);

    /*external void JS$_enable(Camera cameras);*/
    /*external void JS$_enable(List<Camera>|Null cameras);*/
    external void JS$_enable(dynamic/*Camera|T*/ cameras);

    /*external void JS$_disable(Camera cameras);*/
    /*external void JS$_disable(List<Camera>|Null cameras);*/
    external void JS$_disable(dynamic/*Camera|T*/ cameras);

    external List<PostProcess>/*List<PostProcess>|Null*/ getPostProcesses([Camera camera]);
}

@JS("BABYLON.PostProcessRenderPipeline")
class PostProcessRenderPipeline {
    // @Ignore
    PostProcessRenderPipeline .fakeConstructor$();

    external get engine;

    external set engine(v);

    external get JS$_renderEffects;

    external set JS$_renderEffects(v);

    external get JS$_renderEffectsForIsolatedPass;

    external set JS$_renderEffectsForIsolatedPass(v);

    external List<Camera> get JS$_cameras;

    external set JS$_cameras(List<Camera> v);

    external String get JS$_name;

    external set JS$_name(String v);

    external factory PostProcessRenderPipeline(Engine engine, String name);

    external String getClassName();

    external bool get isSupported;

    external set isSupported(bool v);

    external void addEffect(PostProcessRenderEffect renderEffect);

    external void JS$_rebuild();

    /*external void JS$_enableEffect(String renderEffectName, Camera cameras);*/
    /*external void JS$_enableEffect(String renderEffectName, List<Camera> cameras);*/
    external void JS$_enableEffect(String renderEffectName, dynamic/*Camera|List<Camera>*/ cameras);

    /*external void JS$_disableEffect(String renderEffectName, List<Camera>|Null cameras);*/
    /*external void JS$_disableEffect(String renderEffectName, List<Camera>|Null cameras);*/
    external void JS$_disableEffect(String renderEffectName, T cameras);

    /*external void JS$_attachCameras(Camera cameras, bool unique);*/
    /*external void JS$_attachCameras(List<Camera> cameras, bool unique);*/
    external void JS$_attachCameras(dynamic/*Camera|List<Camera>*/ cameras, bool unique);

    /*external void JS$_detachCameras(Camera cameras);*/
    /*external void JS$_detachCameras(List<Camera>|Null cameras);*/
    external void JS$_detachCameras(dynamic/*Camera|T*/ cameras);

    external void JS$_update();

    external void JS$_reset();

    external bool JS$_enableMSAAOnFirstPostProcess(num sampleCount);

    external void dispose();
}

@JS("BABYLON.PostProcessRenderPipelineManager")
class PostProcessRenderPipelineManager {
    // @Ignore
    PostProcessRenderPipelineManager .fakeConstructor$();

    external get JS$_renderPipelines;

    external set JS$_renderPipelines(v);

    external factory PostProcessRenderPipelineManager();

    external void addPipeline(PostProcessRenderPipeline renderPipeline);

    external void attachCamerasToRenderPipeline(String renderPipelineName, dynamic/*dynamic|List<Camera>|Camera*/ cameras, [bool unique]);

    external void detachCamerasFromRenderPipeline(String renderPipelineName, dynamic/*dynamic|List<Camera>|Camera*/ cameras);

    external void enableEffectInPipeline(String renderPipelineName, String renderEffectName, dynamic/*dynamic|List<Camera>|Camera*/ cameras);

    external void disableEffectInPipeline(String renderPipelineName, String renderEffectName, dynamic/*dynamic|List<Camera>|Camera*/ cameras);

    external void update();

    external void JS$_rebuild();

    external void dispose();
}

@JS("BABYLON.PostProcessRenderPipelineManagerSceneComponent")
class PostProcessRenderPipelineManagerSceneComponent implements ISceneComponent {
    // @Ignore
    PostProcessRenderPipelineManagerSceneComponent .fakeConstructor$();

    external String get name;

    external set name(String v);

    external Scene get scene;

    external set scene(Scene v);

    external factory PostProcessRenderPipelineManagerSceneComponent(Scene scene);

    external void register();

    external void rebuild();

    external void dispose();

    external get JS$_gatherRenderTargets;

    external set JS$_gatherRenderTargets(v);
}

@JS("BABYLON.CubeMapToSphericalPolynomialTools")
class CubeMapToSphericalPolynomialTools {
    // @Ignore
    CubeMapToSphericalPolynomialTools .fakeConstructor$();

    external static get FileFaces;

    external static set FileFaces(v);

    external static SphericalPolynomial/*SphericalPolynomial|Null*/ ConvertCubeMapTextureToSphericalPolynomial(BaseTexture texture);

    external static SphericalPolynomial ConvertCubeMapToSphericalPolynomial(CubeMapInfo cubeInfo);
}

@anonymous
@JS()
abstract class HDRInfo {
    external num get height;

    external set height(num v);

    external num get width;

    external set width(num v);

    external num get dataPosition;

    external set dataPosition(num v);

    external factory HDRInfo({ num height, num width, num dataPosition});
}

@JS("BABYLON.HDRTools")
class HDRTools {
    // @Ignore
    HDRTools .fakeConstructor$();

    external static get Ldexp;

    external static set Ldexp(v);

    external static get Rgbe2float;

    external static set Rgbe2float(v);

    external static get readStringLine;

    external static set readStringLine(v);

    external static HDRInfo RGBE_ReadHeader(Uint8List uint8array);

    external static CubeMapInfo GetCubeMapTextureData(ByteBuffer buffer, num size);

    external static Float32List RGBE_ReadPixels(Uint8List uint8array, HDRInfo hdrInfo);

    external static get RGBE_ReadPixels_RLE;

    external static set RGBE_ReadPixels_RLE(v);
}

@anonymous
@JS()
abstract class CubeMapInfo {
    external TypedData/*TypedData|Null*/ get front;

    external set front(TypedData/*TypedData|Null*/ v);

    external TypedData/*TypedData|Null*/ get back;

    external set back(TypedData/*TypedData|Null*/ v);

    external TypedData/*TypedData|Null*/ get left;

    external set left(TypedData/*TypedData|Null*/ v);

    external TypedData/*TypedData|Null*/ get right;

    external set right(TypedData/*TypedData|Null*/ v);

    external TypedData/*TypedData|Null*/ get up;

    external set up(TypedData/*TypedData|Null*/ v);

    external TypedData/*TypedData|Null*/ get down;

    external set down(TypedData/*TypedData|Null*/ v);

    external num get size;

    external set size(num v);

    external num get format;

    external set format(num v);

    external num get type;

    external set type(num v);

    external bool get gammaSpace;

    external set gammaSpace(bool v);

    external factory CubeMapInfo({ TypedData/*TypedData|Null*/ front, TypedData/*TypedData|Null*/ back, TypedData/*TypedData|Null*/ left, TypedData/*TypedData|Null*/ right, TypedData/*TypedData|Null*/ up, TypedData/*TypedData|Null*/ down, num size, num format, num type, bool gammaSpace});
}

@JS("BABYLON.PanoramaToCubeMapTools")
class PanoramaToCubeMapTools {
    // @Ignore
    PanoramaToCubeMapTools .fakeConstructor$();

    external static get FACE_FRONT;

    external static set FACE_FRONT(v);

    external static get FACE_BACK;

    external static set FACE_BACK(v);

    external static get FACE_RIGHT;

    external static set FACE_RIGHT(v);

    external static get FACE_LEFT;

    external static set FACE_LEFT(v);

    external static get FACE_DOWN;

    external static set FACE_DOWN(v);

    external static get FACE_UP;

    external static set FACE_UP(v);

    external static CubeMapInfo ConvertPanoramaToCubemap(Float32List float32Array, num inputWidth, num inputHeight, num size);

    external static get CreateCubemapTexture;

    external static set CreateCubemapTexture(v);

    external static get CalcProjectionSpherical;

    external static set CalcProjectionSpherical(v);
}

@JS("BABYLON.CustomProceduralTexture")
class CustomProceduralTexture extends ProceduralTexture {
    // @Ignore
    CustomProceduralTexture .fakeConstructor$() : super.fakeConstructor$();
    external get JS$_animate;

    external set JS$_animate(v);

    external get JS$_time;

    external set JS$_time(v);

    external get JS$_config;

    external set JS$_config(v);

    external get JS$_texturePath;

    external set JS$_texturePath(v);

    external factory CustomProceduralTexture(String name, String texturePath, num size, Scene scene, [Texture fallbackTexture, bool generateMipMaps]);

    external get JS$_loadJson;

    external set JS$_loadJson(v);

    external bool isReady();

    external void render([bool useCameraPostProcess]);

    external void updateTextures();

    external void updateShaderUniforms();

    external bool get animate;

    external set animate(bool v);
}

@JS("BABYLON.NoiseProceduralTexture")
class NoiseProceduralTexture extends ProceduralTexture {
    // @Ignore
    NoiseProceduralTexture .fakeConstructor$() : super.fakeConstructor$();
    external get JS$_time;

    external set JS$_time(v);

    external num get brightness;

    external set brightness(num v);

    external num get octaves;

    external set octaves(num v);

    external num get persistence;

    external set persistence(num v);

    external num get animationSpeedFactor;

    external set animationSpeedFactor(num v);

    external factory NoiseProceduralTexture(String name, [num size, Scene/*Scene|Null*/ scene, Texture fallbackTexture, bool generateMipMaps]);

    external get JS$_updateShaderUniforms;

    external set JS$_updateShaderUniforms(v);

    external String JS$_getDefines();

    external void render([bool useCameraPostProcess]);

    external dynamic serialize();

    external static NoiseProceduralTexture Parse(dynamic parsedTexture, Scene scene, String rootUrl);
}

@JS("BABYLON.ProceduralTexture")
class ProceduralTexture extends Texture {
    // @Ignore
    ProceduralTexture .fakeConstructor$() : super.fakeConstructor$();
    external bool get isCube;

    external set isCube(bool v);

    external bool get isEnabled;

    external set isEnabled(bool v);

    external bool get autoClear;

    external set autoClear(bool v);

    external VoidFunc0 get onGenerated;

    external set onGenerated(VoidFunc0 v);

    external Observable<ProceduralTexture> get onGeneratedObservable;

    external set onGeneratedObservable(Observable<ProceduralTexture> v);

    external bool get JS$_generateMipMaps;

    external set JS$_generateMipMaps(bool v);

    external Effect get JS$_effect;

    external set JS$_effect(Effect v);

    external dynamic/*JSMap of <String,Texture>*/ get JS$_textures;

    external set JS$_textures(dynamic/*JSMap of <String,Texture>*/ v);

    external get JS$_size;

    external set JS$_size(v);

    external get JS$_currentRefreshId;

    external set JS$_currentRefreshId(v);

    external get JS$_refreshRate;

    external set JS$_refreshRate(v);

    external get JS$_vertexBuffers;

    external set JS$_vertexBuffers(v);

    external get JS$_indexBuffer;

    external set JS$_indexBuffer(v);

    external get JS$_uniforms;

    external set JS$_uniforms(v);

    external get JS$_samplers;

    external set JS$_samplers(v);

    external get JS$_fragment;

    external set JS$_fragment(v);

    external get JS$_floats;

    external set JS$_floats(v);

    external get JS$_ints;

    external set JS$_ints(v);

    external get JS$_floatsArrays;

    external set JS$_floatsArrays(v);

    external get JS$_colors3;

    external set JS$_colors3(v);

    external get JS$_colors4;

    external set JS$_colors4(v);

    external get JS$_vectors2;

    external set JS$_vectors2(v);

    external get JS$_vectors3;

    external set JS$_vectors3(v);

    external get JS$_matrices;

    external set JS$_matrices(v);

    external get JS$_fallbackTexture;

    external set JS$_fallbackTexture(v);

    external get JS$_fallbackTextureUsed;

    external set JS$_fallbackTextureUsed(v);

    external get JS$_engine;

    external set JS$_engine(v);

    external get JS$_cachedDefines;

    external set JS$_cachedDefines(v);

    external get JS$_contentUpdateId;

    external set JS$_contentUpdateId(v);

    external get JS$_contentData;

    external set JS$_contentData(v);

    external factory ProceduralTexture(String name, dynamic size, dynamic fragment, Scene/*Scene|Null*/ scene, [Texture/*Texture|Null*/ fallbackTexture, bool generateMipMaps, bool isCube]);

    external TypedData/*TypedData|Null*/ getContent();

    external get JS$_createIndexBuffer;

    external set JS$_createIndexBuffer(v);

    external void JS$_rebuild();

    external void reset();

    external String JS$_getDefines();

    external bool isReady();

    external void resetRefreshCounter();

    external void setFragment(dynamic fragment);

    external num get refreshRate;

    external set refreshRate(num v);

    external bool JS$_shouldRender();

    external num getRenderSize();

    external void resize(num size, bool generateMipMaps);

    external get JS$_checkUniform;

    external set JS$_checkUniform(v);

    external ProceduralTexture setTexture(String name, Texture texture);

    external ProceduralTexture setFloat(String name, num value);

    external ProceduralTexture setInt(String name, num value);

    external ProceduralTexture setFloats(String name, List<num> value);

    external ProceduralTexture setColor3(String name, Color3 value);

    external ProceduralTexture setColor4(String name, Color4 value);

    external ProceduralTexture setVector2(String name, Vector2 value);

    external ProceduralTexture setVector3(String name, Vector3 value);

    external ProceduralTexture setMatrix(String name, Matrix value);

    external void render([bool useCameraPostProcess]);

    external ProceduralTexture clone();

    external void dispose();
}

/// Defines the Procedural Texture scene component responsible to manage any Procedural Texture
/// in a given scene.
@JS("BABYLON.ProceduralTextureSceneComponent")
class ProceduralTextureSceneComponent implements ISceneComponent {
    // @Ignore
    ProceduralTextureSceneComponent .fakeConstructor$();

    /// The component name helpfull to identify the component in the list of scene components.
    external String get name;

    external set name(String v);

    /// The scene the component belongs to.
    external Scene get scene;

    external set scene(Scene v);

    /// Creates a new instance of the component for the given scene
    external factory ProceduralTextureSceneComponent(Scene scene);

    /// Registers the component in a given scene
    external void register();

    /// Rebuilds the elements related to this component in case of
    /// context lost for instance.
    external void rebuild();

    /// Disposes the component and the associated ressources.
    external void dispose();

    external get JS$_beforeClear;

    external set JS$_beforeClear(v);
}

/// The default rendering pipeline can be added to a scene to apply common post processing effects such as anti-aliasing or depth of field.
/// See https://doc.babylonjs.com/how_to/using_default_rendering_pipeline
@JS("BABYLON.DefaultRenderingPipeline")
class DefaultRenderingPipeline extends PostProcessRenderPipeline implements IDisposable, IAnimatable {
    // @Ignore
    DefaultRenderingPipeline .fakeConstructor$() : super.fakeConstructor$();
    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_camerasToBeAttached;

    external set JS$_camerasToBeAttached(v);

    /// ID of the sharpen post process,
    external get SharpenPostProcessId;

    external set SharpenPostProcessId(v);

    /// @ignore
    /// ID of the image processing post process;
    external String get ImageProcessingPostProcessId;

    external set ImageProcessingPostProcessId(String v);

    /// @ignore
    /// ID of the Fast Approximate Anti-Aliasing post process;
    external String get FxaaPostProcessId;

    external set FxaaPostProcessId(String v);

    /// ID of the chromatic aberration post process,
    external get ChromaticAberrationPostProcessId;

    external set ChromaticAberrationPostProcessId(v);

    /// ID of the grain post process
    external get GrainPostProcessId;

    external set GrainPostProcessId(v);

    /// Sharpen post process which will apply a sharpen convolution to enhance edges
    external SharpenPostProcess get sharpen;

    external set sharpen(SharpenPostProcess v);

    external get JS$_sharpenEffect;

    external set JS$_sharpenEffect(v);

    external get bloom;

    external set bloom(v);

    /// Depth of field effect, applies a blur based on how far away objects are from the focus distance.
    external DepthOfFieldEffect get depthOfField;

    external set depthOfField(DepthOfFieldEffect v);

    /// The Fast Approximate Anti-Aliasing post process which attemps to remove aliasing from an image.
    external FxaaPostProcess get fxaa;

    external set fxaa(FxaaPostProcess v);

    /// Image post processing pass used to perform operations such as tone mapping or color grading.
    external ImageProcessingPostProcess get imageProcessing;

    external set imageProcessing(ImageProcessingPostProcess v);

    /// Chromatic aberration post process which will shift rgb colors in the image
    external ChromaticAberrationPostProcess get chromaticAberration;

    external set chromaticAberration(ChromaticAberrationPostProcess v);

    external get JS$_chromaticAberrationEffect;

    external set JS$_chromaticAberrationEffect(v);

    /// Grain post process which add noise to the image
    external GrainPostProcess get grain;

    external set grain(GrainPostProcess v);

    external get JS$_grainEffect;

    external set JS$_grainEffect(v);

    /// Glow post process which adds a glow to emmisive areas of the image
    external get JS$_glowLayer;

    external set JS$_glowLayer(v);

    /// Animations which can be used to tweak settings over a period of time
    external List<Animation> get animations;

    external set animations(List<Animation> v);

    external get JS$_imageProcessingConfigurationObserver;

    external set JS$_imageProcessingConfigurationObserver(v);

    external get JS$_sharpenEnabled;

    external set JS$_sharpenEnabled(v);

    external get JS$_bloomEnabled;

    external set JS$_bloomEnabled(v);

    external get JS$_depthOfFieldEnabled;

    external set JS$_depthOfFieldEnabled(v);

    external get JS$_depthOfFieldBlurLevel;

    external set JS$_depthOfFieldBlurLevel(v);

    external get JS$_fxaaEnabled;

    external set JS$_fxaaEnabled(v);

    external get JS$_imageProcessingEnabled;

    external set JS$_imageProcessingEnabled(v);

    external get JS$_defaultPipelineTextureType;

    external set JS$_defaultPipelineTextureType(v);

    external get JS$_bloomScale;

    external set JS$_bloomScale(v);

    external get JS$_chromaticAberrationEnabled;

    external set JS$_chromaticAberrationEnabled(v);

    external get JS$_grainEnabled;

    external set JS$_grainEnabled(v);

    external get JS$_buildAllowed;

    external set JS$_buildAllowed(v);

    /// Enable or disable the sharpen process from the pipeline
    external bool get sharpenEnabled;

    external set sharpenEnabled(bool v);

    external get JS$_resizeObserver;

    external set JS$_resizeObserver(v);

    external get JS$_hardwareScaleLevel;

    external set JS$_hardwareScaleLevel(v);

    external get JS$_bloomKernel;

    external set JS$_bloomKernel(v);

    /// Specifies the size of the bloom blur kernel, relative to the final output size
    external num get bloomKernel;

    external set bloomKernel(num v);

    /// Specifies the weight of the bloom in the final rendering
    external get JS$_bloomWeight;

    external set JS$_bloomWeight(v);

    /// Specifies the luma threshold for the area that will be blurred by the bloom
    external get JS$_bloomThreshold;

    external set JS$_bloomThreshold(v);

    external get JS$_hdr;

    external set JS$_hdr(v);

    /// The strength of the bloom.
    external num get bloomWeight;

    external set bloomWeight(num v);

    /// The strength of the bloom.
    external num get bloomThreshold;

    external set bloomThreshold(num v);

    /// The scale of the bloom, lower value will provide better performance.
    external num get bloomScale;

    external set bloomScale(num v);

    /// Enable or disable the bloom from the pipeline
    external bool get bloomEnabled;

    external set bloomEnabled(bool v);

    external get JS$_rebuildBloom;

    external set JS$_rebuildBloom(v);

    /// If the depth of field is enabled.
    external bool get depthOfFieldEnabled;

    external set depthOfFieldEnabled(bool v);

    /// Blur level of the depth of field effect. (Higher blur will effect performance)
    external num/*enum DepthOfFieldEffectBlurLevel*/ get depthOfFieldBlurLevel;

    external set depthOfFieldBlurLevel(num/*enum DepthOfFieldEffectBlurLevel*/ v);

    /// If the anti aliasing is enabled.
    external bool get fxaaEnabled;

    external set fxaaEnabled(bool v);

    external get JS$_samples;

    external set JS$_samples(v);

    /// MSAA sample count, setting this to 4 will provide 4x anti aliasing. (default: 1)
    external num get samples;

    external set samples(num v);

    /// If image processing is enabled.
    external bool get imageProcessingEnabled;

    external set imageProcessingEnabled(bool v);

    /// If glow layer is enabled. (Adds a glow effect to emmissive materials)
    external bool get glowLayerEnabled;

    external set glowLayerEnabled(bool v);

    /// Enable or disable the chromaticAberration process from the pipeline
    external bool get chromaticAberrationEnabled;

    external set chromaticAberrationEnabled(bool v);

    /// Enable or disable the grain process from the pipeline
    external bool get grainEnabled;

    external set grainEnabled(bool v);

    /// @constructor
    external factory DefaultRenderingPipeline([String name, bool hdr, Scene scene, List<Camera> cameras, bool automaticBuild]);

    /// Force the compilation of the entire pipeline.
    external void prepare();

    external get JS$_hasCleared;

    external set JS$_hasCleared(v);

    external get JS$_prevPostProcess;

    external set JS$_prevPostProcess(v);

    external get JS$_prevPrevPostProcess;

    external set JS$_prevPrevPostProcess(v);

    external get JS$_setAutoClearAndTextureSharing;

    external set JS$_setAutoClearAndTextureSharing(v);

    external get JS$_depthOfFieldSceneObserver;

    external set JS$_depthOfFieldSceneObserver(v);

    external get JS$_buildPipeline;

    external set JS$_buildPipeline(v);

    external get JS$_disposePostProcesses;

    external set JS$_disposePostProcesses(v);

    /// Adds a camera to the pipeline
    external void addCamera(Camera camera);

    /// Removes a camera from the pipeline
    external void removeCamera(Camera camera);

    /// Dispose of the pipeline and stop all post processes
    external void dispose();

    /// Serialize the rendering pipeline (Used when exporting)
    external dynamic serialize();

    /// Parse the serialized pipeline
    external static DefaultRenderingPipeline Parse(dynamic source, Scene scene, String rootUrl);
}

/// BABYLON.JS Chromatic Aberration GLSL Shader
/// Author: Olivier Guyot
/// Separates very slightly R, G and B colors on the edges of the screen
/// Inspired by Francois Tarlier & Martins Upitis
@JS("BABYLON.LensRenderingPipeline")
class LensRenderingPipeline extends PostProcessRenderPipeline {
    // @Ignore
    LensRenderingPipeline .fakeConstructor$() : super.fakeConstructor$();

    /// @ignore
    /// The chromatic aberration PostProcess id in the pipeline
    external String get LensChromaticAberrationEffect;

    external set LensChromaticAberrationEffect(String v);

    /// @ignore
    /// The highlights enhancing PostProcess id in the pipeline
    external String get HighlightsEnhancingEffect;

    external set HighlightsEnhancingEffect(String v);

    /// @ignore
    /// The depth-of-field PostProcess id in the pipeline
    external String get LensDepthOfFieldEffect;

    external set LensDepthOfFieldEffect(String v);

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_depthTexture;

    external set JS$_depthTexture(v);

    external get JS$_grainTexture;

    external set JS$_grainTexture(v);

    external get JS$_chromaticAberrationPostProcess;

    external set JS$_chromaticAberrationPostProcess(v);

    external get JS$_highlightsPostProcess;

    external set JS$_highlightsPostProcess(v);

    external get JS$_depthOfFieldPostProcess;

    external set JS$_depthOfFieldPostProcess(v);

    external get JS$_edgeBlur;

    external set JS$_edgeBlur(v);

    external get JS$_grainAmount;

    external set JS$_grainAmount(v);

    external get JS$_chromaticAberration;

    external set JS$_chromaticAberration(v);

    external get JS$_distortion;

    external set JS$_distortion(v);

    external get JS$_highlightsGain;

    external set JS$_highlightsGain(v);

    external get JS$_highlightsThreshold;

    external set JS$_highlightsThreshold(v);

    external get JS$_dofDistance;

    external set JS$_dofDistance(v);

    external get JS$_dofAperture;

    external set JS$_dofAperture(v);

    external get JS$_dofDarken;

    external set JS$_dofDarken(v);

    external get JS$_dofPentagon;

    external set JS$_dofPentagon(v);

    external get JS$_blurNoise;

    external set JS$_blurNoise(v);

    /// @constructor
    /// Effect parameters are as follow:
    /// {
    /// chromatic_aberration: number;       // from 0 to x (1 for realism)
    /// edge_blur: number;                  // from 0 to x (1 for realism)
    /// distortion: number;                 // from 0 to x (1 for realism)
    /// grain_amount: number;               // from 0 to 1
    /// grain_texture: BABYLON.Texture;     // texture to use for grain effect; if unset, use random B&W noise
    /// dof_focus_distance: number;         // depth-of-field: focus distance; unset to disable (disabled by default)
    /// dof_aperture: number;               // depth-of-field: focus blur bias (default: 1)
    /// dof_darken: number;                 // depth-of-field: darken that which is out of focus (from 0 to 1, disabled by default)
    /// dof_pentagon: boolean;              // depth-of-field: makes a pentagon-like "bokeh" effect
    /// dof_gain: number;                   // depth-of-field: highlights gain; unset to disable (disabled by default)
    /// dof_threshold: number;              // depth-of-field: highlights threshold (default: 1)
    /// blur_noise: boolean;                // add a little bit of noise to the blur (default: true)
    /// }
    /// Note: if an effect parameter is unset, effect is disabled
    external factory LensRenderingPipeline(String name, dynamic parameters, Scene scene, [num ratio, List<Camera> cameras]);

    /// Sets the amount of blur at the edges
    external void setEdgeBlur(num amount);

    /// Sets edge blur to 0
    external void disableEdgeBlur();

    /// Sets the amout of grain
    external void setGrainAmount(num amount);

    /// Set grain amount to 0
    external void disableGrain();

    /// Sets the chromatic aberration amount
    external void setChromaticAberration(num amount);

    /// Sets chromatic aberration amount to 0
    external void disableChromaticAberration();

    /// Sets the EdgeDistortion amount
    external void setEdgeDistortion(num amount);

    /// Sets edge distortion to 0
    external void disableEdgeDistortion();

    /// Sets the FocusDistance amount
    external void setFocusDistance(num amount);

    /// Disables depth of field
    external void disableDepthOfField();

    /// Sets the Aperture amount
    external void setAperture(num amount);

    /// Sets the DarkenOutOfFocus amount
    external void setDarkenOutOfFocus(num amount);

    /// Creates a pentagon bokeh effect
    external void enablePentagonBokeh();

    /// Disables the pentagon bokeh effect
    external void disablePentagonBokeh();

    /// Enables noise blur
    external void enableNoiseBlur();

    /// Disables noise blur
    external void disableNoiseBlur();

    /// Sets the HighlightsGain amount
    external void setHighlightsGain(num amount);

    /// Sets the HighlightsThreshold amount
    external void setHighlightsThreshold(num amount);

    /// Disables highlights
    external void disableHighlights();

    /// Removes the internal pipeline assets and detaches the pipeline from the scene cameras
    external void dispose([bool disableDepthRender]);

    external get JS$_createChromaticAberrationPostProcess;

    external set JS$_createChromaticAberrationPostProcess(v);

    external get JS$_createHighlightsPostProcess;

    external set JS$_createHighlightsPostProcess(v);

    external get JS$_createDepthOfFieldPostProcess;

    external set JS$_createDepthOfFieldPostProcess(v);

    external get JS$_createGrainTexture;

    external set JS$_createGrainTexture(v);
}

/// Render pipeline to produce ssao effect
@JS("BABYLON.SSAO2RenderingPipeline")
class SSAO2RenderingPipeline extends PostProcessRenderPipeline {
    // @Ignore
    SSAO2RenderingPipeline .fakeConstructor$() : super.fakeConstructor$();

    /// @ignore
    /// The PassPostProcess id in the pipeline that contains the original scene color
    external String get SSAOOriginalSceneColorEffect;

    external set SSAOOriginalSceneColorEffect(String v);

    /// @ignore
    /// The SSAO PostProcess id in the pipeline
    external String get SSAORenderEffect;

    external set SSAORenderEffect(String v);

    /// @ignore
    /// The horizontal blur PostProcess id in the pipeline
    external String get SSAOBlurHRenderEffect;

    external set SSAOBlurHRenderEffect(String v);

    /// @ignore
    /// The vertical blur PostProcess id in the pipeline
    external String get SSAOBlurVRenderEffect;

    external set SSAOBlurVRenderEffect(String v);

    /// @ignore
    /// The PostProcess id in the pipeline that combines the SSAO-Blur output with the original scene color (SSAOOriginalSceneColorEffect)
    external String get SSAOCombineRenderEffect;

    external set SSAOCombineRenderEffect(String v);

    /// The output strength of the SSAO post-process. Default value is 1.0.
    external num get totalStrength;

    external set totalStrength(num v);

    /// Maximum depth value to still render AO. A smooth falloff makes the dimming more natural, so there will be no abrupt shading change.
    external num get maxZ;

    external set maxZ(num v);

    /// In order to save performances, SSAO radius is clamped on close geometry. This ratio changes by how much
    external num get minZAspect;

    external set minZAspect(num v);

    external get JS$_samples;

    external set JS$_samples(v);

    /// Number of samples used for the SSAO calculations. Default value is 8
    external num get samples;

    external set samples(num v);

    external get JS$_textureSamples;

    external set JS$_textureSamples(v);

    /// Number of samples to use for antialiasing
    external num get textureSamples;

    external set textureSamples(num v);

    /// Ratio object used for SSAO ratio and blur ratio
    external get JS$_ratio;

    external set JS$_ratio(v);

    /// Dynamically generated sphere sampler.
    external get JS$_sampleSphere;

    external set JS$_sampleSphere(v);

    /// Blur filter offsets
    external get JS$_samplerOffsets;

    external set JS$_samplerOffsets(v);

    external get JS$_expensiveBlur;

    external set JS$_expensiveBlur(v);

    /// If bilateral blur should be used
    external bool get expensiveBlur;

    external set expensiveBlur(bool v);

    /// The radius around the analyzed pixel used by the SSAO post-process. Default value is 2.0
    external num get radius;

    external set radius(num v);

    /// The base color of the SSAO post-process
    /// The final result is "base + ssao" between [0, 1]
    external num get base;

    external set base(num v);

    /// Support test.
    external static bool get IsSupported;

    external static set IsSupported(bool v);

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_depthTexture;

    external set JS$_depthTexture(v);

    external get JS$_normalTexture;

    external set JS$_normalTexture(v);

    external get JS$_randomTexture;

    external set JS$_randomTexture(v);

    external get JS$_originalColorPostProcess;

    external set JS$_originalColorPostProcess(v);

    external get JS$_ssaoPostProcess;

    external set JS$_ssaoPostProcess(v);

    external get JS$_blurHPostProcess;

    external set JS$_blurHPostProcess(v);

    external get JS$_blurVPostProcess;

    external set JS$_blurVPostProcess(v);

    external get JS$_ssaoCombinePostProcess;

    external set JS$_ssaoCombinePostProcess(v);

    external get JS$_firstUpdate;

    external set JS$_firstUpdate(v);

    /// @constructor
    external factory SSAO2RenderingPipeline(String name, Scene scene, dynamic ratio, [List<Camera> cameras]);

    /// Removes the internal pipeline assets and detatches the pipeline from the scene cameras
    external void dispose([bool disableGeometryBufferRenderer]);

    external get JS$_createBlurPostProcess;

    external set JS$_createBlurPostProcess(v);

    /// @hidden
    external void JS$_rebuild();

    external get JS$_bits;

    external set JS$_bits(v);

    external get JS$_radicalInverse_VdC;

    external set JS$_radicalInverse_VdC(v);

    external get JS$_hammersley;

    external set JS$_hammersley(v);

    external get JS$_hemisphereSample_uniform;

    external set JS$_hemisphereSample_uniform(v);

    external get JS$_generateHemisphere;

    external set JS$_generateHemisphere(v);

    external get JS$_createSSAOPostProcess;

    external set JS$_createSSAOPostProcess(v);

    external get JS$_createSSAOCombinePostProcess;

    external set JS$_createSSAOCombinePostProcess(v);

    external get JS$_createRandomTexture;

    external set JS$_createRandomTexture(v);

    /// Serialize the rendering pipeline (Used when exporting)
    external dynamic serialize();

    /// Parse the serialized pipeline
    external static SSAO2RenderingPipeline Parse(dynamic source, Scene scene, String rootUrl);
}

/// Render pipeline to produce ssao effect
@JS("BABYLON.SSAORenderingPipeline")
class SSAORenderingPipeline extends PostProcessRenderPipeline {
    // @Ignore
    SSAORenderingPipeline .fakeConstructor$() : super.fakeConstructor$();

    /// @ignore
    /// The PassPostProcess id in the pipeline that contains the original scene color
    external String get SSAOOriginalSceneColorEffect;

    external set SSAOOriginalSceneColorEffect(String v);

    /// @ignore
    /// The SSAO PostProcess id in the pipeline
    external String get SSAORenderEffect;

    external set SSAORenderEffect(String v);

    /// @ignore
    /// The horizontal blur PostProcess id in the pipeline
    external String get SSAOBlurHRenderEffect;

    external set SSAOBlurHRenderEffect(String v);

    /// @ignore
    /// The vertical blur PostProcess id in the pipeline
    external String get SSAOBlurVRenderEffect;

    external set SSAOBlurVRenderEffect(String v);

    /// @ignore
    /// The PostProcess id in the pipeline that combines the SSAO-Blur output with the original scene color (SSAOOriginalSceneColorEffect)
    external String get SSAOCombineRenderEffect;

    external set SSAOCombineRenderEffect(String v);

    /// The output strength of the SSAO post-process. Default value is 1.0.
    external num get totalStrength;

    external set totalStrength(num v);

    /// The radius around the analyzed pixel used by the SSAO post-process. Default value is 0.0006
    external num get radius;

    external set radius(num v);

    /// Related to fallOff, used to interpolate SSAO samples (first interpolate function input) based on the occlusion difference of each pixel
    /// Must not be equal to fallOff and superior to fallOff.
    /// Default value is 0.975
    external num get area;

    external set area(num v);

    /// Related to area, used to interpolate SSAO samples (second interpolate function input) based on the occlusion difference of each pixel
    /// Must not be equal to area and inferior to area.
    /// Default value is 0.0
    external num get fallOff;

    external set fallOff(num v);

    /// The base color of the SSAO post-process
    /// The final result is "base + ssao" between [0, 1]
    external num get base;

    external set base(num v);

    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_depthTexture;

    external set JS$_depthTexture(v);

    external get JS$_randomTexture;

    external set JS$_randomTexture(v);

    external get JS$_originalColorPostProcess;

    external set JS$_originalColorPostProcess(v);

    external get JS$_ssaoPostProcess;

    external set JS$_ssaoPostProcess(v);

    external get JS$_blurHPostProcess;

    external set JS$_blurHPostProcess(v);

    external get JS$_blurVPostProcess;

    external set JS$_blurVPostProcess(v);

    external get JS$_ssaoCombinePostProcess;

    external set JS$_ssaoCombinePostProcess(v);

    external get JS$_firstUpdate;

    external set JS$_firstUpdate(v);

    /// @constructor
    external factory SSAORenderingPipeline(String name, Scene scene, dynamic ratio, [List<Camera> cameras]);

    /// Removes the internal pipeline assets and detatches the pipeline from the scene cameras
    external void dispose([bool disableDepthRender]);

    external get JS$_createBlurPostProcess;

    external set JS$_createBlurPostProcess(v);

    /// @hidden
    external void JS$_rebuild();

    external get JS$_createSSAOPostProcess;

    external set JS$_createSSAOPostProcess(v);

    external get JS$_createSSAOCombinePostProcess;

    external set JS$_createSSAOCombinePostProcess(v);

    external get JS$_createRandomTexture;

    external set JS$_createRandomTexture(v);
}

/// Standard rendering pipeline
/// Default pipeline should be used going forward but the standard pipeline will be kept for backwards compatibility.
/// @see https://doc.babylonjs.com/how_to/using_standard_rendering_pipeline
@JS("BABYLON.StandardRenderingPipeline")
class StandardRenderingPipeline extends PostProcessRenderPipeline implements IDisposable, IAnimatable {
    // @Ignore
    StandardRenderingPipeline .fakeConstructor$() : super.fakeConstructor$();

    /// Public members
    /// Post-process which contains the original scene color before the pipeline applies all the effects
    external PostProcess/*PostProcess|Null*/ get originalPostProcess;

    external set originalPostProcess(PostProcess/*PostProcess|Null*/ v);

    /// Post-process used to down scale an image x4
    external PostProcess/*PostProcess|Null*/ get downSampleX4PostProcess;

    external set downSampleX4PostProcess(PostProcess/*PostProcess|Null*/ v);

    /// Post-process used to calculate the illuminated surfaces controlled by a threshold
    external PostProcess/*PostProcess|Null*/ get brightPassPostProcess;

    external set brightPassPostProcess(PostProcess/*PostProcess|Null*/ v);

    /// Post-process array storing all the horizontal blur post-processes used by the pipeline
    external List<PostProcess> get blurHPostProcesses;

    external set blurHPostProcesses(List<PostProcess> v);

    /// Post-process array storing all the vertical blur post-processes used by the pipeline
    external List<PostProcess> get blurVPostProcesses;

    external set blurVPostProcesses(List<PostProcess> v);

    /// Post-process used to add colors of 2 textures (typically brightness + real scene color)
    external PostProcess/*PostProcess|Null*/ get textureAdderPostProcess;

    external set textureAdderPostProcess(PostProcess/*PostProcess|Null*/ v);

    /// Post-process used to create volumetric lighting effect
    external PostProcess/*PostProcess|Null*/ get volumetricLightPostProcess;

    external set volumetricLightPostProcess(PostProcess/*PostProcess|Null*/ v);

    /// Post-process used to smooth the previous volumetric light post-process on the X axis
    external BlurPostProcess/*BlurPostProcess|Null*/ get volumetricLightSmoothXPostProcess;

    external set volumetricLightSmoothXPostProcess(BlurPostProcess/*BlurPostProcess|Null*/ v);

    /// Post-process used to smooth the previous volumetric light post-process on the Y axis
    external BlurPostProcess/*BlurPostProcess|Null*/ get volumetricLightSmoothYPostProcess;

    external set volumetricLightSmoothYPostProcess(BlurPostProcess/*BlurPostProcess|Null*/ v);

    /// Post-process used to merge the volumetric light effect and the real scene color
    external PostProcess/*PostProcess|Null*/ get volumetricLightMergePostProces;

    external set volumetricLightMergePostProces(PostProcess/*PostProcess|Null*/ v);

    /// Post-process used to store the final volumetric light post-process (attach/detach for debug purpose)
    external PostProcess/*PostProcess|Null*/ get volumetricLightFinalPostProcess;

    external set volumetricLightFinalPostProcess(PostProcess/*PostProcess|Null*/ v);

    /// Base post-process used to calculate the average luminance of the final image for HDR
    external PostProcess/*PostProcess|Null*/ get luminancePostProcess;

    external set luminancePostProcess(PostProcess/*PostProcess|Null*/ v);

    /// Post-processes used to create down sample post-processes in order to get
    /// the average luminance of the final image for HDR
    /// Array of length "StandardRenderingPipeline.LuminanceSteps"
    external List<PostProcess> get luminanceDownSamplePostProcesses;

    external set luminanceDownSamplePostProcesses(List<PostProcess> v);

    /// Post-process used to create a HDR effect (light adaptation)
    external PostProcess/*PostProcess|Null*/ get hdrPostProcess;

    external set hdrPostProcess(PostProcess/*PostProcess|Null*/ v);

    /// Post-process used to store the final texture adder post-process (attach/detach for debug purpose)
    external PostProcess/*PostProcess|Null*/ get textureAdderFinalPostProcess;

    external set textureAdderFinalPostProcess(PostProcess/*PostProcess|Null*/ v);

    /// Post-process used to store the final lens flare post-process (attach/detach for debug purpose)
    external PostProcess/*PostProcess|Null*/ get lensFlareFinalPostProcess;

    external set lensFlareFinalPostProcess(PostProcess/*PostProcess|Null*/ v);

    /// Post-process used to merge the final HDR post-process and the real scene color
    external PostProcess/*PostProcess|Null*/ get hdrFinalPostProcess;

    external set hdrFinalPostProcess(PostProcess/*PostProcess|Null*/ v);

    /// Post-process used to create a lens flare effect
    external PostProcess/*PostProcess|Null*/ get lensFlarePostProcess;

    external set lensFlarePostProcess(PostProcess/*PostProcess|Null*/ v);

    /// Post-process that merges the result of the lens flare post-process and the real scene color
    external PostProcess/*PostProcess|Null*/ get lensFlareComposePostProcess;

    external set lensFlareComposePostProcess(PostProcess/*PostProcess|Null*/ v);

    /// Post-process used to create a motion blur effect
    external PostProcess/*PostProcess|Null*/ get motionBlurPostProcess;

    external set motionBlurPostProcess(PostProcess/*PostProcess|Null*/ v);

    /// Post-process used to create a depth of field effect
    external PostProcess/*PostProcess|Null*/ get depthOfFieldPostProcess;

    external set depthOfFieldPostProcess(PostProcess/*PostProcess|Null*/ v);

    /// The Fast Approximate Anti-Aliasing post process which attemps to remove aliasing from an image.
    external FxaaPostProcess/*FxaaPostProcess|Null*/ get fxaaPostProcess;

    external set fxaaPostProcess(FxaaPostProcess/*FxaaPostProcess|Null*/ v);

    /// Represents the brightness threshold in order to configure the illuminated surfaces
    external num get brightThreshold;

    external set brightThreshold(num v);

    /// Configures the blur intensity used for surexposed surfaces are highlighted surfaces (light halo)
    external num get blurWidth;

    external set blurWidth(num v);

    /// Sets if the blur for highlighted surfaces must be only horizontal
    external bool get horizontalBlur;

    external set horizontalBlur(bool v);

    /// Sets the overall exposure used by the pipeline
    external num get exposure;

    external set exposure(num v);

    /// Texture used typically to simulate "dirty" on camera lens
    external Texture/*Texture|Null*/ get lensTexture;

    external set lensTexture(Texture/*Texture|Null*/ v);

    /// Represents the offset coefficient based on Rayleigh principle. Typically in interval [-0.2, 0.2]
    external num get volumetricLightCoefficient;

    external set volumetricLightCoefficient(num v);

    /// The overall power of volumetric lights, typically in interval [0, 10] maximum
    external num get volumetricLightPower;

    external set volumetricLightPower(num v);

    /// Used the set the blur intensity to smooth the volumetric lights
    external num get volumetricLightBlurScale;

    external set volumetricLightBlurScale(num v);

    /// Light (spot or directional) used to generate the volumetric lights rays
    /// The source light must have a shadow generate so the pipeline can get its
    /// depth map
    external dynamic/*SpotLight|DirectionalLight|Null*/ get sourceLight;

    external set sourceLight(dynamic/*SpotLight|DirectionalLight|Null*/ v);

    /// For eye adaptation, represents the minimum luminance the eye can see
    external num get hdrMinimumLuminance;

    external set hdrMinimumLuminance(num v);

    /// For eye adaptation, represents the decrease luminance speed
    external num get hdrDecreaseRate;

    external set hdrDecreaseRate(num v);

    /// For eye adaptation, represents the increase luminance speed
    external num get hdrIncreaseRate;

    external set hdrIncreaseRate(num v);

    /// Lens color texture used by the lens flare effect. Mandatory if lens flare effect enabled
    external Texture/*Texture|Null*/ get lensColorTexture;

    external set lensColorTexture(Texture/*Texture|Null*/ v);

    /// The overall strengh for the lens flare effect
    external num get lensFlareStrength;

    external set lensFlareStrength(num v);

    /// Dispersion coefficient for lens flare ghosts
    external num get lensFlareGhostDispersal;

    external set lensFlareGhostDispersal(num v);

    /// Main lens flare halo width
    external num get lensFlareHaloWidth;

    external set lensFlareHaloWidth(num v);

    /// Based on the lens distortion effect, defines how much the lens flare result
    /// is distorted
    external num get lensFlareDistortionStrength;

    external set lensFlareDistortionStrength(num v);

    /// Lens star texture must be used to simulate rays on the flares and is available
    /// in the documentation
    external Texture/*Texture|Null*/ get lensStarTexture;

    external set lensStarTexture(Texture/*Texture|Null*/ v);

    /// As the "lensTexture" (can be the same texture or different), it is used to apply the lens
    /// flare effect by taking account of the dirt texture
    external Texture/*Texture|Null*/ get lensFlareDirtTexture;

    external set lensFlareDirtTexture(Texture/*Texture|Null*/ v);

    /// Represents the focal length for the depth of field effect
    external num get depthOfFieldDistance;

    external set depthOfFieldDistance(num v);

    /// Represents the blur intensity for the blurred part of the depth of field effect
    external num get depthOfFieldBlurWidth;

    external set depthOfFieldBlurWidth(num v);

    /// For motion blur, defines how much the image is blurred by the movement
    external num get motionStrength;

    external set motionStrength(num v);

    /// List of animations for the pipeline (IAnimatable implementation)
    external List<Animation> get animations;

    external set animations(List<Animation> v);

    /// Private members
    external get JS$_scene;

    external set JS$_scene(v);

    external get JS$_currentDepthOfFieldSource;

    external set JS$_currentDepthOfFieldSource(v);

    external get JS$_basePostProcess;

    external set JS$_basePostProcess(v);

    external get JS$_hdrCurrentLuminance;

    external set JS$_hdrCurrentLuminance(v);

    external get JS$_floatTextureType;

    external set JS$_floatTextureType(v);

    external get JS$_ratio;

    external set JS$_ratio(v);

    external get JS$_bloomEnabled;

    external set JS$_bloomEnabled(v);

    external get JS$_depthOfFieldEnabled;

    external set JS$_depthOfFieldEnabled(v);

    external get JS$_vlsEnabled;

    external set JS$_vlsEnabled(v);

    external get JS$_lensFlareEnabled;

    external set JS$_lensFlareEnabled(v);

    external get JS$_hdrEnabled;

    external set JS$_hdrEnabled(v);

    external get JS$_motionBlurEnabled;

    external set JS$_motionBlurEnabled(v);

    external get JS$_fxaaEnabled;

    external set JS$_fxaaEnabled(v);

    external get JS$_motionBlurSamples;

    external set JS$_motionBlurSamples(v);

    external get JS$_volumetricLightStepsCount;

    external set JS$_volumetricLightStepsCount(v);

    external get JS$_samples;

    external set JS$_samples(v);

    /// @ignore
    /// Specifies if the bloom pipeline is enabled
    external bool get BloomEnabled;

    external set BloomEnabled(bool v);

    /// @ignore
    /// Specifies if the depth of field pipeline is enabed
    external bool get DepthOfFieldEnabled;

    external set DepthOfFieldEnabled(bool v);

    /// @ignore
    /// Specifies if the lens flare pipeline is enabed
    external bool get LensFlareEnabled;

    external set LensFlareEnabled(bool v);

    /// @ignore
    /// Specifies if the HDR pipeline is enabled
    external bool get HDREnabled;

    external set HDREnabled(bool v);

    /// @ignore
    /// Specifies if the volumetric lights scattering effect is enabled
    external bool get VLSEnabled;

    external set VLSEnabled(bool v);

    /// @ignore
    /// Specifies if the motion blur effect is enabled
    external bool get MotionBlurEnabled;

    external set MotionBlurEnabled(bool v);

    /// Specifies if anti-aliasing is enabled
    external bool get fxaaEnabled;

    external set fxaaEnabled(bool v);

    /// Specifies the number of steps used to calculate the volumetric lights
    /// Typically in interval [50, 200]
    external num get volumetricLightStepsCount;

    external set volumetricLightStepsCount(num v);

    /// Specifies the number of samples used for the motion blur effect
    /// Typically in interval [16, 64]
    external num get motionBlurSamples;

    external set motionBlurSamples(num v);

    /// Specifies MSAA sample count, setting this to 4 will provide 4x anti aliasing. (default: 1)
    external num get samples;

    external set samples(num v);

    /// Default pipeline should be used going forward but the standard pipeline will be kept for backwards compatibility.
    /// @constructor
    external factory StandardRenderingPipeline(String name, Scene scene, num ratio, [PostProcess/*PostProcess|Null*/ originalPostProcess, List<Camera> cameras]);

    external get JS$_buildPipeline;

    external set JS$_buildPipeline(v);

    external get JS$_createDownSampleX4PostProcess;

    external set JS$_createDownSampleX4PostProcess(v);

    external get JS$_createBrightPassPostProcess;

    external set JS$_createBrightPassPostProcess(v);

    external get JS$_createBlurPostProcesses;

    external set JS$_createBlurPostProcesses(v);

    external get JS$_createTextureAdderPostProcess;

    external set JS$_createTextureAdderPostProcess(v);

    external get JS$_createVolumetricLightPostProcess;

    external set JS$_createVolumetricLightPostProcess(v);

    external get JS$_createLuminancePostProcesses;

    external set JS$_createLuminancePostProcesses(v);

    external get JS$_createHdrPostProcess;

    external set JS$_createHdrPostProcess(v);

    external get JS$_createLensFlarePostProcess;

    external set JS$_createLensFlarePostProcess(v);

    external get JS$_createDepthOfFieldPostProcess;

    external set JS$_createDepthOfFieldPostProcess(v);

    external get JS$_createMotionBlurPostProcess;

    external set JS$_createMotionBlurPostProcess(v);

    external get JS$_getDepthTexture;

    external set JS$_getDepthTexture(v);

    external get JS$_disposePostProcesses;

    external set JS$_disposePostProcesses(v);

    /// Dispose of the pipeline and stop all post processes
    external void dispose();

    /// Serialize the rendering pipeline (Used when exporting)
    external dynamic serialize();

    /// Parse the serialized pipeline
    external static StandardRenderingPipeline Parse(dynamic source, Scene scene, String rootUrl);

    /// Luminance steps
    external static num get LuminanceSteps;

    external static set LuminanceSteps(num v);
}


// End module BABYLON

/* Skipping class Window*/

/* Skipping class WebGLRenderingContext*/

/* Skipping class Document*/

/* Skipping class HTMLCanvasElement*/

/* Skipping class CanvasRenderingContext2D*/

/* Skipping class WebGLBuffer*/

/* Skipping class WebGLProgram*/

/* Skipping class MouseEvent*/

/* Skipping class Navigator*/

/* Skipping class HTMLVideoElement*/

/* Skipping class Element*/

/* Skipping class Screen*/
@anonymous
@JS()
abstract class Math {
    external num fround(num x);

    external num imul(num a, num b);
}

@anonymous
@JS()
abstract class EXT_disjoint_timer_query {
    external num get QUERY_COUNTER_BITS_EXT;

    external set QUERY_COUNTER_BITS_EXT(num v);

    external num get TIME_ELAPSED_EXT;

    external set TIME_ELAPSED_EXT(num v);

    external num get TIMESTAMP_EXT;

    external set TIMESTAMP_EXT(num v);

    external num get GPU_DISJOINT_EXT;

    external set GPU_DISJOINT_EXT(num v);

    external num get QUERY_RESULT_EXT;

    external set QUERY_RESULT_EXT(num v);

    external num get QUERY_RESULT_AVAILABLE_EXT;

    external set QUERY_RESULT_AVAILABLE_EXT(num v);

    external void queryCounterEXT(WebGLQuery query, num target);

    external WebGLQuery createQueryEXT();

    external void beginQueryEXT(num target, WebGLQuery query);

    external void endQueryEXT(num target);

    external dynamic getQueryObjectEXT(WebGLQuery query, num target);

    external void deleteQueryEXT(WebGLQuery query);
}


/* Skipping class WebGLUniformLocation*/
@JS()
external void importScripts([String urls1, String urls2, String urls3, String urls4, String urls5]);

@JS()
external dynamic get safePostMessage;

@JS("VRDisplay")
abstract class VRDisplay implements EventTarget {
    external VRDisplayCapabilities get capabilities;

    external set capabilities(VRDisplayCapabilities v);

    external num get depthFar;

    external set depthFar(num v);

    external num get depthNear;

    external set depthNear(num v);

    external num get displayId;

    external set displayId(num v);

    external String get displayName;

    external set displayName(String v);

    external bool get isConnected;

    external set isConnected(bool v);

    external bool get isPresenting;

    external set isPresenting(bool v);

    external VRStageParameters/*VRStageParameters|Null*/ get stageParameters;

    external set stageParameters(VRStageParameters/*VRStageParameters|Null*/ v);

    external void cancelAnimationFrame(num handle);

    external Promise<Null> exitPresent();

    external VREyeParameters getEyeParameters(String whichEye);

    external bool getFrameData(VRFrameData frameData);

    external List<VRLayer> getLayers();

    external VRPose getPose();

    external VRPose getImmediatePose();

    external num requestAnimationFrame(FrameRequestCallback callback);

    external Promise<Null> requestPresent(List<VRLayer> layers);

    external void resetPose();

    external void submitFrame([VRPose pose]);

    external static VRDisplay get prototype;

    external static set prototype(VRDisplay v);

    external factory VRDisplay();
}

@anonymous
@JS()
abstract class VRLayer {
    external dynamic/*List<num>|Float32List|Null*/ get leftBounds;

    external set leftBounds(dynamic/*List<num>|Float32List|Null*/ v);

    external dynamic/*List<num>|Float32List|Null*/ get rightBounds;

    external set rightBounds(dynamic/*List<num>|Float32List|Null*/ v);

    external CanvasElement/*CanvasElement|Null*/ get source;

    external set source(CanvasElement/*CanvasElement|Null*/ v);

    external factory VRLayer({ dynamic/*List<num>|Float32List|Null*/ leftBounds, dynamic/*List<num>|Float32List|Null*/ rightBounds, CanvasElement/*CanvasElement|Null*/ source});
}

@anonymous
@JS()
abstract class VRDisplayCapabilities {
    external bool get canPresent;

    external set canPresent(bool v);

    external bool get hasExternalDisplay;

    external set hasExternalDisplay(bool v);

    external bool get hasOrientation;

    external set hasOrientation(bool v);

    external bool get hasPosition;

    external set hasPosition(bool v);

    external num get maxLayers;

    external set maxLayers(num v);

    external factory VRDisplayCapabilities({ bool canPresent, bool hasExternalDisplay, bool hasOrientation, bool hasPosition, num maxLayers});
}

@anonymous
@JS()
abstract class VREyeParameters {
    external VRFieldOfView get fieldOfView;

    external set fieldOfView(VRFieldOfView v);

    external Float32List get offset;

    external set offset(Float32List v);

    external num get renderHeight;

    external set renderHeight(num v);

    external num get renderWidth;

    external set renderWidth(num v);

    external factory VREyeParameters({ VRFieldOfView fieldOfView, Float32List offset, num renderHeight, num renderWidth});
}

@anonymous
@JS()
abstract class VRFieldOfView {
    external num get downDegrees;

    external set downDegrees(num v);

    external num get leftDegrees;

    external set leftDegrees(num v);

    external num get rightDegrees;

    external set rightDegrees(num v);

    external num get upDegrees;

    external set upDegrees(num v);

    external factory VRFieldOfView({ num downDegrees, num leftDegrees, num rightDegrees, num upDegrees});
}

@anonymous
@JS()
abstract class VRFrameData {
    external Float32List get leftProjectionMatrix;

    external set leftProjectionMatrix(Float32List v);

    external Float32List get leftViewMatrix;

    external set leftViewMatrix(Float32List v);

    external VRPose get pose;

    external set pose(VRPose v);

    external Float32List get rightProjectionMatrix;

    external set rightProjectionMatrix(Float32List v);

    external Float32List get rightViewMatrix;

    external set rightViewMatrix(Float32List v);

    external num get timestamp;

    external set timestamp(num v);

    external factory VRFrameData({ Float32List leftProjectionMatrix, Float32List leftViewMatrix, VRPose pose, Float32List rightProjectionMatrix, Float32List rightViewMatrix, num timestamp});
}

@anonymous
@JS()
abstract class VRPose {
    external Float32List/*Float32List|Null*/ get angularAcceleration;

    external set angularAcceleration(Float32List/*Float32List|Null*/ v);

    external Float32List/*Float32List|Null*/ get angularVelocity;

    external set angularVelocity(Float32List/*Float32List|Null*/ v);

    external Float32List/*Float32List|Null*/ get linearAcceleration;

    external set linearAcceleration(Float32List/*Float32List|Null*/ v);

    external Float32List/*Float32List|Null*/ get linearVelocity;

    external set linearVelocity(Float32List/*Float32List|Null*/ v);

    external Float32List/*Float32List|Null*/ get orientation;

    external set orientation(Float32List/*Float32List|Null*/ v);

    external Float32List/*Float32List|Null*/ get position;

    external set position(Float32List/*Float32List|Null*/ v);

    external num get timestamp;

    external set timestamp(num v);

    external factory VRPose({ Float32List/*Float32List|Null*/ angularAcceleration, Float32List/*Float32List|Null*/ angularVelocity, Float32List/*Float32List|Null*/ linearAcceleration, Float32List/*Float32List|Null*/ linearVelocity, Float32List/*Float32List|Null*/ orientation, Float32List/*Float32List|Null*/ position, num timestamp});
}

@anonymous
@JS()
abstract class VRStageParameters {
    external Float32List get sittingToStandingTransform;

    external set sittingToStandingTransform(Float32List v);

    external num get sizeX;

    external set sizeX(num v);

    external num get sizeY;

    external set sizeY(num v);

    external factory VRStageParameters({ Float32List sittingToStandingTransform, num sizeX, num sizeY});
}


/* Skipping class Window*/

/* Skipping class Gamepad*/
@anonymous
@JS()
abstract class ImageBitmap {
    external num get width;

    external set width(num v);

    external num get height;

    external set height(num v);

    external void close();
}

@JS("WebGLQuery")
abstract class WebGLQuery implements WebGLObject {
    external static WebGLQuery get prototype;

    external static set prototype(WebGLQuery v);

    external factory WebGLQuery();
}

@JS("WebGLSampler")
abstract class WebGLSampler implements WebGLObject {
    external static WebGLSampler get prototype;

    external static set prototype(WebGLSampler v);

    external factory WebGLSampler();
}

@JS("WebGLSync")
abstract class WebGLSync implements WebGLObject {
    external static WebGLSync get prototype;

    external static set prototype(WebGLSync v);

    external factory WebGLSync();
}

@JS("WebGLTransformFeedback")
abstract class WebGLTransformFeedback implements WebGLObject {
    external static WebGLTransformFeedback get prototype;

    external static set prototype(WebGLTransformFeedback v);

    external factory WebGLTransformFeedback();
}

@JS("WebGLVertexArrayObject")
abstract class WebGLVertexArrayObject implements WebGLObject {
    external static WebGLVertexArrayObject get prototype;

    external static set prototype(WebGLVertexArrayObject v);

    external factory WebGLVertexArrayObject();
}

@anonymous
@JS()
abstract class MediaRecorder {
    external void start(num timeSlice);

    external void stop();

    external VoidFunc1<ErrorEvent> get onerror;

    external set onerror(VoidFunc1<ErrorEvent> v);

    external VoidFunc1<Event> get onstop;

    external set onstop(VoidFunc1<Event> v);

    external VoidFunc1<Event> get ondataavailable;

    external set ondataavailable(VoidFunc1<Event> v);
}

@anonymous
@JS()
abstract class MediaRecorderOptions {
    external String get mimeType;

    external set mimeType(String v);

    external num get audioBitsPerSecond;

    external set audioBitsPerSecond(num v);

    external num get videoBitsPerSecond;

    external set videoBitsPerSecond(num v);

    external num get bitsPerSecond;

    external set bitsPerSecond(num v);

    external factory MediaRecorderOptions({ String mimeType, num audioBitsPerSecond, num videoBitsPerSecond, num bitsPerSecond});
}

@JS("MediaRecorder")
abstract class MediaRecorderConstructor {
    external MediaRecorder get prototype;

    external set prototype(MediaRecorder v);

    external factory MediaRecorderConstructor(MediaStream stream, [MediaRecorderOptions options]);
}

@JS()
external MediaRecorderConstructor get MediaRecorder;

@JS()
external set MediaRecorder(MediaRecorderConstructor v);

@JS()
external dynamic get DracoDecoderModule;

@JS()
external set DracoDecoderModule(dynamic v);

@JS()
external dynamic get WebAssembly;

@JS()
external set WebAssembly(dynamic v);